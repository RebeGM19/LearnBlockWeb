// Do not edit this file; automatically generated by build.py.
'use strict';

//Mapping of block type names to block prototype objects
var LearnBlock = {};
LearnBlock.Blocks = Object.create(null);

LearnBlock.utils = {};
//Reference to the global object
LearnBlock.utils.global = function () {
    return "object" === typeof self ? self : "object" === typeof window ? window : "object" === typeof global ? global : this
}();
//Msg singleton
LearnBlock.Msg = {};
LearnBlock.utils.global.Blockly || (LearnBlock.utils.global.Blockly = {});
LearnBlock.utils.global.LearnBlock.Msg || (LearnBlock.utils.global.LearnBlock.Msg = LearnBlock.Msg);

//Represents coordinates and positions
LearnBlock.utils.Coordinate = function (a, b) {
    this.x = a;
    this.y = b
};
//Compares if equal
LearnBlock.utils.Coordinate.equals = function (a, b) {
    return a == b ? !0 : a && b ? a.x == b.x && a.y == b.y : !1
};
//Returns distance between two coordinates
LearnBlock.utils.Coordinate.distance = function (a, b) {
    var c = a.x - b.x,
        d = a.y - b.y;
    return Math.sqrt(c * c + d * d)
};
//Returns magnitude
LearnBlock.utils.Coordinate.magnitude = function (a) {
    return Math.sqrt(a.x * a.x + a.y * a.y)
};
//Returns difference between two coordenates
LearnBlock.utils.Coordinate.difference = function (a, b) {
    return new LearnBlock.utils.Coordinate(a.x - b.x, a.y - b.y)
};
//Returns sum between two coordenates
LearnBlock.utils.Coordinate.sum = function (a, b) {
    return new LearnBlock.utils.Coordinate(a.x + b.x, a.y + b.y)
};
//Scales the coordinate by the given factor
LearnBlock.utils.Coordinate.prototype.scale = function (a) {
    this.x *= a;
    this.y *= a;
    return this
};
//Translates the coordinate by the given offsets
LearnBlock.utils.Coordinate.prototype.translate = function (a, b) {
    this.x += a;
    this.y += b;
    return this
};

//String utils
LearnBlock.utils.string = {};
//Fast prefix-checker
LearnBlock.utils.string.startsWith = function (a, b) {
    return 0 == a.lastIndexOf(b, 0)
};
//Given an array of strings, returns the length of the shortest one
LearnBlock.utils.string.shortestStringLength = function (a) {
    return a.length ? a.reduce(function (a, c) {
        return a.length < c.length ? a : c
    }).length : 0
};
//Given an array of strings, returns the length of the common prefix
LearnBlock.utils.string.commonWordPrefix = function (a, b) {
    if (!a.length) return 0;
    if (1 == a.length) return a[0].length;
    for (var c = 0, d = b || LearnBlock.utils.string.shortestStringLength(a), e = 0; e < d; e++) {
        for (var f = a[0][e], g = 1; g < a.length; g++)
            if (f != a[g][e]) return c;
        " " == f && (c = e + 1)
    }
    for (g = 1; g < a.length; g++)
        if ((f = a[g][e]) && " " != f) return c;
    return d
};
//Given an array of strings, returns the length of the common suffix
LearnBlock.utils.string.commonWordSuffix = function (a, b) {
    if (!a.length) return 0;
    if (1 == a.length) return a[0].length;
    for (var c = 0, d = b || LearnBlock.utils.string.shortestStringLength(a), e = 0; e < d; e++) {
        for (var f = a[0].substr(-e - 1, 1), g = 1; g < a.length; g++)
            if (f != a[g].substr(-e - 1, 1)) return c;
        " " == f && (c = e + 1)
    }
    for (g = 1; g < a.length; g++)
        if ((f = a[g].charAt(a[g].length - e - 1)) && " " != f) return c;
    return d
};
//Wraps text to the specified width
LearnBlock.utils.string.wrap = function (a, b) {
    for (var c = a.split("\n"), d = 0; d < c.length; d++) c[d] = LearnBlock.utils.string.wrapLine_(c[d], b);
    return c.join("\n")
};
//Wraps single line of text to the specified width
LearnBlock.utils.string.wrapLine_ = function (a, b) {
    if (a.length <= b) return a;
    for (var c = a.trim().split(/\s+/), d = 0; d < c.length; d++) c[d].length > b && (b = c[d].length);
    d = -Infinity;
    var e = 1;
    do {
        var f = d;
        var g = a;
        var h = [],
            k = c.length / e,
            l = 1;
        for (d = 0; d < c.length - 1; d++) l < (d + 1.5) / k ? (l++, h[d] = !0) : h[d] = !1;
        h = LearnBlock.utils.string.wrapMutate_(c, h, b);
        d = LearnBlock.utils.string.wrapScore_(c, h, b);
        a = LearnBlock.utils.string.wrapToText_(c, h);
        e++
    } while (d > f);
    return g
};
//Computes a score for how good the wrapping is
LearnBlock.utils.string.wrapScore_ = function (a, b, c) {
    for (var d = [0], e = [], f = 0; f < a.length; f++) d[d.length - 1] += a[f].length, !0 === b[f] ? (d.push(0), e.push(a[f].charAt(a[f].length - 1))) : !1 === b[f] && d[d.length - 1]++;
    a = Math.max.apply(Math, d);
    for (f = b = 0; f < d.length; f++) b -= 2 * Math.pow(Math.abs(c - d[f]), 1.5), b -= Math.pow(a - d[f], 1.5), -1 != ".?!".indexOf(e[f]) ? b += c / 3 : -1 != ",;)]}".indexOf(e[f]) && (b += c / 4);
    1 < d.length && d[d.length - 1] <= d[d.length - 2] && (b += .5);
    return b
};
//Mutates the array of line break locations until an optimal solution is found
LearnBlock.utils.string.wrapMutate_ = function (a, b, c) {
    for (var d = LearnBlock.utils.string.wrapScore_(a, b, c), e, f = 0; f < b.length - 1; f++)
        if (b[f] != b[f + 1]) {
            var g = [].concat(b);
            g[f] = !g[f];
            g[f + 1] = !g[f + 1];
            var h = LearnBlock.utils.string.wrapScore_(a, g, c);
            h > d && (d = h, e = g)
        } return e ? LearnBlock.utils.string.wrapMutate_(a, e, c) : b
};
//Reassembles the array of words into text, with the specified line breaks
LearnBlock.utils.string.wrapToText_ = function (a, b) {
    for (var c = [], d = 0; d < a.length; d++) c.push(a[d]), void 0 !== b[d] && c.push(b[d] ? "\n" : " ");
    return c.join("")
};

//Class for representing sizes consisting of a width and height
LearnBlock.utils.Size = function (a, b) {
    this.width = a;
    this.height = b
};
//Compares sizes for equality
LearnBlock.utils.Size.equals = function (a, b) {
    return a == b ? !0 : a && b ? a.width == b.width && a.height == b.height : !1
};

//Style utils
LearnBlock.utils.style = {};
//Gets the height and width of an element
LearnBlock.utils.style.getSize = function (a) {
    if ("none" != LearnBlock.utils.style.getStyle_(a, "display")) return LearnBlock.utils.style.getSizeWithDisplay_(a);
    var b = a.style,
        c = b.display,
        d = b.visibility,
        e = b.position;
    b.visibility = "hidden";
    b.position = "absolute";
    b.display = "inline";
    var f = a.offsetWidth;
    a = a.offsetHeight;
    b.display = c;
    b.position = e;
    b.visibility = d;
    return new LearnBlock.utils.Size(f, a)
};
//Gets the height and width of an element when the display is not none
LearnBlock.utils.style.getSizeWithDisplay_ = function (a) {
    return new LearnBlock.utils.Size(a.offsetWidth, a.offsetHeight)
};
//Cross-browser pseudo get computed style. It returns the computed style
LearnBlock.utils.style.getStyle_ = function (a, b) {
    return LearnBlock.utils.style.getComputedStyle(a, b) || LearnBlock.utils.style.getCascadedStyle(a, b) || a.style && a.style[b]
};
//Retrieves a computed style value of a node
LearnBlock.utils.style.getComputedStyle = function (a, b) {
    if (document.defaultView && document.defaultView.getComputedStyle) {
        var c = document.defaultView.getComputedStyle(a, null);
        if (c) return c[b] || c.getPropertyValue(b) || ""
    }
    return ""
};
//Gets the cascaded style value of a node
LearnBlock.utils.style.getCascadedStyle = function (a, b) {
    return a.currentStyle ? a.currentStyle[b] : null
};
//Returns a Coordinate object relative to the top-left of the HTML document
LearnBlock.utils.style.getPageOffset = function (a) {
    var b = new LearnBlock.utils.Coordinate(0, 0);
    a = a.getBoundingClientRect();
    var c = document.documentElement;
    c = new LearnBlock.utils.Coordinate(window.pageXOffset || c.scrollLeft, window.pageYOffset || c.scrollTop);
    b.x = a.left + c.x;
    b.y = a.top + c.y;
    return b
};
//Calculates the viewport coordinates relative to the document
LearnBlock.utils.style.getViewportPageOffset = function () {
    var a = document.body,
        b = document.documentElement;
    return new LearnBlock.utils.Coordinate(a.scrollLeft || b.scrollLeft, a.scrollTop || b.scrollTop)
};
//Shows or hides an element from the page
LearnBlock.utils.style.setElementShown = function (a, b) {
    a.style.display = b ? "" : "none"
};
//Returns true if the element is using right to left direction
LearnBlock.utils.style.isRightToLeft = function (a) {
    return "rtl" == LearnBlock.utils.style.getStyle_(a, "direction")
};
//Gets the computed border widths in pixels
LearnBlock.utils.style.getBorderBox = function (a) {
    var b = LearnBlock.utils.style.getComputedStyle(a, "borderLeftWidth"),
        c = LearnBlock.utils.style.getComputedStyle(a, "borderRightWidth"),
        d = LearnBlock.utils.style.getComputedStyle(a, "borderTopWidth");
    a = LearnBlock.utils.style.getComputedStyle(a, "borderBottomWidth");
    return {
        top: parseFloat(d),
        right: parseFloat(c),
        bottom: parseFloat(a),
        left: parseFloat(b)
    }
};
//Changes the scroll position of container with the minimum amount so that the content and the borders of the given element become visible
LearnBlock.utils.style.scrollIntoContainerView = function (a, b, c) {
    a = LearnBlock.utils.style.getContainerOffsetToScrollInto(a, b, c);
    b.scrollLeft = a.x;
    b.scrollTop = a.y
};
//Calculates the scroll position of container with the minimum amount so that the content and the borders of the given element become visible
LearnBlock.utils.style.getContainerOffsetToScrollInto = function (a, b, c) {
    var d = LearnBlock.utils.style.getPageOffset(a),
        e = LearnBlock.utils.style.getPageOffset(b),
        f = LearnBlock.utils.style.getBorderBox(b),
        g = d.x - e.x - f.left;
    d = d.y - e.y - f.top;
    e = LearnBlock.utils.style.getSizeWithDisplay_(a);
    a = b.clientWidth - e.width;
    e = b.clientHeight - e.height;
    f = b.scrollLeft;
    b = b.scrollTop;
    c ? (f += g - a / 2, b += d - e / 2) : (f += Math.min(g, Math.max(g - a, 0)), b += Math.min(d, Math.max(d - e, 0)));
    return new LearnBlock.utils.Coordinate(f, b)
};

//UserAgent utils
LearnBlock.utils.userAgent = {};
//UserAgent detection
(function (a) {
    function b(a) {
        return -1 != c.indexOf(a.toUpperCase())
    }
    LearnBlock.utils.userAgent.raw = a;
    var c = LearnBlock.utils.userAgent.raw.toUpperCase();
    LearnBlock.utils.userAgent.IE = b("Trident") || b("MSIE");
    LearnBlock.utils.userAgent.EDGE = b("Edge");
    LearnBlock.utils.userAgent.JAVA_FX = b("JavaFX");
    LearnBlock.utils.userAgent.WEBKIT = b("WebKit") && !LearnBlock.utils.userAgent.EDGE;
    LearnBlock.utils.userAgent.GECKO = b("Gecko") && !LearnBlock.utils.userAgent.WEBKIT && !LearnBlock.utils.userAgent.IE && !LearnBlock.utils.userAgent.EDGE;
})(LearnBlock.utils.global.navigator && LearnBlock.utils.global.navigator.userAgent || "");
//Don't do anything for this event, just halt propagation
LearnBlock.utils.noEvent = function (a) {
    a.preventDefault();
    a.stopPropagation()
};
//Is this event targeting a text input widget?
LearnBlock.utils.isTargetInput = function (a) {
    return "textarea" == a.target.type || "text" == a.target.type || "number" == a.target.type || "email" == a.target.type || "password" == a.target.type || "search" == a.target.type || "tel" == a.target.type || "url" == a.target.type || a.target.isContentEditable
};
//Returns the coordinates of the top-left corner of the element relative to its parent
LearnBlock.utils.getRelativeXY = function (a) {
    var b = new LearnBlock.utils.Coordinate(0, 0),
        c = a.getAttribute("x");
    c && (b.x = parseInt(c, 10));
    if (c = a.getAttribute("y")) b.y = parseInt(c, 10);
    if (c = (c = a.getAttribute("transform")) && c.match(LearnBlock.utils.getRelativeXY.XY_REGEX_)) b.x += Number(c[1]), c[3] && (b.y += Number(c[3]));
    (a = a.getAttribute("style")) && -1 < a.indexOf("translate") && (a = a.match(LearnBlock.utils.getRelativeXY.XY_STYLE_REGEX_)) && (b.x += Number(a[1]), a[3] && (b.y += Number(a[3])));
    return b
};
//Returns the coordinates of the top-left corner of this element relative to the div LearnBlock was injected into
LearnBlock.utils.getInjectionDivXY_ = function (a) {
    for (var b = 0, c = 0; a;) {
        var d = LearnBlock.utils.getRelativeXY(a);
        b += d.x;
        c += d.y;
        if (-1 != (" " + (a.getAttribute("class") || "") + " ").indexOf(" injectionDiv ")) break;
        a = a.parentNode
    }
    return new LearnBlock.utils.Coordinate(b, c)
};
//Static regex to pull the x,y values out of an SVG translate() directive
LearnBlock.utils.getRelativeXY.XY_REGEX_ = /translate\(\s*([-+\d.e]+)([ ,]\s*([-+\d.e]+)\s*)?/;
//Static regex to pull the x,y values out of a translate() or translate3d() style property
LearnBlock.utils.getRelativeXY.XY_STYLE_REGEX_ = /transform:\s*translate(?:3d)?\(\s*([-+\d.e]+)\s*px([ ,]\s*([-+\d.e]+)\s*px)?/;
//Is this event a right-click?
LearnBlock.utils.isRightButton = function (a) {
    return a.ctrlKey && LearnBlock.utils.userAgent.MAC ? !0 : 2 == a.button
};
//Returns the converted coordinates of the given mouse event
LearnBlock.utils.mouseToSvg = function (a, b, c) {
    var d = b.createSVGPoint();
    d.x = a.clientX;
    d.y = a.clientY;
    c || (c = b.getScreenCTM().inverse());
    return d.matrixTransform(c)
};
//Gets the scroll delta of a mouse event in pixel units
LearnBlock.utils.getScrollDeltaPixels = function (a) {
    switch (a.deltaMode) {
        case 0:
            return {
                x: a.deltaX, y: a.deltaY
            };
        case 1:
            return {
                x: a.deltaX * LearnBlock.LINE_MODE_MULTIPLIER, y: a.deltaY * LearnBlock.LINE_MODE_MULTIPLIER
            };
        case 2:
            return {
                x: a.deltaX * LearnBlock.PAGE_MODE_MULTIPLIER, y: a.deltaY * LearnBlock.PAGE_MODE_MULTIPLIER
            }
    }
};
//Parses a string with any number of interpolation tokens
LearnBlock.utils.tokenizeInterpolation = function (a) {
    return LearnBlock.utils.tokenizeInterpolation_(a, !0)
};
//Replaces string table references in a message, if the message is a string
LearnBlock.utils.replaceMessageReferences = function (a) {
    if ("string" != typeof a) return a;
    a = LearnBlock.utils.tokenizeInterpolation_(a, !1);
    return a.length ? a[0] : ""
};
//Validates that any msg key references in the message refer to keys of the LearnBlock.Msg string table
LearnBlock.utils.checkMessageReferences = function (a) {
    for (var b = !0, c = LearnBlock.Msg, d = a.match(/%{BKY_[A-Z]\w*}/ig), e = 0; e < d.length; e++) {
        var f = d[e].toUpperCase();
        void 0 == c[f.slice(6, -1)] && (console.log("WARNING: No message string for " + d[e] + " in " + a), b = !1)
    }
    return b
};
//Internal implementation of the message reference and interpolation token parsing used by tokenizeInterpolation() and replaceMessageReferences()
LearnBlock.utils.tokenizeInterpolation_ = function (a, b) {
    var c = [],
        d = a.split("");
    d.push("");
    for (var e = 0, f = [], g = null, h = 0; h < d.length; h++) {
        var k = d[h];
        0 == e ? "%" == k ? ((k = f.join("")) && c.push(k), f.length = 0, e = 1) : f.push(k) : 1 == e ? "%" == k ? (f.push(k), e = 0) : b && "0" <= k && "9" >= k ? (e = 2, g = k, (k = f.join("")) && c.push(k), f.length = 0) : "{" == k ? e = 3 : (f.push("%", k), e = 0) : 2 == e ? "0" <= k && "9" >= k ? g += k : (c.push(parseInt(g, 10)), h--, e = 0) : 3 == e && ("" == k ? (f.splice(0, 0, "%{"), h--, e = 0) : "}" != k ? f.push(k) : (e = f.join(""), /[A-Z]\w*/i.test(e) ? (k = e.toUpperCase(), (k =
            LearnBlock.utils.string.startsWith(k, "BKY_") ? k.substring(4) : null) && k in LearnBlock.Msg ? (e = LearnBlock.Msg[k], "string" == typeof e ? Array.prototype.push.apply(c, LearnBlock.utils.tokenizeInterpolation_(e, b)) : b ? c.push(String(e)) : c.push(e)) : c.push("%{" + e + "}")) : c.push("%{" + e + "}"), e = f.length = 0))
    }(k = f.join("")) && c.push(k);
    d = [];
    for (h = f.length = 0; h < c.length; ++h) "string" == typeof c[h] ? f.push(c[h]) : ((k = f.join("")) && d.push(k), f.length = 0, d.push(c[h]));
    (k = f.join("")) && d.push(k);
    f.length = 0;
    return d
};
//Generates a unique ID
LearnBlock.utils.genUid = function () {
    for (var a = LearnBlock.utils.genUid.soup_.length, b = [], c = 0; 20 > c; c++) b[c] = LearnBlock.utils.genUid.soup_.charAt(Math.random() * a);
    return b.join("")
};
//Legal characters for the unique ID
LearnBlock.utils.genUid.soup_ = "!#$%()*+,-./:;=?@[]^_`{|}~ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
//Checks if 3D transforms are supported by adding an element and attempting to set the property
LearnBlock.utils.is3dSupported = function () {
    if (void 0 !== LearnBlock.utils.is3dSupported.cached_) return LearnBlock.utils.is3dSupported.cached_;
    if (!LearnBlock.utils.global.getComputedStyle) return !1;
    var a = document.createElement("p"),
        b = "none",
        c = {
            webkitTransform: "-webkit-transform",
            OTransform: "-o-transform",
            msTransform: "-ms-transform",
            MozTransform: "-moz-transform",
            transform: "transform"
        };
    document.body.insertBefore(a, null);
    for (var d in c)
        if (void 0 !== a.style[d]) {
            a.style[d] = "translate3d(1px,1px,1px)";
            b = LearnBlock.utils.global.getComputedStyle(a);
            if (!b) return document.body.removeChild(a), !1;
            b = b.getPropertyValue(c[d])
        } document.body.removeChild(a);
    LearnBlock.utils.is3dSupported.cached_ = "none" !== b;
    return LearnBlock.utils.is3dSupported.cached_
};
//Calls a function after the page has loaded
LearnBlock.utils.runAfterPageLoad = function (a) {
    if ("object" != typeof document) throw Error("LearnBlock.utils.runAfterPageLoad() requires browser document.");
    if ("complete" == document.readyState) a();
    else var b = setInterval(function () {
        "complete" == document.readyState && (clearInterval(b), a())
    }, 10)
};
//Gets the position of the current viewport in window coordinates
LearnBlock.utils.getViewportBBox = function () {
    var a = LearnBlock.utils.style.getViewportPageOffset();
    return {
        right: document.documentElement.clientWidth + a.x,
        bottom: document.documentElement.clientHeight + a.y,
        top: a.y,
        left: a.x
    }
};
//Removes the first occurrence of a particular value from an array
LearnBlock.utils.arrayRemove = function (a, b) {
    var c = a.indexOf(b);
    if (-1 == c) return !1;
    a.splice(c, 1);
    return !0
};
//Gets the document scroll distance as a coordinate object
LearnBlock.utils.getDocumentScroll = function () {
    var a = document.documentElement,
        b = window;
    return LearnBlock.utils.userAgent.IE && b.pageYOffset != a.scrollTop ? new LearnBlock.utils.Coordinate(a.scrollLeft, a.scrollTop) : new LearnBlock.utils.Coordinate(b.pageXOffset || a.scrollLeft, b.pageYOffset || a.scrollTop)
};
//Gets a map of all the block's descendants mapping their type to the number of children with that type
LearnBlock.utils.getBlockTypeCounts = function (a, b) {
    var c = Object.create(null),
        d = a.getDescendants(!0);
    if (b) {
        var e = a.getNextBlock();
        e && (e = d.indexOf(e), d.splice(e, d.length - e))
    }
    e = 0;
    for (var f; f = d[e]; e++) c[f.type] ? c[f.type]++ : c[f.type] = 1;
    return c
};
//Converts screen coordinates to workspace coordinates
LearnBlock.utils.screenToWsCoordinates = function (a, b) {
    var c = b.x,
        d = b.y,
        e = a.getInjectionDiv().getBoundingClientRect();
    c = new LearnBlock.utils.Coordinate(c - e.left, d - e.top);
    d = a.getOriginOffsetInPixels();
    return LearnBlock.utils.Coordinate.difference(c, d).scale(1 / a.scale)
};

//Events functions
LearnBlock.Events = {};
//Events definitions
LearnBlock.Events.group_ = "";
LearnBlock.Events.recordUndo = !0;
LearnBlock.Events.disabled_ = 0;
LearnBlock.Events.CREATE = "create";
LearnBlock.Events.BLOCK_CREATE = LearnBlock.Events.CREATE;
LearnBlock.Events.DELETE = "delete";
LearnBlock.Events.BLOCK_DELETE = LearnBlock.Events.DELETE;
LearnBlock.Events.CHANGE = "change";
LearnBlock.Events.BLOCK_CHANGE = LearnBlock.Events.CHANGE;
LearnBlock.Events.MOVE = "move";
LearnBlock.Events.BLOCK_MOVE = LearnBlock.Events.MOVE;
LearnBlock.Events.VAR_CREATE = "var_create";
LearnBlock.Events.VAR_DELETE = "var_delete";
LearnBlock.Events.VAR_RENAME = "var_rename";
LearnBlock.Events.UI = "ui";
LearnBlock.Events.COMMENT_MOVE = "comment_move";
LearnBlock.Events.FINISHED_LOADING = "finished_loading";
LearnBlock.Events.BUMP_EVENTS = [LearnBlock.Events.BLOCK_CREATE, LearnBlock.Events.BLOCK_MOVE, LearnBlock.Events.COMMENT_CREATE, LearnBlock.Events.COMMENT_MOVE];
LearnBlock.Events.FIRE_QUEUE_ = [];
//Creates a custom event and fires it
LearnBlock.Events.fire = function (a) {
    LearnBlock.Events.isEnabled() && (LearnBlock.Events.FIRE_QUEUE_.length || setTimeout(LearnBlock.Events.fireNow_, 0), LearnBlock.Events.FIRE_QUEUE_.push(a))
};
//Fires all queued events
LearnBlock.Events.fireNow_ = function () {
    for (var a = LearnBlock.Events.filter(LearnBlock.Events.FIRE_QUEUE_, !0), b = LearnBlock.Events.FIRE_QUEUE_.length = 0, c; c = a[b]; b++)
        if (c.workspaceId) {
            var d = LearnBlock.Workspace.getById(c.workspaceId);
            d && d.fireChangeListener(c)
        }
};
//Filters the queued events and merges duplicates
LearnBlock.Events.filter = function (a, b) {
    var c = a.slice();
    b || c.reverse();
    for (var d = [], e = Object.create(null), f = 0, g; g = c[f]; f++)
        if (!g.isNull()) {
            var h = [g.type, g.blockId, g.workspaceId].join(" "),
                k = e[h],
                l = k ? k.event : null;
            if (!k) e[h] = {
                event: g,
                index: f
            }, d.push(g);
            else if (g.type == LearnBlock.Events.MOVE && k.index == f - 1) l.newParentId = g.newParentId, l.newInputName = g.newInputName, l.newCoordinate = g.newCoordinate, k.index = f;
            else if (g.type == LearnBlock.Events.CHANGE && g.element == l.element && g.name == l.name) l.newValue = g.newValue;
            else if (g.type !=
                LearnBlock.Events.UI || "click" != g.element || "commentOpen" != l.element && "mutatorOpen" != l.element && "warningOpen" != l.element) e[h] = {
                event: g,
                index: 1
            }, d.push(g)
        } c = d.filter(function (a) {
        return !a.isNull()
    });
    b || c.reverse();
    for (f = 1; g = c[f]; f++) g.type == LearnBlock.Events.CHANGE && "mutation" == g.element && c.unshift(c.splice(f, 1)[0]);
    return c
};
//Modifies pending undo events so that when they are fired they don't land in the undo stack
LearnBlock.Events.clearPendingUndo = function () {
    for (var a = 0, b; b = LearnBlock.Events.FIRE_QUEUE_[a]; a++) b.recordUndo = !1
};
//Stops sending events
LearnBlock.Events.disable = function () {
    LearnBlock.Events.disabled_++
};
//Starts sending events
LearnBlock.Events.enable = function () {
    LearnBlock.Events.disabled_--
};
//Returns whether events may be fired or not
LearnBlock.Events.isEnabled = function () {
    return 0 == LearnBlock.Events.disabled_
};
//Current group
LearnBlock.Events.getGroup = function () {
    return LearnBlock.Events.group_
};
//Starts or stops a group
LearnBlock.Events.setGroup = function (a) {
    LearnBlock.Events.group_ = "boolean" == typeof a ? a ? LearnBlock.utils.genUid() : "" : a
};
//Computes a list of the IDs of the specified block and all its descendants
LearnBlock.Events.getDescendantIds = function (a) {
    var b = [];
    a = a.getDescendants(!1);
    for (var c = 0, d; d = a[c]; c++) b[c] = d.id;
    return b
};
//Decodes the JSON into an event
LearnBlock.Events.fromJson = function (a, b) {
    switch (a.type) {
        case LearnBlock.Events.CREATE:
            var c = new LearnBlock.Events.Create(null);
            break;
        case LearnBlock.Events.DELETE:
            c = new LearnBlock.Events.Delete(null);
            break;
        case LearnBlock.Events.CHANGE:
            c = new LearnBlock.Events.Change(null, "", "", "", "");
            break;
        case LearnBlock.Events.MOVE:
            c = new LearnBlock.Events.Move(null);
            break;
        case LearnBlock.Events.VAR_CREATE:
            c = new LearnBlock.Events.VarCreate(null);
            break;
        case LearnBlock.Events.VAR_DELETE:
            c = new LearnBlock.Events.VarDelete(null);
            break;
        case LearnBlock.Events.VAR_RENAME:
            c =
                new LearnBlock.Events.VarRename(null, "");
            break;
        case LearnBlock.Events.UI:
            c = new LearnBlock.Events.Ui(null, "", "", "");
            break;
        default:
            throw Error("Unknown event type.");
    }
    c.fromJson(a);
    c.workspaceId =
        b.id;
    return c
};
//Abstract class for an event
LearnBlock.Events.Abstract = function () {
    this.workspaceId = void 0;
    this.group = LearnBlock.Events.getGroup();
    this.recordUndo = LearnBlock.Events.recordUndo
};
//Encodes the event as JSON
LearnBlock.Events.Abstract.prototype.toJson = function () {
    var a = {
        type: this.type
    };
    this.group && (a.group = this.group);
    return a
};
//Decodes the JSON event
LearnBlock.Events.Abstract.prototype.fromJson = function (a) {
    this.group = a.group
};
//Does this event record any change of state?
LearnBlock.Events.Abstract.prototype.isNull = function () {
    return !1
};
//Runs an event
LearnBlock.Events.Abstract.prototype.run = function (a) {};
//Gets workspace the event belongs to
LearnBlock.Events.Abstract.prototype.getEventWorkspace_ = function () {
    if (this.workspaceId) var a = LearnBlock.Workspace.getById(this.workspaceId);
    if (!a) throw Error("Workspace is null. Event must have been generated from real Blockly events.");
    return a
};

//Utils object
LearnBlock.utils.object = {};
//Inherits the prototype methods from one constructor into another
LearnBlock.utils.object.inherits = function (a, b) {
    a.superClass_ = b.prototype;
    a.prototype = Object.create(b.prototype);
    a.prototype.constructor = a
};
//Copies all the members of a source object to a target object
LearnBlock.utils.object.mixin = function (a, b) {
    for (var c in b) a[c] = b[c]
};
//Returns an array of a given object's own enumerable property values
LearnBlock.utils.object.values = function (a) {
    return Object.values ? Object.values(a) : Object.keys(a).map(function (b) {
        return a[b]
    })
};

//Utils xml
LearnBlock.utils.xml = {};
//Namespace for xml
LearnBlock.utils.xml.NAME_SPACE = "https://developers.google.com/blockly/xml";
//Gets the document object
LearnBlock.utils.xml.document = function () {
    return document
};
//Creates DOM element for xml
LearnBlock.utils.xml.createElement = function (a) {
    return LearnBlock.utils.xml.document().createElementNS(LearnBlock.utils.xml.NAME_SPACE, a)
};
//Creates text element for xml
LearnBlock.utils.xml.createTextNode = function (a) {
    return LearnBlock.utils.xml.document().createTextNode(a)
};
//Converts an xml string into a DOM tree
LearnBlock.utils.xml.textToDomDocument = function (a) {
    return (new DOMParser).parseFromString(a, "text/xml")
};
//Converts a DOM structure into plain text
LearnBlock.utils.xml.domToText = function (a) {
    return (new XMLSerializer).serializeToString(a)
};

//Abstract class for a block event
LearnBlock.Events.BlockBase = function (a) {
    LearnBlock.Events.BlockBase.superClass_.constructor.call(this);
    this.blockId = a.id;
    this.workspaceId = a.workspace.id
};
LearnBlock.utils.object.inherits(LearnBlock.Events.BlockBase, LearnBlock.Events.Abstract);
//Encodes the event as JSON
LearnBlock.Events.BlockBase.prototype.toJson = function () {
    var a = LearnBlock.Events.BlockBase.superClass_.toJson.call(this);
    a.blockId = this.blockId;
    return a
};
//Decodes the JSON event
LearnBlock.Events.BlockBase.prototype.fromJson = function (a) {
    LearnBlock.Events.BlockBase.superClass_.fromJson.call(this, a);
    this.blockId = a.blockId
};
//Class for a block change event
LearnBlock.Events.Change = function (a, b, c, d, e) {
    a && (LearnBlock.Events.Change.superClass_.constructor.call(this, a), this.element = b, this.name = c, this.oldValue = d, this.newValue = e)
};
LearnBlock.utils.object.inherits(LearnBlock.Events.Change, LearnBlock.Events.BlockBase);
LearnBlock.Events.BlockChange = LearnBlock.Events.Change;
LearnBlock.Events.Change.prototype.type = LearnBlock.Events.CHANGE;
//Encodes the event as JSON
LearnBlock.Events.Change.prototype.toJson = function () {
    var a = LearnBlock.Events.Change.superClass_.toJson.call(this);
    a.element = this.element;
    this.name && (a.name = this.name);
    a.newValue = this.newValue;
    return a
};
//Decodes the JSON event
LearnBlock.Events.Change.prototype.fromJson = function (a) {
    LearnBlock.Events.Change.superClass_.fromJson.call(this, a);
    this.element = a.element;
    this.name = a.name;
    this.newValue = a.newValue
};
//Does the event record any change of state?
LearnBlock.Events.Change.prototype.isNull = function () {
    return this.oldValue == this.newValue
};
//Runs a change event
LearnBlock.Events.Change.prototype.run = function (a) {
    var b = this.getEventWorkspace_().getBlockById(this.blockId);
    if (b) switch (a = a ? this.newValue : this.oldValue, this.element) {
        case "field":
            (b = b.getField(this.name)) ? b.setValue(a): console.warn("Can't set non-existent field: " + this.name);
            break;
        case "inline":
            b.setInputsInline(!!a);
            break;
        default:
            console.warn("Unknown change type: " + this.element)
    } else console.warn("Can't change non-existent block: " + this.blockId)
};
//Class for a block creation event
LearnBlock.Events.Create = function (a) {
    a && (LearnBlock.Events.Create.superClass_.constructor.call(this, a), this.xml = a.workspace.rendered ? LearnBlock.Xml.blockToDomWithXY(a) : LearnBlock.Xml.blockToDom(a), this.ids = LearnBlock.Events.getDescendantIds(a))
};
LearnBlock.utils.object.inherits(LearnBlock.Events.Create, LearnBlock.Events.BlockBase);
LearnBlock.Events.BlockCreate = LearnBlock.Events.Create;
LearnBlock.Events.Create.prototype.type = LearnBlock.Events.CREATE;
//Encodes the event as JSON
LearnBlock.Events.Create.prototype.toJson = function () {
    var a = LearnBlock.Events.Create.superClass_.toJson.call(this);
    a.xml = LearnBlock.Xml.domToText(this.xml);
    a.ids = this.ids;
    return a
};
//Decodes the JSON event
LearnBlock.Events.Create.prototype.fromJson = function (a) {
    LearnBlock.Events.Create.superClass_.fromJson.call(this, a);
    this.xml = LearnBlock.Xml.textToDom(a.xml);
    this.ids = a.ids
};
//Runs a creation event
LearnBlock.Events.Create.prototype.run = function (a) {
    var b = this.getEventWorkspace_();
    if (a) a = LearnBlock.utils.xml.createElement("xml"), a.appendChild(this.xml), LearnBlock.Xml.domToWorkspace(a, b);
    else {
        a = 0;
        for (var c; c = this.ids[a]; a++) {
            var d = b.getBlockById(c);
            d ? d.dispose(!1) : c == this.blockId && console.warn("Can't uncreate non-existent block: " + c)
        }
    }
};
//Class for a block deletion event
LearnBlock.Events.Delete = function (a) {
    if (a) {
        if (a.getParent()) throw Error("Connected blocks cannot be deleted.");
        LearnBlock.Events.Delete.superClass_.constructor.call(this, a);
        this.oldXml = a.workspace.rendered ? LearnBlock.Xml.blockToDomWithXY(a) : LearnBlock.Xml.blockToDom(a);
        this.ids = LearnBlock.Events.getDescendantIds(a)
    }
};
LearnBlock.utils.object.inherits(LearnBlock.Events.Delete, LearnBlock.Events.BlockBase);
LearnBlock.Events.BlockDelete = LearnBlock.Events.Delete;
LearnBlock.Events.Delete.prototype.type = LearnBlock.Events.DELETE;
//Encodes the event as JSON
LearnBlock.Events.Delete.prototype.toJson = function () {
    var a = LearnBlock.Events.Delete.superClass_.toJson.call(this);
    a.ids = this.ids;
    return a
};
//Decodes the JSON event
LearnBlock.Events.Delete.prototype.fromJson = function (a) {
    LearnBlock.Events.Delete.superClass_.fromJson.call(this, a);
    this.ids = a.ids
};
//Runs a deletion event
LearnBlock.Events.Delete.prototype.run = function (a) {
    var b = this.getEventWorkspace_();
    if (a) {
        a = 0;
        for (var c; c = this.ids[a]; a++) {
            var d = b.getBlockById(c);
            d ? d.dispose(!1) : c == this.blockId && console.warn("Can't delete non-existent block: " + c)
        }
    } else a = LearnBlock.utils.xml.createElement("xml"), a.appendChild(this.oldXml), LearnBlock.Xml.domToWorkspace(a, b)
};
//Class for a block move event
LearnBlock.Events.Move = function (a) {
    a && (LearnBlock.Events.Move.superClass_.constructor.call(this, a), a = this.currentLocation_(), this.oldParentId = a.parentId, this.oldInputName = a.inputName, this.oldCoordinate = a.coordinate)
};
LearnBlock.utils.object.inherits(LearnBlock.Events.Move, LearnBlock.Events.BlockBase);
LearnBlock.Events.BlockMove = LearnBlock.Events.Move;
LearnBlock.Events.Move.prototype.type = LearnBlock.Events.MOVE;
//Encodes the event as JSON
LearnBlock.Events.Move.prototype.toJson = function () {
    var a = LearnBlock.Events.Move.superClass_.toJson.call(this);
    this.newParentId && (a.newParentId = this.newParentId);
    this.newInputName && (a.newInputName = this.newInputName);
    this.newCoordinate && (a.newCoordinate = Math.round(this.newCoordinate.x) + "," + Math.round(this.newCoordinate.y));
    return a
};
//Decodes the JSON event
LearnBlock.Events.Move.prototype.fromJson = function (a) {
    LearnBlock.Events.Move.superClass_.fromJson.call(this, a);
    this.newParentId = a.newParentId;
    this.newInputName = a.newInputName;
    a.newCoordinate && (a = a.newCoordinate.split(","), this.newCoordinate = new LearnBlock.utils.Coordinate(Number(a[0]), Number(a[1])))
};
//Records the block's new location
LearnBlock.Events.Move.prototype.recordNew = function () {
    var a = this.currentLocation_();
    this.newParentId = a.parentId;
    this.newInputName = a.inputName;
    this.newCoordinate = a.coordinate
};
//Returns the parentId and input if the block is connected or the XY location if disconnected
LearnBlock.Events.Move.prototype.currentLocation_ = function () {
    var a = this.getEventWorkspace_().getBlockById(this.blockId),
        b = {},
        c = a.getParent();
    if (c) {
        if (b.parentId = c.id, a = c.getInputWithBlock(a)) b.inputName = a.name
    } else b.coordinate = a.getRelativeToSurfaceXY();
    return b
};
//Does the event record any change of state?
LearnBlock.Events.Move.prototype.isNull = function () {
    return this.oldParentId == this.newParentId && this.oldInputName == this.newInputName && LearnBlock.utils.Coordinate.equals(this.oldCoordinate, this.newCoordinate)
};
//Runs a move event
LearnBlock.Events.Move.prototype.run = function (a) {
    var b = this.getEventWorkspace_(),
        c = b.getBlockById(this.blockId);
    if (c) {
        var d = a ? this.newParentId : this.oldParentId,
            e = a ? this.newInputName : this.oldInputName;
        a = a ? this.newCoordinate : this.oldCoordinate;
        var f = null;
        if (d && (f = b.getBlockById(d), !f)) {
            console.warn("Can't connect to non-existent block: " + d);
            return
        }
        c.getParent() && c.unplug();
        if (a) e = c.getRelativeToSurfaceXY(), c.moveBy(a.x - e.x, a.y - e.y);
        else {
            c = c.outputConnection || c.previousConnection;
            if (e) {
                if (b = f.getInput(e)) var g =
                    b.connection
            } else c.type == LearnBlock.PREVIOUS_STATEMENT && (g = f.nextConnection);
            g ? c.connect(g) : console.warn("Can't connect to non-existent input: " + e)
        }
    } else console.warn("Can't move non-existent block: " + this.blockId)
};

//Class for a finished loading event
LearnBlock.Events.FinishedLoading = function (a) {
    this.workspaceId = a.id;
    this.group = LearnBlock.Events.getGroup();
    this.recordUndo = !1
};
LearnBlock.utils.object.inherits(LearnBlock.Events.FinishedLoading, LearnBlock.Events.Abstract);
//Type of the event
LearnBlock.Events.FinishedLoading.prototype.type = LearnBlock.Events.FINISHED_LOADING;
//Encodes the event as JSON
LearnBlock.Events.FinishedLoading.prototype.toJson = function () {
    var a = {
        type: this.type
    };
    this.group && (a.group = this.group);
    this.workspaceId && (a.workspaceId = this.workspaceId);
    return a
};
//Decodes the JSON event
LearnBlock.Events.FinishedLoading.prototype.fromJson = function (a) {
    this.workspaceId = a.workspaceId;
    this.group = a.group
};

//Abstract class for a variable event
LearnBlock.Events.VarBase = function (a) {
    LearnBlock.Events.VarBase.superClass_.constructor.call(this);
    this.varId = a.getId();
    this.workspaceId = a.workspace.id
};
LearnBlock.utils.object.inherits(LearnBlock.Events.VarBase, LearnBlock.Events.Abstract);
//Encodes the event as JSON
LearnBlock.Events.VarBase.prototype.toJson = function () {
    var a = LearnBlock.Events.VarBase.superClass_.toJson.call(this);
    a.varId = this.varId;
    return a
};
//Decodes the JSON event
LearnBlock.Events.VarBase.prototype.fromJson = function (a) {
    LearnBlock.Events.VarBase.superClass_.toJson.call(this);
    this.varId = a.varId
};
//Class for a variable creation event
LearnBlock.Events.VarCreate = function (a) {
    a && (LearnBlock.Events.VarCreate.superClass_.constructor.call(this, a), this.varType = a.type, this.varName = a.name)
};
LearnBlock.utils.object.inherits(LearnBlock.Events.VarCreate, LearnBlock.Events.VarBase);
//Type of the event
LearnBlock.Events.VarCreate.prototype.type = LearnBlock.Events.VAR_CREATE;
//Encodes the event as JSON
LearnBlock.Events.VarCreate.prototype.toJson = function () {
    var a = LearnBlock.Events.VarCreate.superClass_.toJson.call(this);
    a.varType = this.varType;
    a.varName = this.varName;
    return a
};
//Decodes the JSON event
LearnBlock.Events.VarCreate.prototype.fromJson = function (a) {
    LearnBlock.Events.VarCreate.superClass_.fromJson.call(this, a);
    this.varType = a.varType;
    this.varName = a.varName
};
//Runs a variable creation event
LearnBlock.Events.VarCreate.prototype.run = function (a) {
    var b = this.getEventWorkspace_();
    a ? b.createVariable(this.varName, this.varType, this.varId) : b.deleteVariableById(this.varId)
};
//Class for a variable deletion event
LearnBlock.Events.VarDelete = function (a) {
    a && (LearnBlock.Events.VarDelete.superClass_.constructor.call(this, a), this.varType = a.type, this.varName = a.name)
};
LearnBlock.utils.object.inherits(LearnBlock.Events.VarDelete, LearnBlock.Events.VarBase);
//Type of the event
LearnBlock.Events.VarDelete.prototype.type = LearnBlock.Events.VAR_DELETE;
//Encodes the event as JSON
LearnBlock.Events.VarDelete.prototype.toJson = function () {
    var a = LearnBlock.Events.VarDelete.superClass_.toJson.call(this);
    a.varType = this.varType;
    a.varName = this.varName;
    return a
};
//Decodes the JSON event
LearnBlock.Events.VarDelete.prototype.fromJson = function (a) {
    LearnBlock.Events.VarDelete.superClass_.fromJson.call(this, a);
    this.varType = a.varType;
    this.varName = a.varName
};
//Runs a variable deletion event
LearnBlock.Events.VarDelete.prototype.run = function (a) {
    var b = this.getEventWorkspace_();
    a ? b.deleteVariableById(this.varId) : b.createVariable(this.varName, this.varType, this.varId)
};
//Class for a variable rename event
LearnBlock.Events.VarRename = function (a, b) {
    a && (LearnBlock.Events.VarRename.superClass_.constructor.call(this, a), this.oldName = a.name, this.newName = b)
};
LearnBlock.utils.object.inherits(LearnBlock.Events.VarRename, LearnBlock.Events.VarBase);
//Type of the event
LearnBlock.Events.VarRename.prototype.type = LearnBlock.Events.VAR_RENAME;
//Encodes the event as JSON
LearnBlock.Events.VarRename.prototype.toJson = function () {
    var a = LearnBlock.Events.VarRename.superClass_.toJson.call(this);
    a.oldName = this.oldName;
    a.newName = this.newName;
    return a
};
//Decodes the JSON event
LearnBlock.Events.VarRename.prototype.fromJson = function (a) {
    LearnBlock.Events.VarRename.superClass_.fromJson.call(this, a);
    this.oldName = a.oldName;
    this.newName = a.newName
};
//Runs a variable rename event
LearnBlock.Events.VarRename.prototype.run = function (a) {
    var b = this.getEventWorkspace_();
    a ? b.renameVariableById(this.varId, this.newName) : b.renameVariableById(this.varId, this.oldName)
};

//Utils DOM
LearnBlock.utils.dom = {};
//Required name space for SVG elements
LearnBlock.utils.dom.SVG_NS = "http://www.w3.org/2000/svg";
//Required name space for HTML elements
LearnBlock.utils.dom.HTML_NS = "http://www.w3.org/1999/xhtml";
//Required name space for XLINK elements
LearnBlock.utils.dom.XLINK_NS = "http://www.w3.org/1999/xlink";
//Node type constants
LearnBlock.utils.dom.Node = {
    ELEMENT_NODE: 1,
    TEXT_NODE: 3,
    COMMENT_NODE: 8,
    DOCUMENT_POSITION_CONTAINED_BY: 16
};
//Temporary cache of text widths
LearnBlock.utils.dom.cacheWidths_ = null;
//Number of current references to cache
LearnBlock.utils.dom.cacheReference_ = 0;
//Helper method for creating SVG elements
LearnBlock.utils.dom.createSvgElement = function (a, b, c) {
    a = document.createElementNS(LearnBlock.utils.dom.SVG_NS, a);
    for (var d in b) a.setAttribute(d, b[d]);
    document.body.runtimeStyle && (a.runtimeStyle = a.currentStyle = a.style);
    c && c.appendChild(a);
    return a
};
//Adds a CSS class to a element
LearnBlock.utils.dom.addClass = function (a, b) {
    var c = a.getAttribute("class") || "";
    if (-1 != (" " + c + " ").indexOf(" " + b + " ")) return !1;
    c && (c += " ");
    a.setAttribute("class", c + b);
    return !0
};
//Removes a CSS class from a element
LearnBlock.utils.dom.removeClass = function (a, b) {
    var c = a.getAttribute("class");
    if (-1 == (" " + c + " ").indexOf(" " + b + " ")) return !1;
    c = c.split(/\s+/);
    for (var d = 0; d < c.length; d++) c[d] && c[d] != b || (c.splice(d, 1), d--);
    c.length ? a.setAttribute("class", c.join(" ")) : a.removeAttribute("class");
    return !0
};
//Checks if an element has the specified CSS class
LearnBlock.utils.dom.hasClass = function (a, b) {
    return -1 != (" " + a.getAttribute("class") + " ").indexOf(" " + b + " ")
};
//Removes a node from its parent
LearnBlock.utils.dom.removeNode = function (a) {
    return a && a.parentNode ? a.parentNode.removeChild(a) : null
};
//Inserts a node after a reference node
LearnBlock.utils.dom.insertAfter = function (a, b) {
    var c = b.nextSibling,
        d = b.parentNode;
    if (!d) throw Error("Reference node has no parent.");
    c ? d.insertBefore(a, c) : d.appendChild(a)
};
//Whether a node contains another node
LearnBlock.utils.dom.containsNode = function (a, b) {
    return !!(a.compareDocumentPosition(b) & LearnBlock.utils.dom.Node.DOCUMENT_POSITION_CONTAINED_BY)
};
//Sets the CSS transform property on an element
LearnBlock.utils.dom.setCssTransform = function (a, b) {
    a.style.transform = b;
    a.style["-webkit-transform"] = b
};
//Starts caching text widths
LearnBlock.utils.dom.startTextWidthCache = function () {
    LearnBlock.utils.dom.cacheReference_++;
    LearnBlock.utils.dom.cacheWidths_ || (LearnBlock.utils.dom.cacheWidths_ = {})
};
//Stops caching field widths
LearnBlock.utils.dom.stopTextWidthCache = function () {
    LearnBlock.utils.dom.cacheReference_--;
    LearnBlock.utils.dom.cacheReference_ || (LearnBlock.utils.dom.cacheWidths_ = null)
};
//Gets the width of a text element
LearnBlock.utils.dom.getTextWidth = function (a) {
    var b = a.textContent + "\n" + a.className.baseVal,
        c;
    if (LearnBlock.utils.dom.cacheWidths_ && (c = LearnBlock.utils.dom.cacheWidths_[b])) return c;
    try {
        c = LearnBlock.utils.userAgent.IE || LearnBlock.utils.userAgent.EDGE ? a.getBBox().width : a.getComputedTextLength()
    } catch (d) {
        return 8 * a.textContent.length
    }
    LearnBlock.utils.dom.cacheWidths_ && (LearnBlock.utils.dom.cacheWidths_[b] = c);
    return c
};

//Class for XML reader and writer
LearnBlock.Xml = {};
//Encodes a block tree as XML
LearnBlock.Xml.workspaceToDom = function (a, b) {
    var c = LearnBlock.utils.xml.createElement("xml"),
        d = LearnBlock.Xml.variablesToDom(LearnBlock.Variables.allUsedVarModels(a));
    d.hasChildNodes() && c.appendChild(d);
    var e = a.getTopBlocks(!0);
    var f;
    for (d = 0; f = e[d]; d++) c.appendChild(LearnBlock.Xml.blockToDomWithXY(f, b));
    return c
};
//Encodes a list of variables as XML
LearnBlock.Xml.variablesToDom = function (a) {
    for (var b = LearnBlock.utils.xml.createElement("variables"), c = 0, d; d = a[c]; c++) {
        var e = LearnBlock.utils.xml.createElement("variable");
        e.appendChild(LearnBlock.utils.xml.createTextNode(d.name));
        d.type && e.setAttribute("type", d.type);
        e.id = d.getId();
        b.appendChild(e)
    }
    return b
};
//Encodes a block subtree as XML with XY coordinates
LearnBlock.Xml.blockToDomWithXY = function (a, b) {
    var c;
    a.workspace.RTL && (c = a.workspace.getWidth());
    var d = LearnBlock.Xml.blockToDom(a, b),
        e = a.getRelativeToSurfaceXY();
    d.setAttribute("x", Math.round(a.workspace.RTL ? c - e.x : e.x));
    d.setAttribute("y", Math.round(e.y));
    return d
};
//Encodes a field as XML
LearnBlock.Xml.fieldToDom_ = function (a) {
    if (a.isSerializable()) {
        var b = LearnBlock.utils.xml.createElement("field");
        b.setAttribute("name", a.name);
        return a.toXml(b)
    }
    return null
};
//Encodes all of a block's fields as XML and attaches them to the given tree of XML elements
LearnBlock.Xml.allFieldsToDom_ = function (a, b) {
    for (var c = 0, d; d = a.inputList[c]; c++)
        for (var e = 0, f; f = d.fieldRow[e]; e++)(f = LearnBlock.Xml.fieldToDom_(f)) && b.appendChild(f)
};
//Encodes a block subtree as XML
LearnBlock.Xml.blockToDom = function (a, b) {
    var c = LearnBlock.utils.xml.createElement("block");
    c.setAttribute("type", a.type);
    c.setAttribute("blocktextname", a.btname);
    b || (c.id = a.id);
    if (a.mutationToDom) {
        var d = a.mutationToDom();
        d && (d.hasChildNodes() || d.hasAttributes()) && c.appendChild(d)
    }
    LearnBlock.Xml.allFieldsToDom_(a, c);
    a.data && (d = LearnBlock.utils.xml.createElement("data"), d.appendChild(LearnBlock.utils.xml.createTextNode(a.data)), c.appendChild(d));
    var f, g;
    for (var e = 0; f = a.inputList[e]; e++) {
        var h;
        g = !0;
        if (f.type != LearnBlock.DUMMY_INPUT) {
            var k = f.connection.targetBlock();
            f.type == LearnBlock.INPUT_VALUE ? h = LearnBlock.utils.xml.createElement("value") : f.type == LearnBlock.NEXT_STATEMENT && (h = LearnBlock.utils.xml.createElement("statement"));
            k && (h.appendChild(LearnBlock.Xml.blockToDom(k, b)), g = !1);
            h.setAttribute("name", f.name);
            g || c.appendChild(h)
        }
    }
    void 0 != a.inputsInline && a.inputsInline != a.inputsInlineDefault && c.setAttribute("inline", a.inputsInline);
    a.isDeletable() || c.setAttribute("deletable", !1);
    a.isMovable() || c.setAttribute("movable", !1);
    a.isEditable() || c.setAttribute("editable", !1);
    if (e = a.getNextBlock()) h = LearnBlock.utils.xml.createElement("next"),
        h.appendChild(LearnBlock.Xml.blockToDom(e, b)), c.appendChild(h);
    d = a.nextConnection;
    !d || e;
    return c
};
//Converts a DOM structure into plain text
LearnBlock.Xml.domToText = function (a) {
    a = LearnBlock.utils.xml.domToText(a);
    var b = /(<[^/](?:[^>]*[^/])?>[^<]*)\n([^<]*<\/)/;
    do {
        var c = a;
        a = a.replace(b, "$1&#10;$2")
    } while (a != c);
    return a
};
//Converts a DOM structure into properly indented text
LearnBlock.Xml.domToPrettyText = function (a) {
    a = LearnBlock.Xml.domToText(a).split("<");
    for (var b = "", c = 1; c < a.length; c++) {
        var d = a[c];
        "/" == d[0] && (b = b.substring(2));
        a[c] = b + "<" + d;
        "/" != d[0] && "/>" != d.slice(-2) && (b += "  ")
    }
    a = a.join("\n");
    a = a.replace(/(<(\w+)\b[^>]*>[^\n]*)\n *<\/\2>/g, "$1</$2>");
    return a.replace(/^\n/, "")
};
//Converts an XML string into a DOM structure
LearnBlock.Xml.textToDom = function (a) {
    var b = LearnBlock.utils.xml.textToDomDocument(a);
    if (!b || !b.documentElement || b.getElementsByTagName("parsererror").length) throw Error("textToDom was unable to parse: " + a);
    return b.documentElement
};
//Clears the given workspace then decodes an XML DOM and creates blocks on the workspace
LearnBlock.Xml.clearWorkspaceAndLoadFromXml = function (a, b) {
    b.setResizesEnabled(!1);
    b.clear();
    var c = LearnBlock.Xml.domToWorkspace(a, b);
    b.setResizesEnabled(!0);
    return c
};
//Decodes an XML DOM and creates blocks on the workspace
LearnBlock.Xml.domToWorkspace = function (a, b) {
    if (a instanceof LearnBlock.Workspace) {
        var c = a;
        a = b;
        b = c;
        console.warn("Deprecated call to LearnBlock.Xml.domToWorkspace, swap the arguments.")
    }
    var d;
    b.RTL && (d = b.getWidth());
    c = [];
    LearnBlock.utils.dom.startTextWidthCache();
    var e = a.childNodes.length,
        f = LearnBlock.Events.getGroup();
    f || LearnBlock.Events.setGroup(!0);
    b.setResizesEnabled && b.setResizesEnabled(!1);
    var g = !0;
    try {
        for (var h = 0; h < e; h++) {
            var k = a.childNodes[h],
                l = k.nodeName.toLowerCase();
            if ("block" == l || !LearnBlock.Events.recordUndo) {
                var m =
                    LearnBlock.Xml.domToBlock(k, b);
                c.push(m.id);
                var n = k.hasAttribute("x") ? parseInt(k.getAttribute("x"), 10) : 10,
                    p = k.hasAttribute("y") ? parseInt(k.getAttribute("y"), 10) : 10;
                isNaN(n) || isNaN(p) || m.moveBy(b.RTL ? d - n : n, p);
                g = !1
            } else {
                if ("variables" == l) {
                    if (g) LearnBlock.Xml.domToVariables(k, b);
                    else throw Error("'variables' tag must exist once before block and shadow tag elements in the workspace XML, but it was found in another location.");
                    g = !1
                }
            }
        }
    } finally {
        f || LearnBlock.Events.setGroup(!1), LearnBlock.utils.dom.stopTextWidthCache()
    }
    b.setResizesEnabled && b.setResizesEnabled(!0);
    LearnBlock.Events.fire(new LearnBlock.Events.FinishedLoading(b));
    return c
};
//Decodes an XML DOM and creates blocks on the workspace
LearnBlock.Xml.appendDomToWorkspace = function (a, b) {
    if (b.hasOwnProperty("scale")) {
        var c = LearnBlock.BlockSvg.TAB_WIDTH;
        try {
            LearnBlock.BlockSvg.TAB_WIDTH = 0;
            var d = b.getBlocksBoundingBox()
        } finally {
            LearnBlock.BlockSvg.TAB_WIDTH = c
        }
    }
    c = LearnBlock.Xml.domToWorkspace(a, b);
    if (d && d.top != d.bottom) {
        var e = d.bottom;
        var f = d.left;
        var g = Infinity,
            h = Infinity;
        for (d = 0; d < c.length; d++) {
            var k = b.getBlockById(c[d]).getRelativeToSurfaceXY();
            k.y < h && (h = k.y);
            k.x < g && (g = k.x)
        }
        e = e - h + LearnBlock.BlockSvg.SEP_SPACE_Y;
        f -= g;
        var l;
        b.RTL && (l = b.getWidth());
        for (d =
            0; d < c.length; d++) b.getBlockById(c[d]).moveBy(b.RTL ? l - f : f, e)
    }
    return c
};
//Decodes an XML block tag and creates a block on the workspace
LearnBlock.Xml.domToBlock = function (a, b) {
    if (a instanceof LearnBlock.Workspace) {
        var c = a;
        a = b;
        b = c;
        console.warn("Deprecated call to LearnBlock.Xml.domToBlock, swap the arguments.")
    }
    LearnBlock.Events.disable();
    c = b.getAllVariables();
    try {
        var d = LearnBlock.Xml.domToBlockHeadless_(a, b),
            e = d.getDescendants(!1);
        if (b.rendered) {
            d.setConnectionsHidden(!0);
            for (var f = e.length - 1; 0 <= f; f--) e[f].initSvg();
            for (f = e.length - 1; 0 <= f; f--) e[f].render(!1);
            setTimeout(function () {
                d.workspace && d.setConnectionsHidden(!1)
            }, 1);
            b.resizeContents()
        } else
            for (f =
                e.length - 1; 0 <= f; f--) e[f].initModel()
    } finally {
        LearnBlock.Events.enable()
    }
    if (LearnBlock.Events.isEnabled()) {
        e = LearnBlock.Variables.getAddedVariables(b, c);
        for (f = 0; f < e.length; f++) LearnBlock.Events.fire(new LearnBlock.Events.VarCreate(e[f]));
        LearnBlock.Events.fire(new LearnBlock.Events.BlockCreate(d))
    }
    return d
};
//Decodes an XML list of variables and adds the variables to the workspace
LearnBlock.Xml.domToVariables = function (a, b) {
    for (var c = 0, d; d = a.childNodes[c]; c++)
        if (d.nodeType == LearnBlock.utils.dom.Node.ELEMENT_NODE) {
            var e = d.getAttribute("type"),
                f = d.getAttribute("id");
            b.createVariable(d.textContent, e, f)
        }
};
//Decodes an XML block tag and creates a block on the workspace
LearnBlock.Xml.domToBlockHeadless_ = function (a, b) {
    var c = null,
        d = a.getAttribute("type");
    if (!d) throw TypeError("Block type unspecified: " + a.outerHTML);
    var e = a.getAttribute("id");
    c = b.newBlock(d, e);
    var f = null;
    e = 0;
    for (var g; g = a.childNodes[e]; e++)
        if (g.nodeType != LearnBlock.utils.dom.Node.TEXT_NODE) {
            for (var h = f = null, k = 0, l; l = g.childNodes[k]; k++) l.nodeType == LearnBlock.utils.dom.Node.ELEMENT_NODE && ("block" == l.nodeName.toLowerCase() ? f = l : "shadow" == l.nodeName.toLowerCase() && (h = l));
            !f && h && (f = h);
            k = g.getAttribute("name");
            switch (g.nodeName.toLowerCase()) {
                case "mutation":
                    c.domToMutation &&
                        (c.domToMutation(g), c.initSvg && c.initSvg());
                    break;
                case "data":
                    c.data = g.textContent;
                    break;
                case "title":
                case "field":
                    LearnBlock.Xml.domToField_(c, k, g);
                    break;
                case "value":
                case "statement":
                    g = c.getInput(k);
                    if (!g) {
                        console.warn("Ignoring non-existent input " + k + " in block " + d);
                        break
                    }
                    if (f)
                        if (f = LearnBlock.Xml.domToBlockHeadless_(f, b), f.outputConnection) g.connection.connect(f.outputConnection);
                        else if (f.previousConnection) g.connection.connect(f.previousConnection);
                    else throw TypeError("Child block does not have output or previous statement.");
                    break;
                case "next":
                    h && c.nextConnection;
                    if (f) {
                        if (!c.nextConnection) throw TypeError("Next statement does not exist.");
                        if (c.nextConnection.isConnected()) throw TypeError("Next statement is already connected.");
                        f = LearnBlock.Xml.domToBlockHeadless_(f, b);
                        if (!f.previousConnection) throw TypeError("Next block does not have previous statement.");
                        c.nextConnection.connect(f.previousConnection)
                    }
                    break;
                default:
                    console.warn("Ignoring unknown tag: " + g.nodeName)
            }
        }(e = a.getAttribute("inline")) && c.setInputsInline("true" == e);
    (e = a.getAttribute("deletable")) && c.setDeletable("true" == e);
    (e = a.getAttribute("movable")) && c.setMovable("true" == e);
    (e = a.getAttribute("editable")) && c.setEditable("true" == e);
    return c
};
//Decodes an XML field tag and sets the value of that field on the given block
LearnBlock.Xml.domToField_ = function (a, b, c) {
    var d = a.getField(b);
    d ? d.fromXml(c) : console.warn("Ignoring non-existent field " + b + " in block " + a.type)
};
//Removes any 'next' block
LearnBlock.Xml.deleteNext = function (a) {
    for (var b = 0, c; c = a.childNodes[b]; b++)
        if ("next" == c.nodeName.toLowerCase()) {
            a.removeChild(c);
            break
        }
};

//Class for connection between blocks
LearnBlock.Connection = function (a, b) {
    this.sourceBlock_ = a;
    this.type = b
};
LearnBlock.Connection.CAN_CONNECT = 0;
LearnBlock.Connection.REASON_SELF_CONNECTION = 1;
LearnBlock.Connection.REASON_WRONG_TYPE = 2;
LearnBlock.Connection.REASON_TARGET_NULL = 3;
LearnBlock.Connection.REASON_CHECKS_FAILED = 4;
LearnBlock.Connection.REASON_DIFFERENT_WORKSPACES = 5;
LearnBlock.Connection.prototype.targetConnection = null;
LearnBlock.Connection.prototype.disposed = !1;
LearnBlock.Connection.prototype.check_ = null;
LearnBlock.Connection.prototype.shadowDom_ = null;
LearnBlock.Connection.prototype.x_ = 0;
LearnBlock.Connection.prototype.y_ = 0;
//Connects two connections together
LearnBlock.Connection.prototype.connect_ = function (a) {
    var b = this,
        c = b.getSourceBlock(),
        d = a.getSourceBlock();
    a.isConnected() && a.disconnect();
    if (b.isConnected()) {
        var e = b.targetBlock();
        if (b.type == LearnBlock.INPUT_VALUE) {
            if (!e.outputConnection) throw Error("Orphan block does not have an output connection.");
            var g = LearnBlock.Connection.lastConnectionInRow_(d, e);
            g && (e.outputConnection.connect(g), e = null)
        } else if (b.type ==
            LearnBlock.NEXT_STATEMENT) {
            if (!e.previousConnection) throw Error("Orphan block does not have a previous connection.");
            for (g = d; g.nextConnection;) {
                var h = g.getNextBlock();
                if (h) g = h;
                else {
                    e.previousConnection.checkType_(g.nextConnection) && (g.nextConnection.connect(e.previousConnection), e = null);
                    break
                }
            }
        }
        if (e && (b.disconnect(), LearnBlock.Events.recordUndo)) {
            var k = LearnBlock.Events.getGroup();
            setTimeout(function () {
                if (e.workspace && !e.getParent()) {
                    LearnBlock.Events.setGroup(k);
                    if (e.outputConnection) e.outputConnection.onFailedConnect(b);
                    else if (e.previousConnection) e.previousConnection.onFailedConnect(b);
                    LearnBlock.Events.setGroup(!1)
                }
            }, LearnBlock.BUMP_DELAY)
        }
    }
    var l;
    LearnBlock.Events.isEnabled() && (l = new LearnBlock.Events.BlockMove(d));
    LearnBlock.Connection.connectReciprocally_(b, a);
    d.setParent(c);
    l && (l.recordNew(), LearnBlock.Events.fire(l))
};
//Disposes of the connection, deals with connected blocks and removes the connection from db
LearnBlock.Connection.prototype.dispose = function () {
    if (this.isConnected()) {
        var a = this.targetBlock();
        a.unplug()
    }
    this.disposed = !0
};
//Gets the source block for the connection
LearnBlock.Connection.prototype.getSourceBlock = function () {
    return this.sourceBlock_
};
//Does the connection belong to a superior block?
LearnBlock.Connection.prototype.isSuperior = function () {
    return this.type == LearnBlock.INPUT_VALUE || this.type == LearnBlock.NEXT_STATEMENT
};
//Is the connection connected?
LearnBlock.Connection.prototype.isConnected = function () {
    return !!this.targetConnection
};
//Checks whether the current connection can connect with the target connection
LearnBlock.Connection.prototype.canConnectWithReason_ = function (a) {
    if (!a) {
        return LearnBlock.Connection.REASON_TARGET_NULL;
    }
    if (this.isSuperior()) {
        var blockA = this.sourceBlock_;
        var blockB = a.getSourceBlock();
    } else {
        var blockB = this.sourceBlock_;
        var blockA = a.getSourceBlock();
    }
    if (blockA && blockA == blockB) {
        return LearnBlock.Connection.REASON_SELF_CONNECTION;
    } else if (a.type != LearnBlock.OPPOSITE_TYPE[this.type]) {
        return LearnBlock.Connection.REASON_WRONG_TYPE;
    } else if (blockA && blockB && blockA.workspace !== blockB.workspace) {
        return LearnBlock.a.REASON_DIFFERENT_WORKSPACES;
    } else if (!this.checkType_(a)) {
        return LearnBlock.Connection.REASON_CHECKS_FAILED;
    }
    return LearnBlock.Connection.CAN_CONNECT;
};
//Checks whether the current connection and target connection are compatible
LearnBlock.Connection.prototype.checkConnection_ = function (a) {
    switch (this.canConnectWithReason_(a)) {
        case LearnBlock.Connection.CAN_CONNECT:
            break;
        case LearnBlock.Connection.REASON_SELF_CONNECTION:
            throw Error("Attempted to connect a block to itself.");
        case LearnBlock.Connection.REASON_DIFFERENT_WORKSPACES:
            throw Error("Blocks not on same workspace.");
        case LearnBlock.Connection.REASON_WRONG_TYPE:
            throw Error("Attempt to connect incompatible types.");
        case LearnBlock.Connection.REASON_TARGET_NULL:
            throw Error("Target connection is null.");
        case LearnBlock.Connection.REASON_CHECKS_FAILED:
            throw Error("Connection checks failed. " + (this + " expected " + this.check_ + ", found " + a.check_));
        default:
            throw Error("Unknown connection failure: this should never happen!");
    }
};
//Checks if two connections can be dragged to connect to each other
LearnBlock.Connection.prototype.canConnectToPrevious_ = function (a) {
    if (this.targetConnection || -1 != LearnBlock.draggingConnections_.indexOf(a)) return !1;
    if (!a.targetConnection) return !0;
    a = a.targetBlock();
    return a.isInsertionMarker() ? !a.getPreviousBlock() : !1
};
LearnBlock.Connection.prototype.isConnectionAllowed = function (a) {
    if (a.sourceBlock_.isInsertionMarker() || this.canConnectWithReason_(a) != LearnBlock.Connection.CAN_CONNECT) return !1;
    switch (a.type) {
        case LearnBlock.PREVIOUS_STATEMENT:
            return this.canConnectToPrevious_(a);
        case LearnBlock.OUTPUT_VALUE:
            if (a.isConnected() && !a.targetBlock().isInsertionMarker() || this.isConnected()) return !1;
            break;
        case LearnBlock.INPUT_VALUE:
            if (a.isConnected() && !a.targetBlock().isMovable() && !a.targetBlock().isShadow()) return !1;
            break;
        case LearnBlock.NEXT_STATEMENT:
            if (a.isConnected() &&
                !this.sourceBlock_.nextConnection && !a.targetBlock().isShadow() && a.targetBlock().nextConnection) return !1;
            break;
        default:
            throw Error("Unknown connection type in isConnectionAllowed");
    }
    return -1 != LearnBlock.draggingConnections_.indexOf(a) ? !1 : !0
};
//Behavior after a connection attempt fails (does nothing)
LearnBlock.Connection.prototype.onFailedConnect = function (a) {};
//Connects the connection to another connection
LearnBlock.Connection.prototype.connect = function (a) {
    if (this.targetConnection != a) {
        this.checkConnection_(a);
        var b = LearnBlock.Events.getGroup();
        b || LearnBlock.Events.setGroup(!0);
        this.isSuperior() ? this.connect_(a) : a.connect_(this);
        b || LearnBlock.Events.setGroup(!1)
    }
};
//Updates two connections to target each other
LearnBlock.Connection.connectReciprocally_ = function (a, b) {
    if (!a || !b) throw Error("Cannot connect null connections.");
    a.targetConnection = b;
    b.targetConnection = a
};
//Does the given block have one connection point that will accept an orphaned block?
LearnBlock.Connection.singleConnection_ = function (a, b) {
    for (var c = !1, d = 0; d < a.inputList.length; d++) {
        var e = a.inputList[d].connection;
        if (e && e.type == LearnBlock.INPUT_VALUE && b.outputConnection.checkType_(e)) {
            if (c) return null;
            c = e
        }
    }
    return c
};
//Walks down a row a blocks, at each stage checking if there are any connections that will accept the orphaned block
LearnBlock.Connection.lastConnectionInRow_ = function (a, b) {
    for (var c = a, d; d = LearnBlock.Connection.singleConnection_(c, b);)
        if (c = d.targetBlock(), !c) return d;
    return null
};
//Disconnects the connection
LearnBlock.Connection.prototype.disconnect = function () {
    var a = this.targetConnection;
    if (!a) throw Error("Source connection not connected.");
    if (a.targetConnection != this) throw Error("Target connection not connected to source connection.");
    if (this.isSuperior()) {
        var b = this.sourceBlock_;
        var c = a.getSourceBlock();
        a = this
    } else b = a.getSourceBlock(), c = this.sourceBlock_;
    var d = LearnBlock.Events.getGroup();
    d || LearnBlock.Events.setGroup(!0);
    this.disconnectInternal_(b, c);
    d || LearnBlock.Events.setGroup(!1)
};
//Disconnecs two block that are connected by this connection
LearnBlock.Connection.prototype.disconnectInternal_ = function (a, b) {
    var c;
    LearnBlock.Events.isEnabled() && (c = new LearnBlock.Events.BlockMove(b));
    this.targetConnection = this.targetConnection.targetConnection = null;
    b.setParent(null);
    c && (c.recordNew(), LearnBlock.Events.fire(c))
};
//Returns the block that this connection connects to
LearnBlock.Connection.prototype.targetBlock = function () {
    return this.isConnected() ? this.targetConnection.getSourceBlock() : null
};
//Is the connection compatible with another connection?
LearnBlock.Connection.prototype.checkType_ = function (a) {
    if (!this.check_ || !a.check_) return !0;
    for (var b = 0; b < this.check_.length; b++)
        if (-1 != a.check_.indexOf(this.check_[b])) return !0;
    return !1
};
//Called when the connection's compatible types have changed
LearnBlock.Connection.prototype.onCheckChanged_ = function () {
    this.isConnected() && !this.checkType_(this.targetConnection) && (this.isSuperior() ? this.targetBlock() : this.sourceBlock_).unplug()
};
//Changes a connection compatibilitty
LearnBlock.Connection.prototype.setCheck = function (a) {
    a ? (Array.isArray(a) || (a = [a]), this.check_ = a, this.onCheckChanged_()) : this.check_ = null;
    return this
};
//Gets a connection compatibility
LearnBlock.Connection.prototype.getCheck = function () {
    return this.check_
};
//Finds all nearby compatible connections
LearnBlock.Connection.prototype.neighbours_ = function (a) {
    return []
};
//Gets the parent input of a connection
LearnBlock.Connection.prototype.getParentInput = function () {
    for (var a = null, b = this.sourceBlock_, c = b.inputList, d = 0; d < b.inputList.length; d++)
        if (c[d].connection === this) {
            a = c[d];
            break
        } return a
};
//Returns a string describing the connection
LearnBlock.Connection.prototype.toString = function () {
    var a = this.sourceBlock_;
    if (a)
        if (a.outputConnection == this) var b = "Output Connection of ";
        else if (a.previousConnection == this) b = "Previous Connection of ";
    else if (a.nextConnection == this) b = "Next Connection of ";
    else {
        b = null;
        for (var c = 0, d; d = a.inputList[c]; c++)
            if (d.connection == this) {
                b = d;
                break
            } if (b) b = 'Input "' + b.name + '" connection on ';
        else return console.warn("Connection not actually connected to sourceBlock_"), "Orphan Connection"
    } else return "Orphan Connection";
    return b + a.toDevString()
};

//Set of all registered extensions
LearnBlock.Extensions = {};
LearnBlock.Extensions.ALL_ = {};
//Registers a new extension function
LearnBlock.Extensions.register = function (a, b) {
    if ("string" != typeof a || "" == a.trim()) throw Error('Error: Invalid extension name "' + a + '"');
    if (LearnBlock.Extensions.ALL_[a]) throw Error('Error: Extension "' + a + '" is already registered.');
    if ("function" != typeof b) throw Error('Error: Extension "' + a + '" must be a function');
    LearnBlock.Extensions.ALL_[a] = b
};
//Registers a new extension function that adds all key/value of mixinObj
LearnBlock.Extensions.registerMixin = function (a, b) {
    if (!b || "object" != typeof b) throw Error('Error: Mixin "' + a + '" must be a object');
    LearnBlock.Extensions.register(a, function () {
        this.mixin(b)
    })
};
//Unregisters the extension registered with the given name
LearnBlock.Extensions.unregister = function (a) {
    LearnBlock.Extensions.ALL_[a] ? delete LearnBlock.Extensions.ALL_[a] : console.warn('No extension mapping for name "' + a + '" found to unregister')
};
//Applies an extension method to a block
LearnBlock.Extensions.apply = function (a, b, c) {
    var d = LearnBlock.Extensions.ALL_[a];
    if ("function" != typeof d) throw Error('Error: Extension "' + a + '" not found.');
    d.apply(b);
};
//Checks that the given value is a function
LearnBlock.Extensions.checkHasFunction_ = function (a, b, c) {
    if (!b) throw Error(a + 'missing required property "' + c + '"');
    if ("function" != typeof b) throw Error(a + '" required property "' + c + '" must be a function');
};
//Builds an extension function that will map a dropdown value to a tooltip string
LearnBlock.Extensions.buildTooltipForDropdown = function (a, b) {
    var c = [];
    "object" == typeof document && LearnBlock.utils.runAfterPageLoad(function () {
        for (var a in b) LearnBlock.utils.checkMessageReferences(b[a])
    });
    return function () {
        this.type && -1 == c.indexOf(this.type) && (LearnBlock.Extensions.checkDropdownOptionsInTable_(this, a, b), c.push(this.type));
        this.setTooltip(function () {
            var d = this.getFieldValue(a),
                e = b[d];
            null == e ? -1 == c.indexOf(this.type) && (d = "No tooltip mapping for value " + d + " of field " + a, null != this.type && (d += " of block type " +
                this.type), console.warn(d + ".")) : e = LearnBlock.utils.replaceMessageReferences(e);
            return e
        }.bind(this))
    }
};
//Checks all options keys are present in the provided string lookup table
LearnBlock.Extensions.checkDropdownOptionsInTable_ = function (a, b, c) {
    var d = a.getField(b);
    if (!d.isOptionListDynamic()) {
        d = d.getOptions();
        for (var e = 0; e < d.length; ++e) {
            var f = d[e][1];
            null == c[f] && console.warn("No tooltip mapping for value " + f + " of field " + b + " of block type " + a.type)
        }
    }
};
//Builds an extension function that will install a dynamic tooltip
LearnBlock.Extensions.buildTooltipWithFieldText = function (a, b) {
    "object" == typeof document && LearnBlock.utils.runAfterPageLoad(function () {
        LearnBlock.utils.checkMessageReferences(a)
    });
    return function () {
        this.setTooltip(function () {
            var c = this.getField(b);
            return LearnBlock.utils.replaceMessageReferences(a).replace("%1", c ? c.getText() : "")
        }.bind(this))
    }
};
//Configures the tooltip to mimic the parent block when connected
LearnBlock.Extensions.extensionParentTooltip_ = function () {
    this.tooltipWhenNotConnected_ = this.tooltip;
    this.setTooltip(function () {
        var a = this.getParent();
        return a && a.getInputsInline() && a.tooltip || this.tooltipWhenNotConnected_
    }.bind(this))
};
LearnBlock.Extensions.register("parent_tooltip_when_inline", LearnBlock.Extensions.extensionParentTooltip_);

//Class for blocks animations
LearnBlock.blockAnimations = {};
LearnBlock.blockAnimations.disconnectPid_ = 0;
LearnBlock.blockAnimations.disconnectGroup_ = null;
//Plays some UI effects when disposing of a block
LearnBlock.blockAnimations.disposeUiEffect = function (a) {
    var b = a.workspace,
        c = a.getSvgRoot();
    a = b.getSvgXY(c);
    c = c.cloneNode(!0);
    c.translateX_ = a.x;
    c.translateY_ = a.y;
    c.setAttribute("transform", "translate(" + a.x + "," + a.y + ")");
    b.getParentSvg().appendChild(c);
    c.bBox_ = c.getBBox();
    LearnBlock.blockAnimations.disposeUiStep_(c, b.RTL, new Date, b.scale)
};
//Animates a cloned block and eventually dispose of it
LearnBlock.blockAnimations.disposeUiStep_ = function (a, b, c, d) {
    var e = (new Date - c) / 150;
    1 < e ? LearnBlock.utils.dom.removeNode(a) : (a.setAttribute("transform", "translate(" + (a.translateX_ + (b ? -1 : 1) * a.bBox_.width * d / 2 * e) + "," + (a.translateY_ + a.bBox_.height * d * e) + ") scale(" + (1 - e) * d + ")"), setTimeout(LearnBlock.blockAnimations.disposeUiStep_, 10, a, b, c, d))
};

//Class that controls updates to connections during drags
LearnBlock.InsertionMarkerManager = function (a) {
    this.topBlock_ = LearnBlock.selected = a;
    this.workspace_ = a.workspace;
    this.lastMarker_ = this.lastOnStack_ = null;
    this.firstMarker_ = this.createMarkerBlock_(this.topBlock_);
    this.localConnection_ = this.closestConnection_ = null;
    this.wouldDeleteBlock_ = !1;
    this.markerConnection_ = null;
    this.highlightingBlock_ = !1;
    this.highlightedBlock_ = null;
    this.availableConnections_ = this.initAvailableConnections_()
};
//Severs all links from this object
LearnBlock.InsertionMarkerManager.prototype.dispose = function () {
    this.workspace_ = this.topBlock_ = null;
    this.availableConnections_.length = 0;
    this.localConnection_ = this.closestConnection_ = null;
    LearnBlock.Events.disable();
    try {
        this.firstMarker_ && (this.firstMarker_.dispose(), this.firstMarker_ = null), this.lastMarker_ && (this.lastMarker_.dispose(), this.lastMarker_ = null)
    } finally {
        LearnBlock.Events.enable()
    }
    this.highlightedBlock_ = null
};
//Returns whether the block would be connected if dropped immediately
LearnBlock.InsertionMarkerManager.prototype.wouldConnectBlock = function () {
    return !!this.closestConnection_
};
//Connects to the closest connection and renders the results
LearnBlock.InsertionMarkerManager.prototype.applyConnections = function () {
    if (this.closestConnection_ && (LearnBlock.Events.disable(), this.hidePreview_(), LearnBlock.Events.enable(), this.localConnection_.connect(this.closestConnection_), this.topBlock_.rendered)) {
        var a = this.localConnection_.isSuperior() ? this.closestConnection_ : this.localConnection_;
        this.topBlock_.getRootBlock().bringToFront()
    }
};
//Updates highlighted connections based on the most recent move location
LearnBlock.InsertionMarkerManager.prototype.update = function (a, b) {
    var c = this.getCandidate_(a);
    if (this.shouldUpdatePreviews_(c, a)) LearnBlock.Events.disable(), this.maybeHidePreview_(c), this.maybeShowPreview_(c), LearnBlock.Events.enable()
};
//Creates an insertion marker that represents the given block
LearnBlock.InsertionMarkerManager.prototype.createMarkerBlock_ = function (a) {
    var b = a.type;
    LearnBlock.Events.disable();
    try {
        var c = this.workspace_.newBlock(b);
        c.setInsertionMarker(!0, a.width);
        for (b = 0; b < a.inputList.length; b++) {
            var e = a.inputList[b],
                f = c.inputList[b];
            for (var d = 0; d < e.fieldRow.length; d++) f.fieldRow[d].setValue(e.fieldRow[d].getValue())
        }
        c.initSvg();
        c.getSvgRoot().setAttribute("visibility", "hidden")
    } finally {
        LearnBlock.Events.enable()
    }
    return c
};
//Populates the list of available connections on this block stack
LearnBlock.InsertionMarkerManager.prototype.initAvailableConnections_ = function () {
    var a = this.topBlock_.getConnections_(!1),
        b = this.topBlock_.lastConnectionInStack();
    b && b != this.topBlock_.nextConnection && (a.push(b), this.lastOnStack_ = b, this.lastMarker_ = this.createMarkerBlock_(b.sourceBlock_));
    return a
};
//Whether the previews should be updated based on the closest candidate and the current drag distance
LearnBlock.InsertionMarkerManager.prototype.shouldUpdatePreviews_ = function (a, b) {
    var c = a.local,
        d = a.closest,
        e = a.radius;
    if (c && d) {
        if (this.localConnection_ && this.closestConnection_) {
            if (this.closestConnection_ == d && this.localConnection_ == c) return !1;
            c = this.localConnection_.x_ + b.x - this.closestConnection_.x_;
            var f = this.localConnection_.y_ + b.y - this.closestConnection_.y_;
            c = Math.sqrt(c * c + f * f);
            return !(d && e > c - LearnBlock.CURRENT_CONNECTION_PREFERENCE)
        }
        if (this.localConnection_ || this.closestConnection_) console.error("Only one of localConnection_ and closestConnection_ was set.");
        else return !0
    } else return !(!this.localConnection_ || !this.closestConnection_);
    console.error("Returning true from shouldUpdatePreviews, but it's not clear why.");
    return !0
};
//Finds the nearest valid connection
LearnBlock.InsertionMarkerManager.prototype.getCandidate_ = function (a) {
    for (var b = this.getStartRadius_(), c = null, d = null, e = 0; e < this.availableConnections_.length; e++) {
        var f = this.availableConnections_[e],
            g = f.closest(b, a);
        g.connection && (c = g.connection, d = f, b = g.radius)
    }
    return {
        closest: c,
        local: d,
        radius: b
    }
};
//Decides the radius at which to start searching for the closest connection
LearnBlock.InsertionMarkerManager.prototype.getStartRadius_ = function () {
    return this.closestConnection_ && this.localConnection_ ? LearnBlock.CONNECTING_SNAP_RADIUS : LearnBlock.SNAP_RADIUS
};
//Whether ending the drag would replace a block or insert a block
LearnBlock.InsertionMarkerManager.prototype.shouldReplace_ = function () {
    var a = this.closestConnection_,
        b = this.localConnection_;
    return b.type == LearnBlock.OUTPUT_VALUE ? !a.isConnected() || LearnBlock.Connection.lastConnectionInRow_(this.topBlock_, a.targetConnection.getSourceBlock()) ? !1 : !0 : b == b.sourceBlock_.getFirstStatementConnection() ? !1 : !this.topBlock_.nextConnection && b.type == LearnBlock.PREVIOUS_STATEMENT && a.isConnected() ? !0 : !1
};
//Shows an insertion marker or replacement highlighting during a drag
LearnBlock.InsertionMarkerManager.prototype.maybeShowPreview_ = function (a) {
    var b = a.closest;
    a = a.local;
    b && (b == this.closestConnection_ || b.sourceBlock_.isInsertionMarker() ? console.log("Trying to connect to an insertion marker") : (this.closestConnection_ = b, this.localConnection_ = a, this.showPreview_()))

};
//A preview should be shown
LearnBlock.InsertionMarkerManager.prototype.showPreview_ = function () {
    this.shouldReplace_() ? this.highlightBlock_() : this.connectMarker_();
    this.closestConnection_ && this.closestConnection_.highlight()
};
//Show an insertion marker or replacement highlighting during a drag
LearnBlock.InsertionMarkerManager.prototype.maybeHidePreview_ = function (a) {
    if (a.closest) {
        var b = this.closestConnection_ != a.closest;
        a = this.localConnection_ != a.local;
        this.closestConnection_ && this.localConnection_ && (b || a) && this.hidePreview_()
    } else this.hidePreview_();
    this.localConnection_ = this.closestConnection_ = this.markerConnection_ = null
};
//A preview should be hidden
LearnBlock.InsertionMarkerManager.prototype.hidePreview_ = function () {
    this.closestConnection_ && this.closestConnection_.unhighlight();
    this.highlightingBlock_ ? this.unhighlightBlock_() : this.markerConnection_ && this.disconnectMarker_()
};
//Adds highlighting showing which block will be replaced
LearnBlock.InsertionMarkerManager.prototype.highlightBlock_ = function () {
    var a = this.closestConnection_,
        b = this.localConnection_;
    a.targetBlock() ? (this.highlightedBlock_ = a.targetBlock(), a.targetBlock().highlightForReplacement(!0)) : b.type == LearnBlock.OUTPUT_VALUE && (this.highlightedBlock_ = a.sourceBlock_, a.sourceBlock_.highlightShapeForInput(a, !0));
    this.highlightingBlock_ = !0
};
//Gets rid of the highlighting marking the block that will be replaced
LearnBlock.InsertionMarkerManager.prototype.unhighlightBlock_ = function () {
    var a = this.closestConnection_;
    a.type != LearnBlock.INPUT_VALUE || a.isConnected() ? this.highlightedBlock_.highlightForReplacement(!1) : this.highlightedBlock_.highlightShapeForInput(a, !1);
    this.highlightedBlock_ = null;
    this.highlightingBlock_ = !1
};
//Disconnects the insertion marker block in a manner that returns the stack to original state
LearnBlock.InsertionMarkerManager.prototype.disconnectMarker_ = function () {
    if (this.markerConnection_) {
        var a = this.markerConnection_,
            b = a.sourceBlock_,
            c = b.nextConnection,
            d = b.previousConnection,
            e = b.outputConnection;
        e = a.type == LearnBlock.INPUT_VALUE && !(e && e.targetConnection);
        !(a != c || d && d.targetConnection) || e ? a.targetBlock().unplug(!1) : a.type == LearnBlock.NEXT_STATEMENT && a != c ? (c = a.targetConnection, c.sourceBlock_.unplug(!1), d = d ? d.targetConnection : null, b.unplug(!0), d && d.connect(c)) : b.unplug(!0);
        if (a.targetConnection) throw Error("markerConnection_ still connected at the end of disconnectInsertionMarker");
        this.markerConnection_ = null;
        b.getSvgRoot().setAttribute("visibility", "hidden")
    } else console.log("No insertion marker connection to disconnect")
};
//Adds an insertion marker connected to the appropriate blocks
LearnBlock.InsertionMarkerManager.prototype.connectMarker_ = function () {
    var a = this.localConnection_,
        b = this.closestConnection_,
        c = this.lastOnStack_ && a == this.lastOnStack_ ? this.lastMarker_ : this.firstMarker_;
    a = c.getMatchingConnection(a.sourceBlock_, a);
    if (a == this.markerConnection_) throw Error("Made it to connectMarker_ even though the marker isn't changing");
    c.render();
    c.rendered = !0;
    c.getSvgRoot().setAttribute("visibility", "visible");
    c.positionNewBlock(c, a, b);
    a.connect(b);
    this.markerConnection_ = a
};
//Gets a list of the insertion markers that currently exist
LearnBlock.InsertionMarkerManager.prototype.getInsertionMarkers = function () {
    var a = [];
    this.firstMarker_ && a.push(this.firstMarker_);
    this.lastMarker_ && a.push(this.lastMarker_);
    return a
};

//Class for a block dragger
LearnBlock.BlockDragger = function (a, b) {
    this.draggingBlock_ = a;
    this.workspace_ = b;
    this.draggedConnectionManager_ = new LearnBlock.InsertionMarkerManager(this.draggingBlock_);
    this.deleteArea_ = null;
    this.wouldDeleteBlock_ = !1;
    this.startXY_ = this.draggingBlock_.getRelativeToSurfaceXY()
};
//Severs all links from this object
LearnBlock.BlockDragger.prototype.dispose = function () {
    this.startWorkspace_ = this.workspace_ = this.draggingBlock_ = null;
    this.draggedConnectionManager_ && (this.draggedConnectionManager_.dispose(), this.draggedConnectionManager_ = null)
};
//Starts dragging a block
LearnBlock.BlockDragger.prototype.startBlockDrag = function (a, b) {
    LearnBlock.Events.getGroup() || LearnBlock.Events.setGroup(!0);
    LearnBlock.utils.dom.startTextWidthCache();
    this.workspace_.setResizesEnabled(!1);
    if (this.draggingBlock_.getParent() || b && this.draggingBlock_.nextConnection && this.draggingBlock_.nextConnection.targetBlock()) {
        this.draggingBlock_.unplug(b);
        var c = this.pixelsToWorkspaceUnits_(a);
        c = LearnBlock.utils.Coordinate.sum(this.startXY_,
            c);
        this.draggingBlock_.translate(c.x, c.y);
    }
    this.draggingBlock_.setDragging(!0);
    this.draggingBlock_.moveToDragSurface_();
    if (c = this.workspace_.getToolbox()) {
        var d = this.draggingBlock_.isDeletable() ? "blocklyToolboxDelete" : "blocklyToolboxGrab";
        c.addStyle(d)
    }
};
//Executes a step of block dragging based on the given event
LearnBlock.BlockDragger.prototype.dragBlock = function (a, b) {
    var c = this.pixelsToWorkspaceUnits_(b),
        d = LearnBlock.utils.Coordinate.sum(this.startXY_, c);
    this.draggingBlock_.moveDuringDrag(d);
    this.draggedConnectionManager_.update(c, this.deleteArea_);
};
//Finishes a block drag and puts the block back on the workspace
LearnBlock.BlockDragger.prototype.endBlockDrag = function (e, currentDragDeltaXY) {
    this.dragBlock(e, currentDragDeltaXY);
    LearnBlock.utils.dom.stopTextWidthCache();
    var delta = this.pixelsToWorkspaceUnits_(currentDragDeltaXY);
    var newLoc = LearnBlock.utils.Coordinate.sum(this.startXY_, delta);
    this.draggingBlock_.moveOffDragSurface_(newLoc);
    this.draggingBlock_.moveConnections_(delta.x, delta.y);
    this.draggingBlock_.setDragging(false);
    this.fireMoveEvent_();
    if (this.draggedConnectionManager_.wouldConnectBlock()) this.draggedConnectionManager_.applyConnections();
    else this.draggingBlock_.render();
    this.draggingBlock_.scheduleSnapAndBump();
    this.workspace_.setResizesEnabled(true);
    var toolbox = this.workspace_.getToolbox();
    if (toolbox) {
        var style = this.draggingBlock_.isDeletable() ? 'blocklyToolboxDelete' :
            'blocklyToolboxGrab';
        toolbox.removeStyle(style);
    }
    LearnBlock.Events.setGroup(false);
};
//Fires a move event at the end of a block drag
LearnBlock.BlockDragger.prototype.fireMoveEvent_ = function () {
    var a = new LearnBlock.Events.BlockMove(this.draggingBlock_);
    a.oldCoordinate = this.startXY_;
    a.recordNew();
    LearnBlock.Events.fire(a)
};
//Converts a coordinate object from pixels to workspace units
LearnBlock.BlockDragger.prototype.pixelsToWorkspaceUnits_ = function (a) {
    a = new LearnBlock.utils.Coordinate(a.x / this.workspace_.scale, a.y / this.workspace_.scale);
    this.workspace_.isMutator && a.scale(1 / this.workspace_.options.parentWorkspace.scale);
    return a
};
//Gets a list of the insertion markers that currently exist
LearnBlock.BlockDragger.prototype.getInsertionMarkers = function () {
    return this.draggedConnectionManager_ && this.draggedConnectionManager_.getInsertionMarkers ? this.draggedConnectionManager_.getInsertionMarkers() : []
};

//Class for touch on the workspace events (mouse)
LearnBlock.Touch = {};
LearnBlock.Touch.touchIdentifier_ = null;
//Dictionary that specifies additional touch (mouse) events to fire
LearnBlock.Touch.TOUCH_MAP = {};
if (LearnBlock.utils.global.PointerEvent) {
    LearnBlock.Touch.TOUCH_MAP = {
        mousedown: ["pointerdown"],
        mouseenter: ["pointerenter"],
        mouseleave: ["pointerleave"],
        mousemove: ["pointermove"],
        mouseout: ["pointerout"],
        mouseover: ["pointerover"],
        mouseup: ["pointerup", "pointercancel"],
        touchend: ["pointerup"],
        touchcancel: ["pointercancel"]
    };
}
LearnBlock.longPid_ = 0;
//Kills the queued long-press task
LearnBlock.longStop_ = function () {
    LearnBlock.longPid_ && (clearTimeout(LearnBlock.longPid_), LearnBlock.longPid_ = 0)
};
//Clears the touch identifier that tracks which touch stream to pay attention to
LearnBlock.Touch.clearTouchIdentifier = function () {
    LearnBlock.Touch.touchIdentifier_ = null
};
//Decides whether should handle or ignore the event
LearnBlock.Touch.shouldHandleEvent = function (a) {
    return !LearnBlock.Touch.isMouseOrTouchEvent(a) || LearnBlock.Touch.checkTouchIdentifier(a)
};
//Gets the touch (mouse) identifier from the given event
LearnBlock.Touch.getTouchIdentifierFromEvent = function (a) {
    return void 0 != a.pointerId ? a.pointerId : a.changedTouches && a.changedTouches[0] && void 0 !== a.changedTouches[0].identifier && null !== a.changedTouches[0].identifier ? a.changedTouches[0].identifier : "mouse"
};
//Checks whether the touch identifier on the event matches the current saved identifier
LearnBlock.Touch.checkTouchIdentifier = function (a) {
    var b = LearnBlock.Touch.getTouchIdentifierFromEvent(a);
    return void 0 !== LearnBlock.Touch.touchIdentifier_ && null !== LearnBlock.Touch.touchIdentifier_ ? LearnBlock.Touch.touchIdentifier_ == b : "mousedown" == a.type || "pointerdown" == a.type ? (LearnBlock.Touch.touchIdentifier_ = b, !0) : !1
};
//Makes a touch event work in a mouse event handler
LearnBlock.Touch.setClientFromTouch = function (a) {
    if (LearnBlock.utils.string.startsWith(a.type, "touch")) {
        var b = a.changedTouches[0];
        a.clientX = b.clientX;
        a.clientY = b.clientY
    }
};
//Check whether a given event is a mouse or pointer event
LearnBlock.Touch.isMouseOrTouchEvent = function (a) {
    return LearnBlock.utils.string.startsWith(a.type, "mouse") || LearnBlock.utils.string.startsWith(a.type, "pointer")
};
//Checks when a given event is a pointer event
LearnBlock.Touch.isTouchEvent = function (a) {
    return LearnBlock.utils.string.startsWith(a.type, "pointer")
};
//Splits an event into an array of events
LearnBlock.Touch.splitEventByTouches = function (a) {
    var b = [];
    if (a.changedTouches)
        for (var c = 0; c < a.changedTouches.length; c++) b[c] = {
            type: a.type,
            changedTouches: [a.changedTouches[c]],
            target: a.target,
            stopPropagation: function () {
                a.stopPropagation()
            },
            preventDefault: function () {
                a.preventDefault()
            }
        };
    else b.push(a);
    return b
};

//Class for a pair of scrollbars: horizontal and vertical
LearnBlock.ScrollbarPair = function (a) {
    this.workspace_ = a;
    this.hScroll = new LearnBlock.Scrollbar(a, !0, !0, "blocklyMainWorkspaceScrollbar");
    this.vScroll = new LearnBlock.Scrollbar(a, !1, !0, "blocklyMainWorkspaceScrollbar");
    this.corner_ = LearnBlock.utils.dom.createSvgElement("rect", {
        height: LearnBlock.Scrollbar.scrollbarThickness,
        width: LearnBlock.Scrollbar.scrollbarThickness,
        "class": "blocklyScrollbarBackground"
    }, null);
};
LearnBlock.ScrollbarPair.prototype.oldHostMetrics_ = null;
//Dispose of the pair of scrollbars
LearnBlock.ScrollbarPair.prototype.dispose = function () {
    LearnBlock.utils.dom.removeNode(this.corner_);
    this.oldHostMetrics_ = this.workspace_ = this.corner_ = null;
    this.hScroll.dispose();
    this.hScroll = null;
    this.vScroll.dispose();
    this.vScroll = null
};
//Recalculates both of the scrollbars' locations and lengths
LearnBlock.ScrollbarPair.prototype.resize = function () {
    var a = this.workspace_.getMetrics();
    if (a) {
        var b = !1,
            c = !1;
        this.oldHostMetrics_ && this.oldHostMetrics_.viewWidth == a.viewWidth && this.oldHostMetrics_.viewHeight == a.viewHeight && this.oldHostMetrics_.absoluteTop == a.absoluteTop && this.oldHostMetrics_.absoluteLeft == a.absoluteLeft ? (this.oldHostMetrics_ && this.oldHostMetrics_.contentWidth == a.contentWidth && this.oldHostMetrics_.viewLeft == a.viewLeft && this.oldHostMetrics_.contentLeft == a.contentLeft || (b = !0), this.oldHostMetrics_ &&
            this.oldHostMetrics_.contentHeight == a.contentHeight && this.oldHostMetrics_.viewTop == a.viewTop && this.oldHostMetrics_.contentTop == a.contentTop || (c = !0)) : c = b = !0;
        b && this.hScroll.resize(a);
        c && this.vScroll.resize(a);
        this.oldHostMetrics_ && this.oldHostMetrics_.viewWidth == a.viewWidth && this.oldHostMetrics_.absoluteLeft == a.absoluteLeft || this.corner_.setAttribute("x", this.vScroll.position_.x);
        this.oldHostMetrics_ && this.oldHostMetrics_.viewHeight == a.viewHeight && this.oldHostMetrics_.absoluteTop == a.absoluteTop || this.corner_.setAttribute("y",
            this.hScroll.position_.y);
        this.oldHostMetrics_ = a
    }
};
//Sets the handles of both scrollbars to be at a certain position
LearnBlock.ScrollbarPair.prototype.set = function (a, b) {
    var c = {},
        d = a * this.hScroll.ratio_,
        e = b * this.vScroll.ratio_,
        f = this.vScroll.scrollViewSize_;
    c.x = this.getRatio_(d, this.hScroll.scrollViewSize_);
    c.y = this.getRatio_(e, f);
    this.workspace_.setMetrics(c);
    this.hScroll.setHandlePosition(d);
    this.vScroll.setHandlePosition(e)
};
//Helper to calculate the ratio of handle position to scrollbar view size
LearnBlock.ScrollbarPair.prototype.getRatio_ = function (a, b) {
    var c = a / b;
    return isNaN(c) ? 0 : c
};

//Class for a pure SVG scrollbar
LearnBlock.Scrollbar = function (a, b, c, d) {
    this.workspace_ = a;
    this.pair_ = c || !1;
    this.horizontal_ = b;
    this.oldHostMetrics_ = null;
    this.createDom_(d);
    this.position_ = new LearnBlock.utils.Coordinate(0, 0);
    a = LearnBlock.Scrollbar.scrollbarThickness;
    b ? (this.svgBackground_.setAttribute("height", a), this.outerSvg_.setAttribute("height", a), this.svgHandle_.setAttribute("height", a - 5), this.svgHandle_.setAttribute("y", 2.5), this.lengthAttribute_ = "width", this.positionAttribute_ = "x") : (this.svgBackground_.setAttribute("width", a), this.outerSvg_.setAttribute("width",
        a), this.svgHandle_.setAttribute("width", a - 5), this.svgHandle_.setAttribute("x", 2.5), this.lengthAttribute_ = "height", this.positionAttribute_ = "y");
    this.onMouseDownBarWrapper_ = LearnBlock.bindEventWithChecks_(this.svgBackground_, "mousedown", this, this.onMouseDownBar_);
    this.onMouseDownHandleWrapper_ = LearnBlock.bindEventWithChecks_(this.svgHandle_, "mousedown", this, this.onMouseDownHandle_)
};
LearnBlock.Scrollbar.prototype.origin_ = new LearnBlock.utils.Coordinate(0, 0);
LearnBlock.Scrollbar.prototype.startDragMouse_ = 0;
LearnBlock.Scrollbar.prototype.scrollViewSize_ = 0;
LearnBlock.Scrollbar.prototype.handleLength_ = 0;
LearnBlock.Scrollbar.prototype.handlePosition_ = 0;
LearnBlock.Scrollbar.prototype.isVisible_ = !0;
LearnBlock.Scrollbar.prototype.containerVisible_ = !0;
LearnBlock.Scrollbar.scrollbarThickness = 15;
LearnBlock.Touch.TOUCH_ENABLED && (LearnBlock.Scrollbar.scrollbarThickness = 25);
//Whether the two sets of metrics are equivalent
LearnBlock.Scrollbar.metricsAreEquivalent_ = function (a, b) {
    return a && b && a.viewWidth == b.viewWidth && a.viewHeight == b.viewHeight && a.viewLeft == b.viewLeft && a.viewTop == b.viewTop && a.absoluteTop == b.absoluteTop && a.absoluteLeft == b.absoluteLeft && a.contentWidth == b.contentWidth && a.contentHeight == b.contentHeight && a.contentLeft == b.contentLeft && a.contentTop == b.contentTop ? !0 : !1
};
//Dispose of the scrollbar
LearnBlock.Scrollbar.prototype.dispose = function () {
    this.cleanUp_();
    LearnBlock.unbindEvent_(this.onMouseDownBarWrapper_);
    this.onMouseDownBarWrapper_ = null;
    LearnBlock.unbindEvent_(this.onMouseDownHandleWrapper_);
    this.onMouseDownHandleWrapper_ = null;
    LearnBlock.utils.dom.removeNode(this.outerSvg_);
    this.svgBackground_ = this.svgGroup_ = this.outerSvg_ = null;
    this.svgHandle_ && (this.workspace_.getThemeManager().unsubscribe(this.svgHandle_), this.svgHandle_ = null);
    this.workspace_ = null
};
//Sets the length of the scrollbar's handle
LearnBlock.Scrollbar.prototype.setHandleLength_ = function (a) {
    this.handleLength_ = a;
    this.svgHandle_.setAttribute(this.lengthAttribute_, this.handleLength_)
};
//Sets the offset of the scrollbar's handle from the scrollbar's position
LearnBlock.Scrollbar.prototype.setHandlePosition = function (a) {
    this.handlePosition_ = a;
    this.svgHandle_.setAttribute(this.positionAttribute_, this.handlePosition_)
};
//Sets the size of the scrollbar's background
LearnBlock.Scrollbar.prototype.setScrollViewSize_ = function (a) {
    this.scrollViewSize_ = a;
    this.outerSvg_.setAttribute(this.lengthAttribute_, this.scrollViewSize_);
    this.svgBackground_.setAttribute(this.lengthAttribute_, this.scrollViewSize_)
};
//Sets whether the scrollbar's container is visible
LearnBlock.ScrollbarPair.prototype.setContainerVisible = function (a) {
    this.hScroll.setContainerVisible(a);
    this.vScroll.setContainerVisible(a)
};
//Sets the position of the scrollbar's SVG group
LearnBlock.Scrollbar.prototype.setPosition_ = function (a, b) {
    this.position_.x = a;
    this.position_.y = b;
    LearnBlock.utils.dom.setCssTransform(this.outerSvg_, "translate(" + (this.position_.x + this.origin_.x) + "px," + (this.position_.y + this.origin_.y) + "px)")
};
//Recalculates the scrollbar's location and its length
LearnBlock.Scrollbar.prototype.resize = function (a) {
    if (!a && (a = this.workspace_.getMetrics(), !a)) return;
    LearnBlock.Scrollbar.metricsAreEquivalent_(a, this.oldHostMetrics_) || (this.oldHostMetrics_ = a, this.horizontal_ ? this.resizeHorizontal_(a) : this.resizeVertical_(a), this.onScroll_())
};
//Recalculates a horizontal scrollbar's location and length
LearnBlock.Scrollbar.prototype.resizeHorizontal_ = function (a) {
    this.resizeViewHorizontal(a)
};
//Recalculates a horizontal scrollbar's location on the screen and path length
LearnBlock.Scrollbar.prototype.resizeViewHorizontal = function (a) {
    var b = a.viewWidth - 1;
    this.pair_ && (b -= LearnBlock.Scrollbar.scrollbarThickness);
    this.setScrollViewSize_(Math.max(0, b));
    b = a.absoluteLeft + .5;
    this.pair_ && this.workspace_.RTL && (b += LearnBlock.Scrollbar.scrollbarThickness);
    this.setPosition_(b, a.absoluteTop + a.viewHeight - LearnBlock.Scrollbar.scrollbarThickness - .5);
    this.resizeContentHorizontal(a)
};
//Recalculates a horizontal scrollbar's location within its path and length
LearnBlock.Scrollbar.prototype.resizeContentHorizontal = function (a) {
    this.pair_ || this.setVisible(this.scrollViewSize_ < a.contentWidth);
    this.ratio_ = this.scrollViewSize_ / a.contentWidth;
    if (-Infinity == this.ratio_ || Infinity == this.ratio_ || isNaN(this.ratio_)) this.ratio_ = 0;
    this.setHandleLength_(Math.max(0, a.viewWidth * this.ratio_));
    this.setHandlePosition(this.constrainHandle_((a.viewLeft - a.contentLeft) * this.ratio_))
};
//Recalculates a vertical scrollbar's location and length
LearnBlock.Scrollbar.prototype.resizeVertical_ = function (a) {
    this.resizeViewVertical(a)
};
//Recalculates a vertical scrollbar's location on the screen and path length
LearnBlock.Scrollbar.prototype.resizeViewVertical = function (a) {
    var b = a.viewHeight - 1;
    this.pair_ && (b -= LearnBlock.Scrollbar.scrollbarThickness);
    this.setScrollViewSize_(Math.max(0, b));
    b = a.absoluteLeft + .5;
    this.workspace_.RTL || (b += a.viewWidth - LearnBlock.Scrollbar.scrollbarThickness - 1);
    this.setPosition_(b, a.absoluteTop + .5);
    this.resizeContentVertical(a)
};
//Recalculates a vertical scrollbar's location within its path and length
LearnBlock.Scrollbar.prototype.resizeContentVertical = function (a) {
    this.pair_ || this.setVisible(this.scrollViewSize_ < a.contentHeight);
    this.ratio_ = this.scrollViewSize_ / a.contentHeight;
    if (-Infinity == this.ratio_ || Infinity == this.ratio_ || isNaN(this.ratio_)) this.ratio_ = 0;
    this.setHandleLength_(Math.max(0, a.viewHeight * this.ratio_));
    this.setHandlePosition(this.constrainHandle_((a.viewTop - a.contentTop) * this.ratio_))
};
//Creates all the DOM elements required for a scrollbar
LearnBlock.Scrollbar.prototype.createDom_ = function (a) {
    var b = "blocklyScrollbar" + (this.horizontal_ ? "Horizontal" : "Vertical");
    a && (b += " " + a);
    this.outerSvg_ = LearnBlock.utils.dom.createSvgElement("svg", {
        "class": b
    }, null);
    this.svgGroup_ = LearnBlock.utils.dom.createSvgElement("g", {}, this.outerSvg_);
    this.svgBackground_ = LearnBlock.utils.dom.createSvgElement("rect", {
        "class": "blocklyScrollbarBackground"
    }, this.svgGroup_);
    a = Math.floor((LearnBlock.Scrollbar.scrollbarThickness - 5) / 2);
    this.svgHandle_ = LearnBlock.utils.dom.createSvgElement("rect", {
        "class": "blocklyScrollbarHandle",
        rx: a,
        ry: a
    }, this.svgGroup_);
    this.workspace_.getThemeManager().subscribe(this.svgHandle_, "scrollbar", "fill");
    this.workspace_.getThemeManager().subscribe(this.svgHandle_, "scrollbarOpacity", "fill-opacity");
    LearnBlock.utils.dom.insertAfter(this.outerSvg_, this.workspace_.getParentSvg())
};
//Is the scrollbar visible?
LearnBlock.Scrollbar.prototype.isVisible = function () {
    return this.isVisible_
};
//Sets whether the scrollbar' container is visible and updates display accordingly if visibility has changed
LearnBlock.Scrollbar.prototype.setContainerVisible = function (a) {
    var b = a != this.containerVisible_;
    this.containerVisible_ = a;
    b && this.updateDisplay_()
};
//Sets whether the scrollbar is visible
LearnBlock.Scrollbar.prototype.setVisible = function (a) {
    var b = a != this.isVisible();
    if (this.pair_) throw Error("Unable to toggle visibility of paired scrollbars.");
    this.isVisible_ = a;
    b && this.updateDisplay_()
};
//Updates visibility of scrollbar based on whether it thinks it should be visible and whether its containing workspace is visible
LearnBlock.Scrollbar.prototype.updateDisplay_ = function () {
    this.containerVisible_ && this.isVisible() ? this.outerSvg_.setAttribute("display", "block") : this.outerSvg_.setAttribute("display", "none")
};
//Scrolls by one pageful
LearnBlock.Scrollbar.prototype.onMouseDownBar_ = function (a) {
    this.workspace_.markFocused();
    LearnBlock.Touch.clearTouchIdentifier();
    this.cleanUp_();
    if (LearnBlock.utils.isRightButton(a)) a.stopPropagation();
    else {
        var b = LearnBlock.utils.mouseToSvg(a, this.workspace_.getParentSvg(), this.workspace_.getInverseScreenCTM());
        b = this.horizontal_ ? b.x : b.y;
        var c = LearnBlock.utils.getInjectionDivXY_(this.svgHandle_);
        c = this.horizontal_ ? c.x : c.y;
        var d = this.handlePosition_,
            e = .95 * this.handleLength_;
        b <= c ? d -= e : b >= c + this.handleLength_ && (d +=
            e);
        this.setHandlePosition(this.constrainHandle_(d));
        this.onScroll_();
        a.stopPropagation();
        a.preventDefault()
    }
};
//Starts a dragging operation
LearnBlock.Scrollbar.prototype.onMouseDownHandle_ = function (a) {
    this.workspace_.markFocused();
    this.cleanUp_();
    LearnBlock.utils.isRightButton(a) ? a.stopPropagation() : (this.startDragHandle = this.handlePosition_, this.workspace_.setupDragSurface(), this.startDragMouse_ = this.horizontal_ ? a.clientX : a.clientY, LearnBlock.Scrollbar.onMouseUpWrapper_ = LearnBlock.bindEventWithChecks_(document, "mouseup", this, this.onMouseUpHandle_), LearnBlock.Scrollbar.onMouseMoveWrapper_ = LearnBlock.bindEventWithChecks_(document, "mousemove", this, this.onMouseMoveHandle_),
        a.stopPropagation(), a.preventDefault())
};
//Drags the scrollbar's handle
LearnBlock.Scrollbar.prototype.onMouseMoveHandle_ = function (a) {
    this.setHandlePosition(this.constrainHandle_(this.startDragHandle + ((this.horizontal_ ? a.clientX : a.clientY) - this.startDragMouse_)));
    this.onScroll_()
};
//Releases the scrollbar handle and resets state accordingly
LearnBlock.Scrollbar.prototype.onMouseUpHandle_ = function () {
    this.workspace_.resetDragSurface();
    LearnBlock.Touch.clearTouchIdentifier();
    this.cleanUp_()
};
//Hides chaff and stops binding to mouseup and mousemove events
LearnBlock.Scrollbar.prototype.cleanUp_ = function () {
    LearnBlock.hideChaff(!0);
    LearnBlock.Scrollbar.onMouseUpWrapper_ && (LearnBlock.unbindEvent_(LearnBlock.Scrollbar.onMouseUpWrapper_), LearnBlock.Scrollbar.onMouseUpWrapper_ = null);
    LearnBlock.Scrollbar.onMouseMoveWrapper_ && (LearnBlock.unbindEvent_(LearnBlock.Scrollbar.onMouseMoveWrapper_), LearnBlock.Scrollbar.onMouseMoveWrapper_ = null)
};
//Constrain the handle's position within the minimum and maximum values allowed for the scrollbar
LearnBlock.Scrollbar.prototype.constrainHandle_ = function (a) {
    return a = 0 >= a || isNaN(a) || this.scrollViewSize_ < this.handleLength_ ? 0 : Math.min(a, this.scrollViewSize_ - this.handleLength_)
};
//Called when scrollbar is moved
LearnBlock.Scrollbar.prototype.onScroll_ = function () {
    var a = this.handlePosition_ / this.scrollViewSize_;
    isNaN(a) && (a = 0);
    var b = {};
    this.horizontal_ ? b.x = a : b.y = a;
    this.workspace_.setMetrics(b)
};
//Sets the scrollbar handle's position
LearnBlock.Scrollbar.prototype.set = function (a) {
    this.setHandlePosition(this.constrainHandle_(a * this.ratio_));
    this.onScroll_()
};
//Records the origin of the workspace that the scrollbar is in
LearnBlock.Scrollbar.prototype.setOrigin = function (a, b) {
    this.origin_ = new LearnBlock.utils.Coordinate(a, b)
};

//Utils math
LearnBlock.utils.math = {};
//Converts degrees to radians
LearnBlock.utils.math.toRadians = function (a) {
    return a * Math.PI / 180
};
//Converts radians to degrees
LearnBlock.utils.math.toDegrees = function (a) {
    return 180 * a / Math.PI
};
//Clamps the provided number between the lower bound and the upper bound
LearnBlock.utils.math.clamp = function (a, b, c) {
    if (c < a) {
        var d = c;
        c = a;
        a = d
    }
    return Math.max(a, Math.min(b, c))
};

//Class for a cursor
LearnBlock.Cursor = function () {
    this.drawer_ = this.curNode_ = null
};
//Sets the object in charge of drawing the cursor
LearnBlock.Cursor.prototype.setDrawer = function (a) {
    this.drawer_ = a
};
//Gets the current drawer for the cursor
LearnBlock.Cursor.prototype.getDrawer = function () {
    return this.drawer_
};
//Gets the current location of the cursor
LearnBlock.Cursor.prototype.getCurNode = function () {
    return this.curNode_
};
//Sets the location of the cursor and calls the update method
LearnBlock.Cursor.prototype.setCurNode = function (a) {
    this.curNode_ = a;
    this.drawer_ && this.drawer_.draw(this.getCurNode())
};
//Hides the cursor SVG
LearnBlock.Cursor.prototype.hide = function () {
    this.drawer_ && this.drawer_.hide()
};
//Finds the next connection, field, or block
LearnBlock.Cursor.prototype.next = function () {
    var a = this.getCurNode();
    if (!a) return null;
    for (a = a.next(); a && a.next() && (a.getType() == LearnBlock.ASTNode.types.NEXT || a.getType() == LearnBlock.ASTNode.types.BLOCK);) a = a.next();
    a && this.setCurNode(a);
    return a
};
//Finds the in connection or field
LearnBlock.Cursor.prototype["in"] = function () {
    var a = this.getCurNode();
    if (!a) return null;
    if (a.getType() == LearnBlock.ASTNode.types.PREVIOUS || a.getType() == LearnBlock.ASTNode.types.OUTPUT) a = a.next();
    (a = a["in"]()) && this.setCurNode(a);
    return a
};
//Finds the previous connection, field, or block
LearnBlock.Cursor.prototype.prev = function () {
    var a = this.getCurNode();
    if (!a) return null;
    for (a = a.prev(); a && a.prev() && (a.getType() == LearnBlock.ASTNode.types.NEXT || a.getType() == LearnBlock.ASTNode.types.BLOCK);) a = a.prev();
    a && this.setCurNode(a);
    return a
};
//Finds the out connection, field, or block
LearnBlock.Cursor.prototype.out = function () {
    var a = this.getCurNode();
    if (!a) return null;
    (a = a.out()) && a.getType() == LearnBlock.ASTNode.types.BLOCK && (a = a.prev() || a);
    a && this.setCurNode(a);
    return a
};

//Class for a marker
LearnBlock.MarkerCursor = function () {
    LearnBlock.MarkerCursor.superClass_.constructor.call(this)
};
LearnBlock.utils.object.inherits(LearnBlock.MarkerCursor, LearnBlock.Cursor);
//No-ops: Markers don't move
LearnBlock.MarkerCursor.prototype.next = function () {
    return null
};
LearnBlock.MarkerCursor.prototype["in"] = function () {
    return null
};
LearnBlock.MarkerCursor.prototype.prev = function () {
    return null
};
LearnBlock.MarkerCursor.prototype.out = function () {
    return null
};


//Class for a theme
LearnBlock.Theme = function (a, b, c) {
    this.blockStyles_ = a;
    this.categoryStyles_ = b;
    this.componentStyles_ = c || Object.create(null)
};
//Overrides or adds all values from blockStyles to blockStyles_
LearnBlock.Theme.prototype.setAllBlockStyles = function (a) {
    for (var b in a) this.setBlockStyle(b, a[b])
};
//Gets a map of all the block style names
LearnBlock.Theme.prototype.getAllBlockStyles = function () {
    return this.blockStyles_
};
//Gets the BlockStyle for the given block style name
LearnBlock.Theme.prototype.getBlockStyle = function (a) {
    return this.blockStyles_[a]
};
//Overrides or adds a style to the blockStyles map
LearnBlock.Theme.prototype.setBlockStyle = function (a, b) {
    this.blockStyles_[a] = b
};
//Gets the CategoryStyle for the given category style name
LearnBlock.Theme.prototype.getCategoryStyle = function (a) {
    return this.categoryStyles_[a]
};
//Overrides or adds a style to the categoryStyles map
LearnBlock.Theme.prototype.setCategoryStyle = function (a, b) {
    this.categoryStyles_[a] = b
};
//Gets the style for a given Blockly UI component
LearnBlock.Theme.prototype.getComponentStyle = function (a) {
    return (a = this.componentStyles_[a]) && "string" == typeof propertyValue && this.getComponentStyle(a) ? this.getComponentStyle(a) : a ? String(a) : null
};
//Configures a specific Blockly UI component with a style value
LearnBlock.Theme.prototype.setComponentStyle = function (a, b) {
    this.componentStyles_[a] = b
};
//Class for storing and updating a workspace's theme and UI components
LearnBlock.ThemeManager = function (a) {
    this.theme_ = a;
    this.subscribedWorkspaces_ = [];
    this.componentDB_ = Object.create(null)
};
//Gets the workspace theme
LearnBlock.ThemeManager.prototype.getTheme = function () {
    return this.theme_
};
//Sets the workspace theme, and refreshes the workspace and all components
LearnBlock.ThemeManager.prototype.setTheme = function (a) {
    if (this.theme_ !== a) {
        this.theme_ = a;
        a = 0;
        for (var b; b = this.subscribedWorkspaces_[a]; a++) b.refreshTheme();
        a = 0;
        b = Object.keys(this.componentDB_);
        for (var c; c = b[a]; a++)
            for (var d = 0, e; e = this.componentDB_[c][d]; d++) {
                var f = e.element;
                e = e.propertyName;
                var g = this.theme_ && this.theme_.getComponentStyle(c);
                f.style[e] = g || ""
            }
    }
};
//Subscribes a workspace to changes to the selected theme
LearnBlock.ThemeManager.prototype.subscribeWorkspace = function (a) {
    this.subscribedWorkspaces_.push(a)
};
//Unsubscribes a workspace to changes to the selected theme
LearnBlock.ThemeManager.prototype.unsubscribeWorkspace = function (a) {
    a = this.subscribedWorkspaces_.indexOf(a);
    if (0 > a) throw Error("Cannot unsubscribe a workspace that hasn't been subscribed.");
    this.subscribedWorkspaces_.splice(a, 1)
};
//Subscribes an element to changes to the selected theme
LearnBlock.ThemeManager.prototype.subscribe = function (a, b, c) {
    this.componentDB_[b] || (this.componentDB_[b] = []);
    this.componentDB_[b].push({
        element: a,
        propertyName: c
    });
    b = this.theme_ && this.theme_.getComponentStyle(b);
    a.style[c] = b || ""
};
//Unsubscribes an element to changes to the selected theme
LearnBlock.ThemeManager.prototype.unsubscribe = function (a) {
    if (a)
        for (var b = Object.keys(this.componentDB_), c = 0, d; d = b[c]; c++) {
            for (var e = this.componentDB_[d], f = e.length - 1; 0 <= f; f--) e[f].element === a && e.splice(f, 1);
            this.componentDB_[d].length || delete this.componentDB_[d]
        }
};
//Dispose of the theme manager
LearnBlock.ThemeManager.prototype.dispose = function () {
    this.componentDB_ = this.subscribedWorkspaces_ = this.theme_ = this.owner_ = null
};
LearnBlock.Themes = {};
//Classic theme
LearnBlock.Themes.Classic = {};
//Default styles for variables and procedures blocks
LearnBlock.Themes.Classic.defaultBlockStyles = {
    procedure_blocks: {
        colourPrimary: "290"
    },
    variable_dynamic_blocks: {
        colourPrimary: "310"
    }
};
LearnBlock.Themes.Classic = new LearnBlock.Theme(LearnBlock.Themes.Classic.defaultBlockStyles);

//Class fpr a variable map: dictionary data structure with variable types and lists of variables
LearnBlock.VariableMap = function (a) {
    this.variableMap_ = Object.create(null);
    this.workspace = a
};
//Clears the variable map
LearnBlock.VariableMap.prototype.clear = function () {
    this.variableMap_ = Object.create(null)
};
//Renames the given variable by updating its name in the variable map
LearnBlock.VariableMap.prototype.renameVariable = function (a, b) {
    var c = this.getVariable(b, a.type),
        d = this.workspace.getAllBlocks(!1);
    LearnBlock.Events.setGroup(!0);
    try {
        c && c.getId() != a.getId() ? this.renameVariableWithConflict_(a, b, c, d) : this.renameVariableAndUses_(a, b, d)
    } finally {
        LearnBlock.Events.setGroup(!1)
    }
};
//Renames a variable, identified by the ID, by updating its name in the variable map
LearnBlock.VariableMap.prototype.renameVariableById = function (a, b) {
    var c = this.getVariableById(a);
    if (!c) throw Error("Tried to rename a variable that didn't exist. ID: " + a);
    this.renameVariable(c, b)
};
//Updates the name of the given variable and refreshes all references to it
LearnBlock.VariableMap.prototype.renameVariableAndUses_ = function (a, b, c) {
    LearnBlock.Events.fire(new LearnBlock.Events.VarRename(a, b));
    a.name = b;
    for (b = 0; b < c.length; b++) c[b].updateVarName(a)
};
//Updates the name of the given variable to the same name as an existing variable
LearnBlock.VariableMap.prototype.renameVariableWithConflict_ = function (a, b, c, d) {
    var e = a.type;
    b != c.name && this.renameVariableAndUses_(c, b, d);
    for (b = 0; b < d.length; b++) d[b].renameVarById(a.getId(), c.getId());
    LearnBlock.Events.fire(new LearnBlock.Events.VarDelete(a));
    a = this.getVariablesOfType(e).indexOf(a);
    this.variableMap_[e].splice(a, 1)
};
//Creates a variable with a given name, optional type, and optional ID
LearnBlock.VariableMap.prototype.createVariable = function (a, b, c) {
    var d = this.getVariable(a, b);
    if (d) {
        if (c && d.getId() != c) throw Error('Variable "' + a + '" is already in use and its id is "' + d.getId() + '" which conflicts with the passed in id, "' + c + '".');
        return d
    }
    if (c && this.getVariableById(c)) throw Error('Variable id, "' + c + '", is already in use.');
    d = c || LearnBlock.utils.genUid();
    b = b || "";
    d = new LearnBlock.VariableModel(this.workspace, a, b, d);
    a = this.variableMap_[b] || [];
    a.push(d);
    delete this.variableMap_[b];
    this.variableMap_[b] =
        a;
    return d
};
//Deletes a variable
LearnBlock.VariableMap.prototype.deleteVariable = function (a) {
    for (var b = this.variableMap_[a.type], c = 0, d; d = b[c]; c++)
        if (d.getId() == a.getId()) {
            b.splice(c, 1);
            LearnBlock.Events.fire(new LearnBlock.Events.VarDelete(a));
            break
        }
};
//Deletes a variable by the given ID
LearnBlock.VariableMap.prototype.deleteVariableById = function (a) {
    var b = this.getVariableById(a);
    if (b) {
        var c = b.name,
            d = this.getVariableUsesById(a);
        a = 0;
        for (var e; e = d[a]; a++)
            if ("procedures_defnoreturn" == e.type || "procedures_defreturn" == e.type) {
                a = e.getFieldValue("NAME");
                c = LearnBlock.Msg.CANNOT_DELETE_VARIABLE_PROCEDURE.replace("%1", c).replace("%2", a);
                LearnBlock.alert(c);
                return
            } var f = this;
        1 < d.length ? (c = LearnBlock.Msg.DELETE_VARIABLE_CONFIRMATION.replace("%1", String(d.length)).replace("%2", c), LearnBlock.confirm(c, function (a) {
            a &&
                f.deleteVariableInternal_(b, d)
        })) : f.deleteVariableInternal_(b, d)
    } else console.warn("Can't delete non-existent variable: " + a)
};
//Deletes a variable and all of its uses from this workspace without asking the user for confirmation
LearnBlock.VariableMap.prototype.deleteVariableInternal_ = function (a, b) {
    var c = LearnBlock.Events.getGroup();
    c || LearnBlock.Events.setGroup(!0);
    try {
        for (var d = 0; d < b.length; d++) b[d].dispose(!0, !1);
        this.deleteVariable(a)
    } finally {
        c || LearnBlock.Events.setGroup(!1)
    }
};
//Finds the variable by the given name and type and returns it
LearnBlock.VariableMap.prototype.getVariable = function (a, b) {
    var c = this.variableMap_[b || ""];
    if (c)
        for (var d = 0, e; e = c[d]; d++)
            if (LearnBlock.Names.equals(e.name, a)) return e;
    return null
};
//Finds the variable by the given ID and returns it
LearnBlock.VariableMap.prototype.getVariableById = function (a) {
    for (var b = Object.keys(this.variableMap_), c = 0; c < b.length; c++)
        for (var d = b[c], e = 0, f; f = this.variableMap_[d][e]; e++)
            if (f.getId() == a) return f;
    return null
};
//Gets a list containing all of the variables of a specified type
LearnBlock.VariableMap.prototype.getVariablesOfType = function (a) {
    return (a = this.variableMap_[a || ""]) ? a.slice() : []
};
//Returns all variable and potential variable types
LearnBlock.VariableMap.prototype.getVariableTypes = function (a) {
    var b = [];
    a && a.getPotentialVariableMap() && (b = Object.keys(a.getPotentialVariableMap().variableMap_));
    a = Object.keys(this.variableMap_).concat(b);
    b = !1;
    for (var c = 0; c < a.length; c++) "" == a[c] && (b = !0);
    b || a.push("");
    return a
};
//Returns all variables of all types
LearnBlock.VariableMap.prototype.getAllVariables = function () {
    var a = [],
        b;
    for (b in this.variableMap_) a = a.concat(this.variableMap_[b]);
    return a
};
//Finds all the uses of a named variable
LearnBlock.VariableMap.prototype.getVariableUsesById = function (a) {
    for (var b = [], c = this.workspace.getAllBlocks(!1), d = 0; d < c.length; d++) {
        var e = c[d].getVarModels();
        if (e)
            for (var f = 0; f < e.length; f++) e[f].getId() == a && b.push(c[d])
    }
    return b
};

//Class for a workspace
LearnBlock.Workspace = function (a) {
    this.id = LearnBlock.utils.genUid();
    LearnBlock.Workspace.WorkspaceDB_[this.id] = this;
    this.options = a || {};
    this.RTL = !!this.options.RTL;
    this.horizontalLayout = !!this.options.horizontalLayout;
    this.toolboxPosition = this.options.toolboxPosition;
    this.topBlocks_ = [];
    this.topComments_ = [];
    this.commentDB_ = Object.create(null);
    this.listeners_ = [];
    this.undoStack_ = [];
    this.redoStack_ = [];
    this.blockDB_ = Object.create(null);
    this.typedBlocksDB_ = Object.create(null);
    this.variableMap_ = new LearnBlock.VariableMap(this);
    this.potentialVariableMap_ = null;
    this.cursor_ = new LearnBlock.Cursor;
    this.marker_ = new LearnBlock.MarkerCursor;
    this.themeManager_ = this.options.parentWorkspace ? this.options.parentWorkspace.getThemeManager() : new LearnBlock.ThemeManager(this.options.theme || LearnBlock.Themes.Classic);
    this.themeManager_.subscribeWorkspace(this)
};
//Returns if the workspace is visible
LearnBlock.Workspace.prototype.rendered = !1;
//Returns if the workspace is currently in a clear process
LearnBlock.Workspace.prototype.isClearing = !1;
//Max of undo events
LearnBlock.Workspace.prototype.MAX_UNDO = 1024;
//DBs list
LearnBlock.Workspace.prototype.connectionDBList = null;
//Sets the cursor for keyboard navigation
LearnBlock.Workspace.prototype.setCursor = function (a) {
    this.cursor_ = a
};
//Sets the marker for keyboard navigation
LearnBlock.Workspace.prototype.setMarker = function (a) {
    this.marker_ = a
};
//Gets the cursor for keyboard navigation
LearnBlock.Workspace.prototype.getCursor = function () {
    return this.cursor_
};
//Gets the marker for keyboard navigation
LearnBlock.Workspace.prototype.getMarker = function () {
    return this.marker_
};
//Gets the workspace theme
LearnBlock.Workspace.prototype.getTheme = function () {
    return this.themeManager_.getTheme()
};
//Sets the workspace theme
LearnBlock.Workspace.prototype.setTheme = function (a) {
    a || (a = LearnBlock.Themes.Classic);
    this.themeManager_.setTheme(a)
};
//Refreshes all blocks on the workspace after a theme update
LearnBlock.Workspace.prototype.refreshTheme = function () {
    this.updateBlockStyles_(this.getAllBlocks().filter(function (a) {
        return void 0 !== a.getStyleName()
    }));
    var a = new LearnBlock.Events.Ui(null, "theme", null, null);
    a.workspaceId = this.id;
    LearnBlock.Events.fire(a)
};
//Updates all the blocks with a new style
LearnBlock.Workspace.prototype.updateBlockStyles_ = function (a) {
    for (var b = 0, c; c = a[b]; b++) {
        var d = c.getStyleName();
        c.setStyle(d);
        c.mutator && c.mutator.updateBlockStyle(d)
    }
};
//Dispose of the workspace
LearnBlock.Workspace.prototype.dispose = function () {
    this.listeners_.length = 0;
    this.clear();
    delete LearnBlock.Workspace.WorkspaceDB_[this.id];
    this.themeManager_ && (this.themeManager_.unsubscribeWorkspace(this), this.themeManager_.unsubscribe(this.svgBackground_), this.options.parentWorkspace || (this.themeManager_.dispose(), this.themeManager_ = null))
};
LearnBlock.Workspace.SCAN_ANGLE = 3;
//Compare function for sorting objects
LearnBlock.Workspace.prototype.sortObjects_ = function (a, b) {
    var c = a.getRelativeToSurfaceXY(),
        d = b.getRelativeToSurfaceXY();
    return c.y + LearnBlock.Workspace.prototype.sortObjects_.offset * c.x - (d.y + LearnBlock.Workspace.prototype.sortObjects_.offset * d.x)
};
//Adds a block to the list of top blocks
LearnBlock.Workspace.prototype.addTopBlock = function (a) {
    this.topBlocks_.push(a)
};
//Removes a block from the list of top blocks
LearnBlock.Workspace.prototype.removeTopBlock = function (a) {
    if (!LearnBlock.utils.arrayRemove(this.topBlocks_, a)) throw Error("Block not present in workspace's list of top-most blocks.");
};
//Returns the top-level blocks
LearnBlock.Workspace.prototype.getTopBlocks = function (a) {
    var b = [].concat(this.topBlocks_);
    a && 1 < b.length && (this.sortObjects_.offset = Math.sin(LearnBlock.utils.math.toRadians(LearnBlock.Workspace.SCAN_ANGLE)), this.RTL && (this.sortObjects_.offset *= -1), b.sort(this.sortObjects_));
    return b
};
//Adds a block to the list of blocks keyed by type
LearnBlock.Workspace.prototype.addTypedBlock = function (a) {
    this.typedBlocksDB_[a.type] || (this.typedBlocksDB_[a.type] = []);
    this.typedBlocksDB_[a.type].push(a)
};
//Removes a block to the list of blocks keyed by type
LearnBlock.Workspace.prototype.removeTypedBlock = function (a) {
    this.typedBlocksDB_[a.type].splice(this.typedBlocksDB_[a.type].indexOf(a), 1);
    this.typedBlocksDB_[a.type].length || delete this.typedBlocksDB_[a.type]
};
//Returns the blocks with the associated type
LearnBlock.Workspace.prototype.getBlocksByType = function (a, b) {
    if (!this.typedBlocksDB_[a]) return [];
    var c = this.typedBlocksDB_[a].slice(0);
    b && 1 < c.length && (this.sortObjects_.offset = Math.sin(LearnBlock.utils.math.toRadians(LearnBlock.Workspace.SCAN_ANGLE)), this.RTL && (this.sortObjects_.offset *= -1), c.sort(this.sortObjects_));
    return c
};
//Finds all blocks in workspace
LearnBlock.Workspace.prototype.getAllBlocks = function (a) {
    if (a) {
        a = this.getTopBlocks(!0);
        for (var b = [], c = 0; c < a.length; c++) b.push.apply(b, a[c].getDescendants(!0))
    } else
        for (b = this.getTopBlocks(!1), c = 0; c < b.length; c++) b.push.apply(b, b[c].getChildren(!1));
    return b.filter(function (a) {
        return !a.isInsertionMarker()
    })
};
//Dispose of all blocks and comments in workspace
LearnBlock.Workspace.prototype.clear = function () {
    this.isClearing = !0;
    try {
        var a = LearnBlock.Events.getGroup();
        for (a || LearnBlock.Events.setGroup(!0); this.topBlocks_.length;) this.topBlocks_[0].dispose();
        a || LearnBlock.Events.setGroup(!1);
        this.variableMap_.clear();
        this.potentialVariableMap_ && this.potentialVariableMap_.clear()
    } finally {
        this.isClearing = !1
    }
};
//Pass-throughs to the variable map functions
LearnBlock.Workspace.prototype.renameVariableById = function (a, b) {
    this.variableMap_.renameVariableById(a, b)
};
LearnBlock.Workspace.prototype.createVariable = function (a, b, c) {
    return this.variableMap_.createVariable(a, b, c)
};
LearnBlock.Workspace.prototype.getVariableUsesById = function (a) {
    return this.variableMap_.getVariableUsesById(a)
};
LearnBlock.Workspace.prototype.deleteVariableById = function (a) {
    this.variableMap_.deleteVariableById(a)
};
LearnBlock.Workspace.prototype.deleteVariableInternal_ = function (a, b) {
    this.variableMap_.deleteVariableInternal_(a, b)
};
LearnBlock.Workspace.prototype.variableIndexOf = function (a) {
    console.warn("Deprecated call to LearnBlock.Workspace.prototype.variableIndexOf");
    return -1
};
LearnBlock.Workspace.prototype.getVariable = function (a, b) {
    return this.variableMap_.getVariable(a, b)
};
LearnBlock.Workspace.prototype.getVariableById = function (a) {
    return this.variableMap_.getVariableById(a)
};
LearnBlock.Workspace.prototype.getVariablesOfType = function (a) {
    return this.variableMap_.getVariablesOfType(a)
};
LearnBlock.Workspace.prototype.getVariableTypes = function () {
    return this.variableMap_.getVariableTypes(this)
};
LearnBlock.Workspace.prototype.getAllVariables = function () {
    return this.variableMap_.getAllVariables()
};
LearnBlock.Workspace.prototype.getWidth = function () {
    return 0
};
LearnBlock.Workspace.prototype.newBlock = function (a, b) {
    return new LearnBlock.Block(this, a, b)
};
//Number of blocks that may be added to the workspace before reaching the maxBlocks
LearnBlock.Workspace.prototype.remainingCapacity = function () {
    return isNaN(this.options.maxBlocks) ? Infinity : this.options.maxBlocks - this.getAllBlocks().length
};
//Number of blocks of a given type that may be added to the workspace before reaching the maxInstances allowed for that type
LearnBlock.Workspace.prototype.remainingCapacityOfType = function (a) {
    return this.options.maxInstances ? (this.options.maxInstances[a] || Infinity) - this.getBlocksByType(a).length : Infinity
};
//Checks if there's remaining capacity for blocks
LearnBlock.Workspace.prototype.isCapacityAvailable = function (a) {
    if (!this.hasBlockLimits()) return !0;
    var b = 0,
        c;
    for (c in a) {
        if (a[c] > this.remainingCapacityOfType(c)) return !1;
        b += a[c]
    }
    return b > this.remainingCapacity() ? !1 : !0
};
//Checks if the workspace has any limits on the maximum number of blocks or block types
LearnBlock.Workspace.prototype.hasBlockLimits = function () {
    return Infinity != this.options.maxBlocks || !!this.options.maxInstances
};
//Undo or redo the previous action
LearnBlock.Workspace.prototype.undo = function (a) {
    var b = a ? this.redoStack_ : this.undoStack_,
        c = a ? this.undoStack_ : this.redoStack_,
        d = b.pop();
    if (d) {
        for (var e = [d]; b.length && d.group && d.group == b[b.length - 1].group;) e.push(b.pop());
        for (b = 0; d = e[b]; b++) c.push(d);
        e = LearnBlock.Events.filter(e, a);
        LearnBlock.Events.recordUndo = !1;
        try {
            for (b = 0; d = e[b]; b++) d.run(a)
        } finally {
            LearnBlock.Events.recordUndo = !0
        }
    }
};
//Clears the undo/redo stacks
LearnBlock.Workspace.prototype.clearUndo = function () {
    this.undoStack_.length = 0;
    this.redoStack_.length = 0;
    LearnBlock.Events.clearPendingUndo()
};
//Creates a change listener function when something in the workspace changes
LearnBlock.Workspace.prototype.addChangeListener = function (a) {
    this.listeners_.push(a);
    return a
};
//Removes the listener
LearnBlock.Workspace.prototype.removeChangeListener = function (a) {
    LearnBlock.utils.arrayRemove(this.listeners_, a)
};
//Fires a change event
LearnBlock.Workspace.prototype.fireChangeListener = function (a) {
    if (a.recordUndo)
        for (this.undoStack_.push(a), this.redoStack_.length = 0; this.undoStack_.length > this.MAX_UNDO && 0 <= this.MAX_UNDO;) this.undoStack_.shift();
    for (var b = 0, c; c = this.listeners_[b]; b++) c(a)
};
//Finds the block with the specified ID
LearnBlock.Workspace.prototype.getBlockById = function (a) {
    return this.blockDB_[a] || null
};
//Checks whether all value and statement inputs in the workspace are filled with blocks
LearnBlock.Workspace.prototype.allInputsFilled = function (a) {
    for (var b = this.getTopBlocks(!1), c = 0, d; d = b[c]; c++)
        if (!d.allInputsFilled(a)) return !1;
    return !0
};
//Returns the variable map that contains "potential" variables
LearnBlock.Workspace.prototype.getPotentialVariableMap = function () {
    return this.potentialVariableMap_
};
//Creates and stores the potential variable map for this workspace
LearnBlock.Workspace.prototype.createPotentialVariableMap = function () {
    this.potentialVariableMap_ = new LearnBlock.VariableMap(this)
};
//Returns the map of all variables on the workspace
LearnBlock.Workspace.prototype.getVariableMap = function () {
    return this.variableMap_
};
//Database of all workspaces
LearnBlock.Workspace.WorkspaceDB_ = Object.create(null);
//Finds the workspace with the specified ID
LearnBlock.Workspace.getById = function (a) {
    return LearnBlock.Workspace.WorkspaceDB_[a] || null
};
//Finds all workspaces
LearnBlock.Workspace.getAll = function () {
    var a = [],
        b;
    for (b in LearnBlock.Workspace.WorkspaceDB_) a.push(LearnBlock.Workspace.WorkspaceDB_[b]);
    return a
};
//Gets the theme manager for the workspace
LearnBlock.Workspace.prototype.getThemeManager = function () {
    return this.themeManager_
};

//LearnBlock constants
LearnBlock.constants = {};
LearnBlock.LINE_MODE_MULTIPLIER = 40;
LearnBlock.PAGE_MODE_MULTIPLIER = 125;
LearnBlock.DRAG_RADIUS = 5;
LearnBlock.FLYOUT_DRAG_RADIUS = 10;
LearnBlock.SNAP_RADIUS = 28;
LearnBlock.CONNECTING_SNAP_RADIUS = LearnBlock.SNAP_RADIUS;
LearnBlock.CURRENT_CONNECTION_PREFERENCE = 8;
LearnBlock.INSERTION_MARKER_COLOUR = "#000000";
LearnBlock.BUMP_DELAY = 250;
LearnBlock.BUMP_RANDOMNESS = 10;
LearnBlock.COLLAPSE_CHARS = 30;
LearnBlock.LONGPRESS = 750;
LearnBlock.SOUND_LIMIT = 100;
LearnBlock.DRAG_STACK = !0;
LearnBlock.HSV_SATURATION = .45;
LearnBlock.HSV_VALUE = .65;
LearnBlock.SPRITE = {
    width: 96,
    height: 124,
    url: "sprites.png"
};
LearnBlock.INPUT_VALUE = 1;
LearnBlock.OUTPUT_VALUE = 2;
LearnBlock.NEXT_STATEMENT = 3;
LearnBlock.PREVIOUS_STATEMENT = 4;
LearnBlock.DUMMY_INPUT = 5;
LearnBlock.ALIGN_LEFT = -1;
LearnBlock.ALIGN_CENTRE = 0;
LearnBlock.ALIGN_RIGHT = 1;
LearnBlock.DRAG_NONE = 0;
LearnBlock.DRAG_STICKY = 1;
LearnBlock.DRAG_BEGIN = 1;
LearnBlock.DRAG_FREE = 2;
LearnBlock.OPPOSITE_TYPE = [];
LearnBlock.OPPOSITE_TYPE[LearnBlock.INPUT_VALUE] = LearnBlock.OUTPUT_VALUE;
LearnBlock.OPPOSITE_TYPE[LearnBlock.OUTPUT_VALUE] = LearnBlock.INPUT_VALUE;
LearnBlock.OPPOSITE_TYPE[LearnBlock.NEXT_STATEMENT] = LearnBlock.PREVIOUS_STATEMENT;
LearnBlock.OPPOSITE_TYPE[LearnBlock.PREVIOUS_STATEMENT] = LearnBlock.NEXT_STATEMENT;
LearnBlock.TOOLBOX_AT_TOP = 0;
LearnBlock.TOOLBOX_AT_BOTTOM = 1;
LearnBlock.TOOLBOX_AT_LEFT = 2;
LearnBlock.TOOLBOX_AT_RIGHT = 3;
LearnBlock.DELETE_AREA_NONE = null;
LearnBlock.DELETE_AREA_TRASH = 1;
LearnBlock.DELETE_AREA_TOOLBOX = 2;
LearnBlock.VARIABLE_CATEGORY_NAME = "VARIABLE";
LearnBlock.VARIABLE_DYNAMIC_CATEGORY_NAME = "VARIABLE_DYNAMIC";
LearnBlock.PROCEDURE_CATEGORY_NAME = "PROCEDURE";
LearnBlock.RENAME_VARIABLE_ID = "RENAME_VARIABLE_ID";
LearnBlock.DELETE_VARIABLE_ID = "DELETE_VARIABLE_ID";

//Class for a UI event
LearnBlock.Events.Ui = function (a, b, c, d) {
    LearnBlock.Events.Ui.superClass_.constructor.call(this);
    this.blockId = a ? a.id : null;
    this.workspaceId = a ? a.workspace.id : void 0;
    this.element = b;
    this.oldValue = c;
    this.newValue = d;
    this.recordUndo = !1
};
LearnBlock.utils.object.inherits(LearnBlock.Events.Ui, LearnBlock.Events.Abstract);
//Type of tge event
LearnBlock.Events.Ui.prototype.type = LearnBlock.Events.UI;
//Encodes the event as JSON
LearnBlock.Events.Ui.prototype.toJson = function () {
    var a = LearnBlock.Events.Ui.superClass_.toJson.call(this);
    a.element = this.element;
    void 0 !== this.newValue && (a.newValue = this.newValue);
    this.blockId && (a.blockId = this.blockId);
    return a
};
//Decodes the JSON event
LearnBlock.Events.Ui.prototype.fromJson = function (a) {
    LearnBlock.Events.Ui.superClass_.fromJson.call(this, a);
    this.element = a.element;
    this.newValue = a.newValue;
    this.blockId = a.blockId
};

//Class that moves the workspace around when being dragged by mouse
LearnBlock.WorkspaceDragger = function (a) {
    this.workspace_ = a;
    this.startScrollXY_ = new LearnBlock.utils.Coordinate(a.scrollX, a.scrollY)
};
//Severs all links from this object
LearnBlock.WorkspaceDragger.prototype.dispose = function () {
    this.workspace_ = null
};
//Starts dragging the workspace
LearnBlock.WorkspaceDragger.prototype.startDrag = function () {
    LearnBlock.selected && LearnBlock.selected.unselect();
    this.workspace_.setupDragSurface()
};
//Finishes dragging the workspace and puts everything back where it belongs
LearnBlock.WorkspaceDragger.prototype.endDrag = function (a) {
    this.drag(a);
    this.workspace_.resetDragSurface()
};
//Moves the workspace based on the most recent mouse movements
LearnBlock.WorkspaceDragger.prototype.drag = function (a) {
    a = LearnBlock.utils.Coordinate.sum(this.startScrollXY_, a);
    this.workspace_.scroll(a.x, a.y)
};

//Class for one gesture
LearnBlock.Gesture = function (a, b) {
    this.startWorkspace_ = this.targetBlock_ = this.startBlock_ = this.startField_ = this.startBubble_ = this.currentDragDeltaXY_ = this.mouseDownXY_ = null;
    this.creatorWorkspace_ = b;
    this.isDraggingBubble_ = this.isDraggingBlock_ = this.isDraggingWorkspace_ = this.hasExceededDragRadius_ = !1;
    this.mostRecentEvent_ = a;
    this.flyout_ = this.workspaceDragger_ = this.blockDragger_ = this.bubbleDragger_ = this.onUpWrapper_ = this.onMoveWrapper_ = null;
    this.isEnding_ = this.hasStarted_ = this.calledUpdateIsDragging_ = !1;
    this.healStack_ = !LearnBlock.DRAG_STACK
};
//Severs all links from this object
LearnBlock.Gesture.prototype.dispose = function () {
    LearnBlock.Touch.clearTouchIdentifier();
    this.creatorWorkspace_.clearGesture();
    this.onMoveWrapper_ && LearnBlock.unbindEvent_(this.onMoveWrapper_);
    this.onUpWrapper_ && LearnBlock.unbindEvent_(this.onUpWrapper_);
    this.flyout_ = this.startWorkspace_ = this.targetBlock_ = this.startBlock_ = this.startField_ = null;
    this.blockDragger_ && (this.blockDragger_.dispose(), this.blockDragger_ = null);
    this.workspaceDragger_ && (this.workspaceDragger_.dispose(), this.workspaceDragger_ =
        null);
    this.bubbleDragger_ && (this.bubbleDragger_.dispose(), this.bubbleDragger_ = null)
};
//Updates internal state based on an event
LearnBlock.Gesture.prototype.updateFromEvent_ = function (a) {
    var b = new LearnBlock.utils.Coordinate(a.clientX, a.clientY);
    this.updateDragDelta_(b) && (this.updateIsDragging_(), LearnBlock.longStop_());
    this.mostRecentEvent_ = a
};
//DO MATH to set currentDragDeltaXY_ based on the most recent mouse position
LearnBlock.Gesture.prototype.updateDragDelta_ = function (a) {
    this.currentDragDeltaXY_ = LearnBlock.utils.Coordinate.difference(a, this.mouseDownXY_);
    return this.hasExceededDragRadius_ ? !1 : this.hasExceededDragRadius_ = LearnBlock.utils.Coordinate.magnitude(this.currentDragDeltaXY_) > (this.flyout_ ? LearnBlock.FLYOUT_DRAG_RADIUS : LearnBlock.DRAG_RADIUS)
};
//Updates the gesture to record whether a block is being dragged from the flyout
LearnBlock.Gesture.prototype.updateIsDraggingFromFlyout_ = function () {
    return this.flyout_.isBlockCreatable_(this.targetBlock_) ? !this.flyout_.isScrollable() || this.flyout_.isDragTowardWorkspace(this.currentDragDeltaXY_) ? (this.startWorkspace_ = this.flyout_.targetWorkspace_, this.startWorkspace_.updateScreenCalculationsIfScrolled(), LearnBlock.Events.getGroup() || LearnBlock.Events.setGroup(!0), this.startBlock_ = null, this.targetBlock_ = this.flyout_.createBlock(this.targetBlock_), this.targetBlock_.select(), !0) : !1 : !1
};
//Updates the gesture to record whether a block is being dragged
LearnBlock.Gesture.prototype.updateIsDraggingBlock_ = function () {
    if (!this.targetBlock_) return !1;
    this.flyout_ ? this.isDraggingBlock_ = this.updateIsDraggingFromFlyout_() : this.targetBlock_.isMovable() && (this.isDraggingBlock_ = !0);
    return this.isDraggingBlock_ ? (this.startDraggingBlock_(), !0) : !1
};
//Updates the gesture to record whether a workspace is being dragged
LearnBlock.Gesture.prototype.updateIsDraggingWorkspace_ = function () {
    var wsMovable = this.startWorkspace_ && this.startWorkspace_.isDraggable();
    if (!wsMovable) {
        return;
    }
    if (!this.flyout_) {
        this.workspaceDragger_ = new LearnBlock.WorkspaceDragger(this.startWorkspace_);
    }
    this.isDraggingWorkspace_ = true;
    this.workspaceDragger_.startDrag();
};
//Updates the gesture to record whether anything is being dragged
LearnBlock.Gesture.prototype.updateIsDragging_ = function () {
    if (this.calledUpdateIsDragging_) throw Error("updateIsDragging_ should only be called once per gesture.");
    this.calledUpdateIsDragging_ = !0;
    this.updateIsDraggingBlock_() || this.updateIsDraggingWorkspace_()
};
//Creates a block dragger and starts dragging the selected block
LearnBlock.Gesture.prototype.startDraggingBlock_ = function () {
    this.blockDragger_ = new LearnBlock.BlockDragger(this.targetBlock_, this.startWorkspace_);
    this.blockDragger_.startBlockDrag(this.currentDragDeltaXY_, this.healStack_);
    this.blockDragger_.dragBlock(this.mostRecentEvent_, this.currentDragDeltaXY_)
};
//Starts a gesture
LearnBlock.Gesture.prototype.doStart = function (a) {
    LearnBlock.utils.isTargetInput(a) ? this.cancel() : (this.hasStarted_ = !0, this.startWorkspace_.updateScreenCalculationsIfScrolled(), this.startWorkspace_.isMutator && this.startWorkspace_.resize(), this.startWorkspace_.markFocused(), this.mostRecentEvent_ = a, LearnBlock.hideChaff(!!this.flyout_), this.targetBlock_ && (!this.targetBlock_.isInFlyout && a.shiftKey ? (LearnBlock.navigation.enableKeyboardAccessibility(),
        this.creatorWorkspace_.getCursor().setCurNode(LearnBlock.navigation.getTopNode(this.targetBlock_))) : this.targetBlock_.select()), LearnBlock.utils.isRightButton(a) ? this.handleRightClick(a) : ("touchstart" != a.type.toLowerCase() && "pointerdown" != a.type.toLowerCase() || "mouse" == a.pointerType || LearnBlock.longStart_(a, this), this.mouseDownXY_ = new LearnBlock.utils.Coordinate(a.clientX, a.clientY), this.healStack_ = a.altKey || a.ctrlKey || a.metaKey, this.bindMouseEvents(a)))
};
//Binds gesture events
LearnBlock.Gesture.prototype.bindMouseEvents = function (a) {
    this.onMoveWrapper_ = LearnBlock.bindEventWithChecks_(document, "mousemove", null, this.handleMove.bind(this));
    this.onUpWrapper_ = LearnBlock.bindEventWithChecks_(document, "mouseup", null, this.handleUp.bind(this));
    a.preventDefault();
    a.stopPropagation()
};
//Handles a mouse move event
LearnBlock.Gesture.prototype.handleMove = function (e) {
    this.updateFromEvent_(e);
    if (this.isDraggingWorkspace_) {
        this.workspaceDragger_.drag(this.currentDragDeltaXY_);
    } else if (this.isDraggingBlock_) {
        this.blockDragger_.dragBlock(this.mostRecentEvent_,
            this.currentDragDeltaXY_);
    }
    e.preventDefault();
    e.stopPropagation();
};
//Handles a mouse up event
LearnBlock.Gesture.prototype.handleUp = function (e) {
    this.updateFromEvent_(e);
    LearnBlock.longStop_();
    if (this.isEnding_) {
        console.log('Trying to end a gesture recursively.');
        return;
    }
    this.isEnding_ = true;
    if (this.isDraggingBubble_) {
        this.bubbleDragger_.endBubbleDrag(e, this.currentDragDeltaXY_);
    } else if (this.isDraggingBlock_) {
        this.blockDragger_.endBlockDrag(e, this.currentDragDeltaXY_);
    } else if (this.isDraggingWorkspace_) {
        this.workspaceDragger_.endDrag(this.currentDragDeltaXY_);
    } else if (this.isFieldClick_()) {
        this.doFieldClick_();
    } else if (this.isBlockClick_()) {
        this.doBlockClick_();
    } else if (this.isWorkspaceClick_()) {
        this.doWorkspaceClick_(e);
    }
    e.preventDefault();
    e.stopPropagation();
    this.dispose();
};
//Cancels an in-progress gesture
LearnBlock.Gesture.prototype.cancel = function () {
    this.isEnding_ || (LearnBlock.longStop_(), this.isDraggingBubble_ ? this.bubbleDragger_.endBubbleDrag(this.mostRecentEvent_, this.currentDragDeltaXY_) : this.isDraggingBlock_ ? this.blockDragger_.endBlockDrag(this.mostRecentEvent_, this.currentDragDeltaXY_) : this.isDraggingWorkspace_ && this.workspaceDragger_.endDrag(this.currentDragDeltaXY_), this.dispose())
};
//Handles a real or faked right-click event by showing a context menu
LearnBlock.Gesture.prototype.handleRightClick = function (a) {
    this.targetBlock_ ? (this.bringBlockToFront_(), LearnBlock.hideChaff(this.flyout_), this.targetBlock_.showContextMenu_(a)) : this.startBubble_ ? this.startBubble_.showContextMenu_(a) : this.startWorkspace_ && !this.flyout_ && (LearnBlock.hideChaff(), this.startWorkspace_.showContextMenu_(a));
    a.preventDefault();
    a.stopPropagation();
    this.dispose()
};
//Handles a mousedown event on a workspace
LearnBlock.Gesture.prototype.handleWsStart = function (a, b) {
    if (this.hasStarted_) throw Error("Tried to call gesture.handleWsStart, but the gesture had already been started.");
    this.setStartWorkspace_(b);
    this.mostRecentEvent_ = a;
    this.doStart(a);
    LearnBlock.keyboardAccessibilityMode && LearnBlock.navigation.setState(LearnBlock.navigation.STATE_WS)
};
//Handles a mousedown event on a flyout
LearnBlock.Gesture.prototype.handleFlyoutStart = function (a, b) {
    if (this.hasStarted_) throw Error("Tried to call gesture.handleFlyoutStart, but the gesture had already been started.");
    this.setStartFlyout_(b);
    this.handleWsStart(a, b.getWorkspace())
};
//Handles a mousedown event on a block
LearnBlock.Gesture.prototype.handleBlockStart = function (a, b) {
    if (this.hasStarted_) throw Error("Tried to call gesture.handleBlockStart, but the gesture had already been started.");
    this.setStartBlock(b);
    this.mostRecentEvent_ = a
};
//Executes a field click
LearnBlock.Gesture.prototype.doFieldClick_ = function () {
    this.startField_.showEditor_();
    this.bringBlockToFront_()
};
//Executes a block click.
LearnBlock.Gesture.prototype.doBlockClick_ = function () {
    this.flyout_ && this.flyout_.autoClose ? this.targetBlock_.isEnabled() && (LearnBlock.Events.getGroup() || LearnBlock.Events.setGroup(!0), this.flyout_.createBlock(this.targetBlock_).scheduleSnapAndBump()) : LearnBlock.Events.fire(new LearnBlock.Events.Ui(this.startBlock_, "click", void 0, void 0));
    this.bringBlockToFront_();
    LearnBlock.Events.setGroup(!1)
};
//Executes a workspace click
LearnBlock.Gesture.prototype.doWorkspaceClick_ = function (a) {
    var b = this.creatorWorkspace_;
    a.shiftKey ? (LearnBlock.navigation.enableKeyboardAccessibility(), a = new LearnBlock.utils.Coordinate(a.clientX, a.clientY), a = LearnBlock.utils.screenToWsCoordinates(b, a), a = LearnBlock.ASTNode.createWorkspaceNode(b, a), b.getCursor().setCurNode(a)) : LearnBlock.selected && LearnBlock.selected.unselect()
};
//Moves the dragged/clicked block to the front of the workspace
LearnBlock.Gesture.prototype.bringBlockToFront_ = function () {
    this.targetBlock_ && !this.flyout_ && this.targetBlock_.bringToFront()
};
//Records the field that a gesture started on
LearnBlock.Gesture.prototype.setStartField = function (a) {
    if (this.hasStarted_) throw Error("Tried to call gesture.setStartField, but the gesture had already been started.");
    this.startField_ || (this.startField_ = a)
};
//Records the block that a gesture started on
LearnBlock.Gesture.prototype.setStartBlock = function (a) {
    this.startBlock_ || this.startBubble_ || (this.startBlock_ = a, a.isInFlyout && a != a.getRootBlock() ? this.setTargetBlock_(a.getRootBlock()) : this.setTargetBlock_(a))
};
//Records the block that a gesture targets
LearnBlock.Gesture.prototype.setTargetBlock_ = function (a) {
    this.targetBlock_ = a
};
//Records the workspace that a gesture started on
LearnBlock.Gesture.prototype.setStartWorkspace_ = function (a) {
    this.startWorkspace_ || (this.startWorkspace_ = a)
};
//Records the flyout that a gesture started on
LearnBlock.Gesture.prototype.setStartFlyout_ = function (a) {
    this.flyout_ || (this.flyout_ = a)
};
//Whether the gesture is a click on a block
LearnBlock.Gesture.prototype.isBlockClick_ = function () {
    return !!this.startBlock_ && !this.hasExceededDragRadius_ && !this.isFieldClick_()
};
//Whether the gesture is a click on a field
LearnBlock.Gesture.prototype.isFieldClick_ = function () {
    return (this.startField_ ? this.startField_.isClickable() : !1) && !this.hasExceededDragRadius_ && (!this.flyout_ || !this.flyout_.autoClose)
};
//Whether the gesture is a click on a workspace
LearnBlock.Gesture.prototype.isWorkspaceClick_ = function () {
    return !this.startBlock_ && !this.startBubble_ && !this.startField_ && !this.hasExceededDragRadius_
};
//Whether the gesture is a drag of either a workspace or block
LearnBlock.Gesture.prototype.isDragging = function () {
    return this.isDraggingWorkspace_ || this.isDraggingBlock_ || this.isDraggingBubble_
};
//Whether the gesture has already been started
LearnBlock.Gesture.prototype.hasStarted = function () {
    return this.hasStarted_
};
//Gets a list of the insertion markers that currently exist
LearnBlock.Gesture.prototype.getInsertionMarkers = function () {
    return this.blockDragger_ ? this.blockDragger_.getInsertionMarkers() : []
};
//Is a drag or other gesture currently in progress on any workspace?
LearnBlock.Gesture.inProgress = function () {
    for (var a = LearnBlock.Workspace.getAll(), b = 0, c; c = a[b]; b++)
        if (c.currentGesture_) return !0;
    return !1
};

//Class for an editable field
LearnBlock.Field = function (a, b, c) {
    this.tooltip_ = this.validator_ = this.value_ = null;
    this.size_ = new LearnBlock.utils.Size(0, 0);
    this.markerSvg_ = this.cursorSvg_ = null;
    c && this.configure_(c);
    this.setValue(a);
    b && this.setValidator(b)
};
LearnBlock.Field.BORDER_RECT_DEFAULT_HEIGHT = 16;
LearnBlock.Field.TEXT_DEFAULT_HEIGHT = 12.5;
LearnBlock.Field.X_PADDING = 10;
LearnBlock.Field.Y_PADDING = 10;
LearnBlock.Field.DEFAULT_TEXT_OFFSET = LearnBlock.Field.X_PADDING / 2;
LearnBlock.Field.prototype.name = void 0;
LearnBlock.Field.prototype.disposed = !1;
LearnBlock.Field.prototype.maxDisplayLength = 50;
LearnBlock.Field.prototype.sourceBlock_ = null;
LearnBlock.Field.prototype.isDirty_ = !0;
LearnBlock.Field.prototype.visible_ = !0;
LearnBlock.Field.prototype.clickTarget_ = null;
LearnBlock.Field.NBSP = "\u00a0";
LearnBlock.Field.prototype.EDITABLE = !0;
LearnBlock.Field.prototype.SERIALIZABLE = !1;
//Processes the configuration map passed to the field
LearnBlock.Field.prototype.configure_ = function (a) {
    var b = a.tooltip;
    "string" == typeof b && (b = LearnBlock.utils.replaceMessageReferences(a.tooltip));
    b && this.setTooltip(b)
};
//Attaches this field to a block
LearnBlock.Field.prototype.setSourceBlock = function (a) {
    if (this.sourceBlock_) throw Error("Field already bound to a block.");
    this.sourceBlock_ = a
};
//Gets the block this field is attached to
LearnBlock.Field.prototype.getSourceBlock = function () {
    return this.sourceBlock_
};
//Initializes everything to render the field
LearnBlock.Field.prototype.init = function () {
    this.fieldGroup_ || (this.fieldGroup_ = LearnBlock.utils.dom.createSvgElement("g", {}, null), this.isVisible() || (this.fieldGroup_.style.display = "none"), this.sourceBlock_.getSvgRoot().appendChild(this.fieldGroup_), this.initView(), this.updateEditable(), this.setTooltip(this.tooltip_), this.bindEvents_(), this.initModel())
};
//Creates the block UI for the field
LearnBlock.Field.prototype.initView = function () {
    this.createBorderRect_();
    this.createTextElement_()
};
//Initializes the model of the field after it has been installed on a block
LearnBlock.Field.prototype.initModel = function () {};
//Creates a field border rect element
LearnBlock.Field.prototype.createBorderRect_ = function () {
    this.size_.height = Math.max(this.size_.height, LearnBlock.Field.BORDER_RECT_DEFAULT_HEIGHT);
    this.size_.width = Math.max(this.size_.width, LearnBlock.Field.X_PADDING);
    this.borderRect_ = LearnBlock.utils.dom.createSvgElement("rect", {
        rx: 4,
        ry: 4,
        x: 0,
        y: 0,
        height: this.size_.height,
        width: this.size_.width
    }, this.fieldGroup_)
};
//Creates a field text element
LearnBlock.Field.prototype.createTextElement_ = function () {
    this.textElement_ = LearnBlock.utils.dom.createSvgElement("text", {
        "class": "blocklyText",
        y: LearnBlock.Field.TEXT_DEFAULT_HEIGHT,
        x: this.borderRect_ ? LearnBlock.Field.DEFAULT_TEXT_OFFSET : 0
    }, this.fieldGroup_);
    this.textContent_ = document.createTextNode("");
    this.textElement_.appendChild(this.textContent_)
};
//Binds events to the field
LearnBlock.Field.prototype.bindEvents_ = function () {
    this.mouseDownWrapper_ = LearnBlock.bindEventWithChecks_(this.getClickTarget_(), "mousedown", this, this.onMouseDown_)
};
//Sets the field's value based on the given XML element
LearnBlock.Field.prototype.fromXml = function (a) {
    this.setValue(a.textContent)
};
//Serializes the field's value to XML
LearnBlock.Field.prototype.toXml = function (a) {
    a.textContent = this.getValue();
    return a
};
//Disposes of all DOM objects and events belonging to the editable field
LearnBlock.Field.prototype.dispose = function () {
    LearnBlock.DropDownDiv.hideIfOwner(this);
    LearnBlock.WidgetDiv.hideIfOwner(this);
    this.mouseDownWrapper_ && LearnBlock.unbindEvent_(this.mouseDownWrapper_);
    LearnBlock.utils.dom.removeNode(this.fieldGroup_);
    this.disposed = !0
};
//Adds or removes the UI indicating if the field is editable or not
LearnBlock.Field.prototype.updateEditable = function () {
    var group = this.getClickTarget_();
    if (!this.EDITABLE || !group) {
        return;
    }
    if (this.sourceBlock_.isEditable()) {
        LearnBlock.utils.dom.addClass(group, 'blocklyEditableText');
        LearnBlock.utils.dom.removeClass(group, 'blocklyNonEditableText');
        group.style.cursor = this.CURSOR;
    }
};
//Checks whether the field defines the showEditor_ function
LearnBlock.Field.prototype.isClickable = function () {
    return !!this.sourceBlock_ && this.sourceBlock_.isEditable() && !!this.showEditor_ && "function" === typeof this.showEditor_
};
//Checks whether the field is currently editable
LearnBlock.Field.prototype.isCurrentlyEditable = function () {
    return this.EDITABLE && !!this.sourceBlock_ && this.sourceBlock_.isEditable()
};
//Checks whether the field should be serialized by the XML renderer
LearnBlock.Field.prototype.isSerializable = function () {
    var a = !1;
    this.name && (this.SERIALIZABLE ? a = !0 : this.EDITABLE && (console.warn("Detected an editable field that was not serializable. Please define SERIALIZABLE property as true on all editable custom fields. Proceeding with serialization."), a = !0));
    return a
};
//Gets whether the editable field is visible or not
LearnBlock.Field.prototype.isVisible = function () {
    return this.visible_
};
//Sets whether the editable field is visible or not
LearnBlock.Field.prototype.setVisible = function (a) {
    if (this.visible_ != a) {
        this.visible_ = a;
        var b = this.getSvgRoot();
        b && (b.style.display = a ? "block" : "none")
    }
};
//Sets a new validation function for editable fields, or clears a previously set validator.
LearnBlock.Field.prototype.setValidator = function (a) {
    this.validator_ = a
};
//Gets the validation function
LearnBlock.Field.prototype.getValidator = function () {
    return this.validator_
};
//Validates a change
LearnBlock.Field.prototype.classValidator = function (a) {
    return a
};
//Calls the validation function
LearnBlock.Field.prototype.callValidator = function (a) {
    var b = this.classValidator(a);
    if (null === b) return null;
    void 0 !== b && (a = b);
    if (b = this.getValidator()) {
        b = b.call(this, a);
        if (null === b) return null;
        void 0 !== b && (a = b)
    }
    return a
};
//Gets the group element for the editable field
LearnBlock.Field.prototype.getSvgRoot = function () {
    return this.fieldGroup_
};
//Updates the field to match the colour/style of the block
LearnBlock.Field.prototype.updateColour = function () {};
//Used to move/resize any DOM elements and get the new size
LearnBlock.Field.prototype.render_ = function () {
    this.textContent_ && (this.textContent_.nodeValue = this.getDisplayText_(), this.updateSize_())
};
//Updates the width of the field
LearnBlock.Field.prototype.updateWidth = function () {
    console.warn("Deprecated call to updateWidth, call LearnBlock.Field.updateSize_ to force an update to the size of the field, or LearnBlock.utils.dom.getTextWidth() to check the size of the field.");
    this.updateSize_()
};
//Updates the size of the field based on the text
LearnBlock.Field.prototype.updateSize_ = function () {
    var a = LearnBlock.utils.dom.getTextWidth(this.textElement_);
    this.borderRect_ && (a += LearnBlock.Field.X_PADDING, this.borderRect_.setAttribute("width", a));
    this.size_.width = a
};
//Returns the height and width of the field
LearnBlock.Field.prototype.getSize = function () {
    if (!this.isVisible()) return new LearnBlock.utils.Size(0, 0);
    this.isDirty_ ? (this.render_(), this.isDirty_ = !1) : this.visible_ && 0 == this.size_.width && (console.warn("Deprecated use of setting size_.width to 0 to rerender a field. Set field.isDirty_ to true instead."), this.render_());
    return this.size_
};
//Returns the bounding box of the rendered field
LearnBlock.Field.prototype.getScaledBBox_ = function () {
    var a = this.borderRect_.getBBox(),
        b = a.height * this.sourceBlock_.workspace.scale;
    a = a.width * this.sourceBlock_.workspace.scale;
    var c = this.getAbsoluteXY_();
    return {
        top: c.y,
        bottom: c.y + b,
        left: c.x,
        right: c.x + a
    }
};
//Gets the text from the field to display on the block
LearnBlock.Field.prototype.getDisplayText_ = function () {
    var a = this.getText();
    if (!a) return LearnBlock.Field.NBSP;
    a.length > this.maxDisplayLength && (a = a.substring(0, this.maxDisplayLength - 2) + "\u2026");
    a = a.replace(/\s/g, LearnBlock.Field.NBSP);
    this.sourceBlock_ && this.sourceBlock_.RTL && (a += "\u200f");
    return a
};
//Gets the text from the field
LearnBlock.Field.prototype.getText = function () {
    if (this.getText_) {
        var a = this.getText_.call(this);
        if (null !== a) return String(a)
    }
    return String(this.getValue())
};
//Sets the text in the field
LearnBlock.Field.prototype.setText = function (a) {
    throw Error("setText method is deprecated");
};
//Forces a rerender of the block that the field is installed on
LearnBlock.Field.prototype.markDirty = function () {
    this.isDirty_ = !0
};
LearnBlock.Field.prototype.forceRerender = function () {
    this.isDirty_ = !0;
    this.sourceBlock_ && this.sourceBlock_.rendered && (this.sourceBlock_.render(), this.sourceBlock_.bumpNeighbours())
};
//Changes the value of the field
LearnBlock.Field.prototype.setValue = function (a) {
    if (null !== a) {
        var b = this.doClassValidation_(a);
        a = this.processValidation_(a, b);
        if (!(a instanceof Error)) {
            if (b = this.getValidator())
                if (b = b.call(this, a), a = this.processValidation_(a, b), a instanceof Error) return;
            b = this.getValue();
            b !== a && (this.sourceBlock_ && LearnBlock.Events.isEnabled() && LearnBlock.Events.fire(new LearnBlock.Events.BlockChange(this.sourceBlock_, "field", this.name || null, b, a)), this.doValueUpdate_(a), this.isDirty_ && this.forceRerender())
        }
    }
};
//Processes the result of the validation
LearnBlock.Field.prototype.processValidation_ = function (a, b) {
    if (null === b) return this.doValueInvalid_(a), this.isDirty_ && this.forceRerender(), Error();
    void 0 !== b && (a = b);
    return a
};
//Gets the current value of the field
LearnBlock.Field.prototype.getValue = function () {
    return this.value_
};
//Validates a value
LearnBlock.Field.prototype.doClassValidation_ = function (a) {
    return null === a || void 0 === a ? null : a = this.classValidator(a)
};
//Updates the value of a field
LearnBlock.Field.prototype.doValueUpdate_ = function (a) {
    this.value_ = a;
    this.isDirty_ = !0
};
//Notifies the field an invalid value was input
LearnBlock.Field.prototype.doValueInvalid_ = function (a) {};
//Handles a mouse down event on a field
LearnBlock.Field.prototype.onMouseDown_ = function (a) {
    this.sourceBlock_ && this.sourceBlock_.workspace && (a = this.sourceBlock_.workspace.getGesture(a)) && a.setStartField(this)
};
//Changes the tooltip text for the field
LearnBlock.Field.prototype.setTooltip = function (a) {
    var b = this.getClickTarget_();
    b ? b.tooltip = a || "" === a ? a : this.sourceBlock_ : this.tooltip_ = a
};
//The element to bind the click handler to
LearnBlock.Field.prototype.getClickTarget_ = function () {
    return this.clickTarget_ || this.getSvgRoot()
};
//Returns the absolute coordinates of the top-left corner of the field
LearnBlock.Field.prototype.getAbsoluteXY_ = function () {
    return LearnBlock.utils.style.getPageOffset(this.borderRect_)
};
//Whether this field references any variables
LearnBlock.Field.prototype.referencesVariables = function () {
    return !1
};
//Searches to find the parent input of a field
LearnBlock.Field.prototype.getParentInput = function () {
    for (var a = null, b = this.sourceBlock_, c = b.inputList, d = 0; d < b.inputList.length; d++)
        for (var e = c[d], f = e.fieldRow, g = 0; g < f.length; g++)
            if (f[g] === this) {
                a = e;
                break
            } return a
};
//Returns whether or not we should flip the field in RTL
LearnBlock.Field.prototype.getFlipRtl = function () {
    return !1
};
//Returns whether or not the field is tab navigable
LearnBlock.Field.prototype.isTabNavigable = function () {
    return !1
};
//Handles the given action
LearnBlock.Field.prototype.onBlocklyAction = function (a) {
    return !1
};
//Adds the cursor svg to the fields svg group
LearnBlock.Field.prototype.setCursorSvg = function (a) {
    a ? (this.fieldGroup_.appendChild(a), this.cursorSvg_ = a) : this.cursorSvg_ = null
};
//Adds the marker svg to the fields svg group
LearnBlock.Field.prototype.setMarkerSvg = function (a) {
    a ? (this.fieldGroup_.appendChild(a), this.markerSvg_ = a) : this.markerSvg_ = null
};

//Set of all registered fields, keyed by field type
LearnBlock.fieldRegistry = {};
LearnBlock.fieldRegistry.typeMap_ = {};
//Registers a field type
LearnBlock.fieldRegistry.register = function (a, b) {
    if ("string" != typeof a || "" == a.trim()) throw Error('Invalid field type "' + a + '". The type must be a non-empty string.');
    if (LearnBlock.fieldRegistry.typeMap_[a]) throw Error('Error: Field "' + a + '" is already registered.');
    if (!b || "function" != typeof b.fromJson) throw Error('Field "' + b + '" must have a fromJson function');
    a = a.toLowerCase();
    LearnBlock.fieldRegistry.typeMap_[a] = b
};
//Unregisters the field registered with the given type
LearnBlock.fieldRegistry.unregister = function (a) {
    LearnBlock.fieldRegistry.typeMap_[a] ? delete LearnBlock.fieldRegistry.typeMap_[a] : console.warn('No field mapping for type "' + a + '" found to unregister')
};
//Constructs a Field from a JSON arg object
LearnBlock.fieldRegistry.fromJson = function (a) {
    var b = a.type.toLowerCase();
    b = LearnBlock.fieldRegistry.typeMap_[b];
    return b ? b.fromJson(a) : (console.warn("Blockly could not create a field of type " + a.type + ". The field is probably not being registered. This could be because the file is not loaded, the field does not register itself (Issue #1584), or the registration is not being reached."), null)
};

//Class for a non-editable text field
LearnBlock.FieldLabel = function (a, b, c) {
    this.class_ = null;
    null == a && (a = "");
    LearnBlock.FieldLabel.superClass_.constructor.call(this, a, null, c);
    c || (this.class_ = b || null);
    this.size_ = new LearnBlock.utils.Size(0, LearnBlock.Field.TEXT_DEFAULT_HEIGHT)
};
LearnBlock.utils.object.inherits(LearnBlock.FieldLabel, LearnBlock.Field);
//Constructs a FieldLabel from a JSON arg object
LearnBlock.FieldLabel.fromJson = function (a) {
    var b = LearnBlock.utils.replaceMessageReferences(a.text);
    return new LearnBlock.FieldLabel(b, void 0, a)
};
//Editable fields usually show some sort of UI indicating they are editable
LearnBlock.FieldLabel.prototype.EDITABLE = !1;
//Override function
LearnBlock.FieldLabel.prototype.configure_ = function (a) {
    LearnBlock.FieldLabel.superClass_.configure_.call(this, a);
    this.class_ = a["class"]
};
//Creates block UI for the label
LearnBlock.FieldLabel.prototype.initView = function () {
    this.createTextElement_();
    this.textElement_.setAttribute("y", this.size_.height);
    this.class_ && LearnBlock.utils.dom.addClass(this.textElement_, this.class_)
};
//Ensures that the input value casts to a valid string
LearnBlock.FieldLabel.prototype.doClassValidation_ = function (a) {
    return null === a || void 0 === a ? null : String(a)
};
//Sets the css class applied to the field's textElement_
LearnBlock.FieldLabel.prototype.setClass = function (a) {
    this.textElement_ && (this.class_ && LearnBlock.utils.dom.removeClass(this.textElement_, this.class_), a && LearnBlock.utils.dom.addClass(this.textElement_, a));
    this.class_ = a
};
LearnBlock.fieldRegistry.register("field_label", LearnBlock.FieldLabel);

//Class for an input with an optional field
LearnBlock.Input = function (a, b, c, d) {
    if (a != LearnBlock.DUMMY_INPUT && !b) throw Error("Value inputs and statement inputs must have non-empty name.");
    this.type = a;
    this.name = b;
    this.sourceBlock_ = c;
    this.connection = d;
    this.fieldRow = []
};
LearnBlock.Input.prototype.align = LearnBlock.ALIGN_LEFT;
LearnBlock.Input.prototype.visible_ = !0;
//Gets the source block for the input
LearnBlock.Input.prototype.getSourceBlock = function () {
    return this.sourceBlock_
};
//Adds a field to the end of the input's field row
LearnBlock.Input.prototype.appendField = function (a, b) {
    this.insertFieldAt(this.fieldRow.length, a, b);
    return this
};
//Inserts a field to the end of the input's field row
LearnBlock.Input.prototype.insertFieldAt = function (a, b, c) {
    if (0 > a || a > this.fieldRow.length) throw Error("index " + a + " out of bounds.");
    if (!(b || "" == b && c)) return a;
    "string" == typeof b && (b = new LearnBlock.FieldLabel(b));
    b.setSourceBlock(this.sourceBlock_);
    this.sourceBlock_.rendered && b.init();
    b.name = c;
    b.prefixField && (a = this.insertFieldAt(a, b.prefixField));
    this.fieldRow.splice(a, 0, b);
    ++a;
    b.suffixField && (a = this.insertFieldAt(a, b.suffixField));
    this.sourceBlock_.rendered && (this.sourceBlock_.render(), this.sourceBlock_.bumpNeighbours());
    return a
};
//Removes a field from this input
LearnBlock.Input.prototype.removeField = function (a) {
    for (var b = 0, c; c = this.fieldRow[b]; b++)
        if (c.name === a) {
            c.dispose();
            this.fieldRow.splice(b, 1);
            this.sourceBlock_.rendered && (this.sourceBlock_.render(), this.sourceBlock_.bumpNeighbours());
            return
        } throw Error('Field "%s" not found.', a);
};
//Gets whether the input is visible or not
LearnBlock.Input.prototype.isVisible = function () {
    return this.visible_
};
//Sets whether the input is visible or not
LearnBlock.Input.prototype.setVisible = function (a) {
    var b = [];
    if (this.visible_ == a) return b;
    for (var c = (this.visible_ = a) ? "block" : "none", d = 0, e; e = this.fieldRow[d]; d++) e.setVisible(a);
    this.connection && (a ? b = this.connection.unhideAll() : this.connection.hideAll(), d = this.connection.targetBlock()) && (d.getSvgRoot().style.display = c, a || (d.rendered = !1));
    return b
};
//Marks all fields on this input as dirty
LearnBlock.Input.prototype.markDirty = function () {
    for (var a = 0, b; b = this.fieldRow[a]; a++) b.markDirty()
};
//Changes a connection's compatibility
LearnBlock.Input.prototype.setCheck = function (a) {
    if (!this.connection) throw Error("This input does not have a connection.");
    this.connection.setCheck(a);
    return this
};
//Changes the alignment of the connection's fields
LearnBlock.Input.prototype.setAlign = function (a) {
    this.align = a;
    this.sourceBlock_.rendered && this.sourceBlock_.render();
    return this
};
//Initializes the fields on the input
LearnBlock.Input.prototype.init = function () {
    if (this.sourceBlock_.workspace.rendered)
        for (var a = 0; a < this.fieldRow.length; a++) this.fieldRow[a].init()
};
//Severs all links to this input
LearnBlock.Input.prototype.dispose = function () {
    for (var a = 0, b; b = this.fieldRow[a]; a++) b.dispose();
    this.connection && this.connection.dispose();
    this.sourceBlock_ = null
};

//Utils colour
LearnBlock.utils.colour = {};
//Parses a colour from a string
LearnBlock.utils.colour.parse = function (a) {
    a = String(a).toLowerCase().trim();
    var b = LearnBlock.utils.colour.names[a];
    if (b) return b;
    b = "#" == a[0] ? a : "#" + a;
    if (/^#[0-9a-f]{6}$/.test(b)) return b;
    if (/^#[0-9a-f]{3}$/.test(b)) return ["#", b[1], b[1], b[2], b[2], b[3], b[3]].join("");
    var c = a.match(/^(?:rgb)?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/);
    return c && (a = Number(c[1]), b = Number(c[2]), c = Number(c[3]), 0 <= a && 256 > a && 0 <= b && 256 > b && 0 <= c && 256 > c) ? LearnBlock.utils.colour.rgbToHex(a, b, c) : null
};
//Converts a colour from RGB to hex representation
LearnBlock.utils.colour.rgbToHex = function (a, b, c) {
    b = a << 16 | b << 8 | c;
    return 16 > a ? "#" + (16777216 | b).toString(16).substr(1) : "#" + b.toString(16)
};
//Converts a hex representation of a colour to RGB
LearnBlock.utils.colour.hexToRgb = function (a) {
    a = parseInt(a.substr(1), 16);
    return [a >> 16, a >> 8 & 255, a & 255]
};
//Converts an HSV triplet to hex representation
LearnBlock.utils.colour.hsvToHex = function (a, b, c) {
    var d = 0,
        e = 0,
        f = 0;
    if (0 == b) f = e = d = c;
    else {
        var g = Math.floor(a / 60),
            h = a / 60 - g;
        a = c * (1 - b);
        var k = c * (1 - b * h);
        b = c * (1 - b * (1 - h));
        switch (g) {
            case 1:
                d = k;
                e = c;
                f = a;
                break;
            case 2:
                d = a;
                e = c;
                f = b;
                break;
            case 3:
                d = a;
                e = k;
                f = c;
                break;
            case 4:
                d = b;
                e = a;
                f = c;
                break;
            case 5:
                d = c;
                e = a;
                f = k;
                break;
            case 6:
            case 0:
                d = c, e = b, f = a
        }
    }
    return LearnBlock.utils.colour.rgbToHex(Math.floor(d), Math.floor(e), Math.floor(f))
};
//Blends two colours together, using the specified factor to indicate the weight given to the first colour
LearnBlock.utils.colour.blend = function (a, b, c) {
    a = LearnBlock.utils.colour.hexToRgb(LearnBlock.utils.colour.parse(a));
    b = LearnBlock.utils.colour.hexToRgb(LearnBlock.utils.colour.parse(b));
    return LearnBlock.utils.colour.rgbToHex(Math.round(b[0] + c * (a[0] - b[0])), Math.round(b[1] + c * (a[1] - b[1])), Math.round(b[2] + c * (a[2] - b[2])))
};
//A map that contains the 16 basic colour keywords as defined by W3C
LearnBlock.utils.colour.names = {
    aqua: "#00ffff",
    black: "#000000",
    blue: "#0000ff",
    fuchsia: "#ff00ff",
    gray: "#808080",
    green: "#008000",
    lime: "#00ff00",
    maroon: "#800000",
    navy: "#000080",
    olive: "#808000",
    purple: "#800080",
    red: "#ff0000",
    silver: "#c0c0c0",
    teal: "#008080",
    white: "#ffffff",
    yellow: "#ffff00"
};

//Class for a block
LearnBlock.Block = function (a, b, c) {
    if (LearnBlock.Generator && "undefined" != typeof LearnBlock.Generator.prototype[b]) throw Error('Block prototypeName "' + b + '" conflicts with LearnBlock.Generator members.');
    this.id = c && !a.getBlockById(c) ? c : LearnBlock.utils.genUid();
    a.blockDB_[this.id] = this;
    this.previousConnection = this.nextConnection = this.outputConnection = null;
    this.inputList = [];
    this.btname = null;
    this.inputsInline = void 0;
    this.disabled = !1;
    this.tooltip = "";
    this.contextMenu = !0;
    this.parentBlock_ = null;
    this.childBlocks_ = [];
    this.editable_ = this.movable_ =
        this.deletable_ = !0;
    this.xy_ = new LearnBlock.utils.Coordinate(0, 0);
    this.workspace = a;
    this.isInFlyout = a.isFlyout;
    this.RTL = a.RTL;
    this.isInsertionMarker_ = !1;
    this.hat = void 0;
    if (b) {
        this.type = b;
        c = LearnBlock.Blocks[b];
        if (!c || "object" != typeof c) throw TypeError("Unknown block type: " + b);
        LearnBlock.utils.object.mixin(this, c)
    }
    a.addTopBlock(this);
    a.addTypedBlock(this);
    "function" == typeof this.init && this.init();
    this.inputsInlineDefault = this.inputsInline;
    if (LearnBlock.Events.isEnabled()) {
        (a = LearnBlock.Events.getGroup()) || LearnBlock.Events.setGroup(!0);
        try {
            LearnBlock.Events.fire(new LearnBlock.Events.BlockCreate(this))
        } finally {
            a || LearnBlock.Events.setGroup(!1)
        }
    }
    "function" == typeof this.onchange && this.setOnChange(this.onchange)
};
LearnBlock.Block.prototype.data = null;
LearnBlock.Block.prototype.disposed = !1;
LearnBlock.Block.prototype.hue_ = null;
LearnBlock.Block.prototype.colour_ = "#000000";
LearnBlock.Block.prototype.colourSecondary_ = null;
LearnBlock.Block.prototype.colourTertiary_ = null;
LearnBlock.Block.prototype.styleName_ = null;
//Dispose of the block
LearnBlock.Block.prototype.dispose = function (a) {
    if (this.workspace) {
        this.onchangeWrapper_ && this.workspace.removeChangeListener(this.onchangeWrapper_);
        LearnBlock.keyboardAccessibilityMode && LearnBlock.navigation.moveCursorOnBlockDelete(this);
        this.unplug(a);
        LearnBlock.Events.isEnabled() && LearnBlock.Events.fire(new LearnBlock.Events.BlockDelete(this));
        LearnBlock.Events.disable();
        try {
            this.workspace && (this.workspace.removeTopBlock(this), this.workspace.removeTypedBlock(this), delete this.workspace.blockDB_[this.id], this.workspace =
                null);
            LearnBlock.selected == this && (LearnBlock.selected = null);
            for (var b = this.childBlocks_.length - 1; 0 <= b; b--) this.childBlocks_[b].dispose(!1);
            b = 0;
            for (var c; c = this.inputList[b]; b++) c.dispose();
            this.inputList.length = 0;
            var d = this.getConnections_(!0);
            b = 0;
            for (var e; e = d[b]; b++) e.dispose()
        } finally {
            LearnBlock.Events.enable(), this.disposed = !0
        }
    }
};
//Calls initModel on all fields on the block
LearnBlock.Block.prototype.initModel = function () {
    for (var a = 0, b; b = this.inputList[a]; a++)
        for (var c = 0, d; d = b.fieldRow[c]; c++) d.initModel && d.initModel()
};
//Unplugs the block from its superior block
LearnBlock.Block.prototype.unplug = function (a) {
    this.outputConnection ? this.unplugFromRow_(a) : this.previousConnection && this.unplugFromStack_(a)
};
//Unplugs the block's output from an input on another block
LearnBlock.Block.prototype.unplugFromRow_ = function (a) {
    var b = null;
    this.outputConnection.isConnected() && (b = this.outputConnection.targetConnection, this.outputConnection.disconnect());
    if (b && a && (a = this.getOnlyValueConnection_()) && a.isConnected())
        if (a = a.targetConnection, a.disconnect(), a.checkType_(b)) b.connect(a);
        else a.onFailedConnect(b)
};
//Returns the connection on the value input that is connected to another block
LearnBlock.Block.prototype.getOnlyValueConnection_ = function () {
    for (var a = null, b = 0; b < this.inputList.length; b++) {
        var c = this.inputList[b].connection;
        if (c && c.type == LearnBlock.INPUT_VALUE && c.targetConnection) {
            if (a) return null;
            a = c
        }
    }
    return a
};
//Unplugs the statement block from its superior block
LearnBlock.Block.prototype.unplugFromStack_ = function (a) {
    var b = null;
    this.previousConnection.isConnected() && (b = this.previousConnection.targetConnection, this.previousConnection.disconnect());
    var c = this.getNextBlock();
    a && c && (a = this.nextConnection.targetConnection, a.disconnect(), b && b.checkType_(a) && b.connect(a))
};
//Returns all connections originating from the block
LearnBlock.Block.prototype.getConnections_ = function (a) {
    a = [];
    this.outputConnection && a.push(this.outputConnection);
    this.previousConnection && a.push(this.previousConnection);
    this.nextConnection && a.push(this.nextConnection);
    for (var b = 0, c; c = this.inputList[b]; b++) c.connection && a.push(c.connection);
    return a
};
//Walks down a stack of blocks and finds the last next connection on the stack
LearnBlock.Block.prototype.lastConnectionInStack = function () {
    for (var a = this.nextConnection; a;) {
        var b = a.targetBlock();
        if (!b) return a;
        a = b.nextConnection
    }
    return null
};
//Bumps unconnected blocks out of alignment
LearnBlock.Block.prototype.bumpNeighbours = function () {
    console.warn("Not expected to reach Block.bumpNeighbours function. BlockSvg.bumpNeighbours was expected to be called instead.")
};
//Returns the parent block or null if the block is at the top level
LearnBlock.Block.prototype.getParent = function () {
    return this.parentBlock_
};
//Returns the input that connects to the specified block
LearnBlock.Block.prototype.getInputWithBlock = function (a) {
    for (var b = 0, c; c = this.inputList[b]; b++)
        if (c.connection && c.connection.targetBlock() == a) return c;
    return null
};
//Returns the parent block that surrounds the current block
LearnBlock.Block.prototype.getSurroundParent = function () {
    var a = this;
    do {
        var b = a;
        a = a.getParent();
        if (!a) return null
    } while (a.getNextBlock() == b);
    return a
};
//Returns the next statement block directly connected to the block
LearnBlock.Block.prototype.getNextBlock = function () {
    return this.nextConnection && this.nextConnection.targetBlock()
};
//Returns the previous statement block directly connected to the block
LearnBlock.Block.prototype.getPreviousBlock = function () {
    return this.previousConnection && this.previousConnection.targetBlock()
};
//Returns the connection on the first statement input on the block
LearnBlock.Block.prototype.getFirstStatementConnection = function () {
    for (var a = 0, b; b = this.inputList[a]; a++)
        if (b.connection && b.connection.type == LearnBlock.NEXT_STATEMENT) return b.connection;
    return null
};
//Returns the top-most block in the block's tree
LearnBlock.Block.prototype.getRootBlock = function () {
    var a = this;
    do {
        var b = a;
        a = b.parentBlock_
    } while (a);
    return b
};
//Walks up from the given block up through the stack of blocks to find the top block of the sub stack
LearnBlock.Block.prototype.getTopStackBlock = function () {
    var a = this;
    do var b = a.getPreviousBlock(); while (b && b.getNextBlock() == a && (a = b));
    return a
};
//Finds all the blocks that are directly nested inside the current one
LearnBlock.Block.prototype.getChildren = function (a) {
    if (!a) return this.childBlocks_;
    a = [];
    for (var b = 0, c; c = this.inputList[b]; b++) c.connection && (c = c.connection.targetBlock()) && a.push(c);
    (b = this.getNextBlock()) && a.push(b);
    return a
};
//Sets parent of the block to be a new block or null
LearnBlock.Block.prototype.setParent = function (a) {
    if (a != this.parentBlock_) {
        if (this.parentBlock_) {
            LearnBlock.utils.arrayRemove(this.parentBlock_.childBlocks_, this);
            if (this.previousConnection && this.previousConnection.isConnected()) throw Error("Still connected to previous block.");
            if (this.outputConnection && this.outputConnection.isConnected()) throw Error("Still connected to parent block.");
            this.parentBlock_ = null
        } else this.workspace.removeTopBlock(this);
        (this.parentBlock_ = a) ? a.childBlocks_.push(this): this.workspace.addTopBlock(this)
    }
};
//Finds all the blocks that are directly or indirectly nested inside the current one
LearnBlock.Block.prototype.getDescendants = function (a) {
    for (var b = [this], c = this.getChildren(a), d, e = 0; d = c[e]; e++) b.push.apply(b, d.getDescendants(a));
    return b
};
//Gets whether the block is deletable or not
LearnBlock.Block.prototype.isDeletable = function () {
    return this.deletable_ && !this.isShadow_ && !(this.workspace && this.workspace.options.readOnly)
};
//Sets whether the block is deletable or not
LearnBlock.Block.prototype.setDeletable = function (a) {
    this.deletable_ = a
};
//Gets whether the block is movable or not
LearnBlock.Block.prototype.isMovable = function () {
    return this.movable_ && !this.isShadow_ && !(this.workspace && this.workspace.options.readOnly)
};
//Sets whether the block is movable or not
LearnBlock.Block.prototype.setMovable = function (a) {
    this.movable_ = a
};
//Gets whether the block is duplicatable or not
LearnBlock.Block.prototype.isDuplicatable = function () {
    return this.workspace.hasBlockLimits() ? this.workspace.isCapacityAvailable(LearnBlock.utils.getBlockTypeCounts(this, !0)) : !0
};
//Gets whether the block is an insertion marker block or not
LearnBlock.Block.prototype.isInsertionMarker = function () {
    return this.isInsertionMarker_
};
//Sets whether the block is an insertion marker block or not
LearnBlock.Block.prototype.setInsertionMarker = function (a) {
    this.isInsertionMarker_ = a
};
//Gets whether the block is editable or not
LearnBlock.Block.prototype.isEditable = function () {
    return this.editable_ && !(this.workspace && this.workspace.options.readOnly)
};
//Sets whether the block is editable or not
LearnBlock.Block.prototype.setEditable = function (a) {
    this.editable_ = a;
    a = 0;
    for (var b; b = this.inputList[a]; a++)
        for (var c = 0, d; d = b.fieldRow[c]; c++) d.updateEditable()
};
//Finds the connection on the block that corresponds to the given connection on the other block
LearnBlock.Block.prototype.getMatchingConnection = function (a, b) {
    var c = this.getConnections_(!0),
        d = a.getConnections_(!0);
    if (c.length != d.length) throw Error("Connection lists did not match in length.");
    for (var e = 0; e < d.length; e++)
        if (d[e] == b) return c[e];
    return null
};
//Changes the tooltip text for a block
LearnBlock.Block.prototype.setTooltip = function (a) {
    this.tooltip = a
};
//Gets the colour of a block
LearnBlock.Block.prototype.getColour = function () {
    return this.colour_
};
//Gets the secondary colour of a block
LearnBlock.Block.prototype.getColourSecondary = function () {
    return this.colourSecondary_
};
//Gets the tertiary colour of a block
LearnBlock.Block.prototype.getColourTertiary = function () {
    return this.colourTertiary_
};
//Gets the border colour(s) of a block
LearnBlock.Block.prototype.getColourBorder = function () {
    var a = this.getColourTertiary();
    if (a) return {
        colourBorder: a,
        colourLight: null,
        colourDark: null
    };
    a = this.getColour();
    return {
        colourBorder: null,
        colourLight: LearnBlock.utils.colour.blend("#fff", a, .3),
        colourDark: LearnBlock.utils.colour.blend("#000", a, .2)
    }
};
//Gets the name of the block style
LearnBlock.Block.prototype.getStyleName = function () {
    return this.styleName_
};
//Gets the HSV hue value of a block
LearnBlock.Block.prototype.getHue = function () {
    return this.hue_
};
//Changes the colour of a block
LearnBlock.Block.prototype.setColour = function (a) {
    var b = "string" == typeof a ? LearnBlock.utils.replaceMessageReferences(a) : a,
        c = Number(b);
    if (!isNaN(c) && 0 <= c && 360 >= c) this.hue_ = c, this.colour_ = LearnBlock.hueToHex(c);
    else if (c = LearnBlock.utils.colour.parse(b)) this.colour_ = c, this.hue_ = null;
    else throw c = 'Invalid colour: "' + b + '"', a != b && (c += ' (from "' + a + '")'), Error(c);
};
//Sets the style and colour values of a block
LearnBlock.Block.prototype.setStyle = function (a) {
    var b = this.workspace.getTheme().getBlockStyle(a);
    this.styleName_ = a;
    if (b) this.colourSecondary_ = b.colourSecondary, this.colourTertiary_ = b.colourTertiary, this.hat = b.hat, this.setColour(b.colourPrimary);
    else throw Error("Invalid style name: " + a);
};
//Sets a callback function to use whenever the block's parent workspace changes
LearnBlock.Block.prototype.setOnChange = function (a) {
    if (a && "function" != typeof a) throw Error("onchange must be a function.");
    this.onchangeWrapper_ && this.workspace.removeChangeListener(this.onchangeWrapper_);
    if (this.onchange = a) this.onchangeWrapper_ = a.bind(this), this.workspace.addChangeListener(this.onchangeWrapper_)
};
//Returns the named field from a bloc
LearnBlock.Block.prototype.getField = function (a) {
    for (var b = 0, c; c = this.inputList[b]; b++)
        for (var d = 0, e; e = c.fieldRow[d]; d++)
            if (e.name == a) return e;
    return null
};
//Returns all variables referenced by the block
LearnBlock.Block.prototype.getVars = function () {
    for (var a = [], b = 0, c; c = this.inputList[b]; b++)
        for (var d = 0, e; e = c.fieldRow[d]; d++) e.referencesVariables() && a.push(e.getValue());
    return a
};
//Returns all variables referenced by the block
LearnBlock.Block.prototype.getVarModels = function () {
    for (var a = [], b = 0, c; c = this.inputList[b]; b++)
        for (var d = 0, e; e = c.fieldRow[d]; d++) e.referencesVariables() && (e = this.workspace.getVariableById(e.getValue())) && a.push(e);
    return a
};
//Updates the variable name but keeps the same ID
LearnBlock.Block.prototype.updateVarName = function (a) {
    for (var b = 0, c; c = this.inputList[b]; b++)
        for (var d = 0, e; e = c.fieldRow[d]; d++) e.referencesVariables() && a.getId() == e.getValue() && e.refreshVariableName()
};
//Renames the variable also by the ID
LearnBlock.Block.prototype.renameVarById = function (a, b) {
    for (var c = 0, d; d = this.inputList[c]; c++)
        for (var e = 0, f; f = d.fieldRow[e]; e++) f.referencesVariables() && a == f.getValue() && f.setValue(b)
};
//Returns the language-neutral value from the field of a block
LearnBlock.Block.prototype.getFieldValue = function (a) {
    return (a = this.getField(a)) ? a.getValue() : null
};
//Changes the field value for a block
LearnBlock.Block.prototype.setFieldValue = function (a, b) {
    var c = this.getField(b);
    if (!c) throw Error('Field "' + b + '" not found.');
    c.setValue(a)
};
//Sets whether the block can chain onto the bottom of another block
LearnBlock.Block.prototype.setPreviousStatement = function (a, b) {
    if (a) {
        void 0 === b && (b = null);
        if (!this.previousConnection) {
            if (this.outputConnection) throw Error("Remove output connection prior to adding previous connection.");
            this.previousConnection = this.makeConnection_(LearnBlock.PREVIOUS_STATEMENT)
        }
        this.previousConnection.setCheck(b)
    } else if (this.previousConnection) {
        if (this.previousConnection.isConnected()) throw Error("Must disconnect previous statement before removing connection.");
        this.previousConnection.dispose();
        this.previousConnection = null
    }
};
//Sets whether another block can chain onto the bottom of the block
LearnBlock.Block.prototype.setNextStatement = function (a, b) {
    if (a) void 0 === b && (b = null), this.nextConnection || (this.nextConnection = this.makeConnection_(LearnBlock.NEXT_STATEMENT)), this.nextConnection.setCheck(b);
    else if (this.nextConnection) {
        if (this.nextConnection.isConnected()) throw Error("Must disconnect next statement before removing connection.");
        this.nextConnection.dispose();
        this.nextConnection = null
    }
};
//Sets whether the block returns a value
LearnBlock.Block.prototype.setOutput = function (a, b) {
    if (a) {
        void 0 === b && (b = null);
        if (!this.outputConnection) {
            if (this.previousConnection) throw Error("Remove previous connection prior to adding output connection.");
            this.outputConnection = this.makeConnection_(LearnBlock.OUTPUT_VALUE)
        }
        this.outputConnection.setCheck(b)
    } else if (this.outputConnection) {
        if (this.outputConnection.isConnected()) throw Error("Must disconnect output value before removing connection.");
        this.outputConnection.dispose();
        this.outputConnection =
            null
    }
};
//Sets whether value inputs are arranged horizontally or vertically
LearnBlock.Block.prototype.setInputsInline = function (a) {
    this.inputsInline != a && (LearnBlock.Events.fire(new LearnBlock.Events.BlockChange(this, "inline", null, this.inputsInline, a)), this.inputsInline = a)
};
//Gets whether value inputs are arranged horizontally or vertically
LearnBlock.Block.prototype.getInputsInline = function () {
    if (void 0 != this.inputsInline) return this.inputsInline;
    for (var a = 1; a < this.inputList.length; a++)
        if (this.inputList[a - 1].type == LearnBlock.DUMMY_INPUT && this.inputList[a].type == LearnBlock.DUMMY_INPUT) return !1;
    for (a = 1; a < this.inputList.length; a++)
        if (this.inputList[a - 1].type == LearnBlock.INPUT_VALUE && this.inputList[a].type == LearnBlock.DUMMY_INPUT) return !0;
    return !1
};
//Creates a text representation of the block and any children
LearnBlock.Block.prototype.toString = function (a, b) {
    var c = [],
        d = b || "?";
    if (this.collapsed_) c.push(this.getInput("_TEMP_COLLAPSED_INPUT").fieldRow[0].getText());
    else
        for (var e = 0, f; f = this.inputList[e]; e++) {
            for (var g = 0, h; h = f.fieldRow[g]; g++) c.push(h.getText());
            f.connection && ((f = f.connection.targetBlock()) ? c.push(f.toString(void 0, b)) : c.push(d))
        }
    c = c.join(" ").trim() || "???";
    a && c.length > a && (c = c.substring(0, a - 3) + "...");
    return c
};
//Shortcut for appending a value input row
LearnBlock.Block.prototype.appendValueInput = function (a) {
    return this.appendInput_(LearnBlock.INPUT_VALUE, a)
};
//Shortcut for appending a statement input row
LearnBlock.Block.prototype.appendStatementInput = function (a) {
    return this.appendInput_(LearnBlock.NEXT_STATEMENT, a)
};
//Shortcut for appending a dummy input row
LearnBlock.Block.prototype.appendDummyInput = function (a) {
    return this.appendInput_(LearnBlock.DUMMY_INPUT, a || "")
};
//Initializes the block using a JSON description
LearnBlock.Block.prototype.jsonInit = function (a) {
    var b = a.type ? 'Block "' + a.type + '": ' : "";
    this.btname = a.blocktextname;
    if (a.output && a.previousStatement) throw Error(b + "Must not have both an output and a previousStatement.");
    a.style && a.style.hat && (this.hat = a.style.hat, a.style = null);
    if (a.style && a.colour) throw Error(b + "Must not have both a colour and a style.");
    a.style ? this.jsonInitStyle_(a, b) : this.jsonInitColour_(a, b);
    for (var c = 0; void 0 !== a["message" + c];) this.interpolate_(a["message" + c], a["args" + c] || [], a["lastDummyAlign" + c]), c++;
    void 0 !==
        a.inputsInline && this.setInputsInline(a.inputsInline);
    void 0 !== a.output && this.setOutput(!0, a.output);
    void 0 !== a.previousStatement && this.setPreviousStatement(!0, a.previousStatement);
    void 0 !== a.nextStatement && this.setNextStatement(!0, a.nextStatement);
    void 0 !== a.tooltip && (c = a.tooltip, c = LearnBlock.utils.replaceMessageReferences(c), this.setTooltip(c));
    void 0 !== a.enableContextMenu && (c = a.enableContextMenu, this.contextMenu = !!c);
    "string" == typeof a.extensions && (console.warn(b + "JSON attribute 'extensions' should be an array of strings. Found raw string in JSON for '" + a.type + "' block."), a.extensions = [a.extensions]);
    if (Array.isArray(a.extensions))
        for (a = a.extensions, b = 0; b < a.length; ++b) LearnBlock.Extensions.apply(a[b], this, !1)
};
//Initializes the colour of the block from the JSON description
LearnBlock.Block.prototype.jsonInitColour_ = function (a, b) {
    if ("colour" in a)
        if (void 0 === a.colour) console.warn(b + "Undefined colour value.");
        else {
            var c = a.colour;
            try {
                this.setColour(c)
            } catch (d) {
                console.warn(b + "Illegal colour value: ", c)
            }
        }
};
//Initializes the style of the block from the JSON description
LearnBlock.Block.prototype.jsonInitStyle_ = function (a, b) {
    var c = a.style;
    try {
        this.setStyle(c)
    } catch (d) {
        console.warn(b + "Style does not exist: ", c)
    }
};
//Adds key/values from mixinObj to the block
LearnBlock.Block.prototype.mixin = function (a, b) {
    if (void 0 !== b && "boolean" != typeof b) throw Error("opt_disableCheck must be a boolean if provided");
    if (!b) {
        var c = [],
            d;
        for (d in a) void 0 !== this[d] && c.push(d);
        if (c.length) throw Error("Mixin will overwrite block members: " + JSON.stringify(c));
    }
    LearnBlock.utils.object.mixin(this, a)
};
//Interpolates a message description onto the block
LearnBlock.Block.prototype.interpolate_ = function (a, b, c) {
    var d = LearnBlock.utils.tokenizeInterpolation(a),
        e = [],
        f = 0;
    a = [];
    for (var g = 0; g < d.length; g++) {
        var h = d[g];
        if ("number" == typeof h) {
            if (0 >= h || h > b.length) throw Error('Block "' + this.type + '": Message index %' + h + " out of range.");
            if (e[h]) throw Error('Block "' + this.type + '": Message index %' + h + " duplicated.");
            e[h] = !0;
            f++;
            a.push(b[h - 1])
        } else(h = h.trim()) && a.push(h)
    }
    if (f != b.length) throw Error('Block "' + this.type + '": Message does not reference all ' + b.length + " arg(s).");
    a.length && ("string" == typeof a[a.length - 1] || LearnBlock.utils.string.startsWith(a[a.length - 1].type, "field_")) && (g = {
        type: "input_dummy"
    }, c && (g.align = c), a.push(g));
    c = {
        LEFT: LearnBlock.ALIGN_LEFT,
        RIGHT: LearnBlock.ALIGN_RIGHT,
        CENTRE: LearnBlock.ALIGN_CENTRE
    };
    b = [];
    for (g = 0; g < a.length; g++)
        if (e = a[g], "string" == typeof e) b.push([e, void 0]);
        else {
            d = f = null;
            do
                if (h = !1, "string" == typeof e) f = new LearnBlock.FieldLabel(e);
                else switch (e.type) {
                    case "input_value":
                        d = this.appendValueInput(e.name);
                        break;
                    case "input_statement":
                        d = this.appendStatementInput(e.name);
                        break;
                    case "input_dummy":
                        d = this.appendDummyInput(e.name);
                        break;
                    default:
                        f = LearnBlock.fieldRegistry.fromJson(e), !f && e.alt && (e = e.alt, h = !0)
                }
            while (h);
            if (f) b.push([f, e.name]);
            else if (d) {
                e.check && d.setCheck(e.check);
                e.align && d.setAlign(c[e.align]);
                for (e = 0; e < b.length; e++) d.appendField(b[e][0], b[e][1]);
                b.length = 0
            }
        }
};
//Adds a value input, statement input or local variable to the block
LearnBlock.Block.prototype.appendInput_ = function (a, b) {
    var c = null;
    if (a == LearnBlock.INPUT_VALUE || a == LearnBlock.NEXT_STATEMENT) c = this.makeConnection_(a);
    c = new LearnBlock.Input(a, b, this, c);
    this.inputList.push(c);
    return c
};
//Moves a named input to a different location on the block
LearnBlock.Block.prototype.moveInputBefore = function (a, b) {
    if (a != b) {
        for (var c = -1, d = b ? -1 : this.inputList.length, e = 0, f; f = this.inputList[e]; e++)
            if (f.name == a) {
                if (c = e, -1 != d) break
            } else if (b && f.name == b && (d = e, -1 != c)) break;
        if (-1 == c) throw Error('Named input "' + a + '" not found.');
        if (-1 == d) throw Error('Reference input "' + b + '" not found.');
        this.moveNumberedInputBefore(c, d)
    }
};
//Moves a numbered input to a different location on the block
LearnBlock.Block.prototype.moveNumberedInputBefore = function (a, b) {
    if (a == b) throw Error("Can't move input to itself.");
    if (a >= this.inputList.length) throw RangeError("Input index " + a + " out of bounds.");
    if (b > this.inputList.length) throw RangeError("Reference input " + b + " out of bounds.");
    var c = this.inputList[a];
    this.inputList.splice(a, 1);
    a < b && b--;
    this.inputList.splice(b, 0, c)
};
//Removes an input from the block
LearnBlock.Block.prototype.removeInput = function (a, b) {
    for (var c = 0, d; d = this.inputList[c]; c++)
        if (d.name == a) {
            d.dispose();
            this.inputList.splice(c, 1);
            return
        } if (!b) throw Error("Input not found: " + a);
};
//Fetches the named input object
LearnBlock.Block.prototype.getInput = function (a) {
    for (var b = 0, c; c = this.inputList[b]; b++)
        if (c.name == a) return c;
    return null
};
//Fetches the block attached to the named input
LearnBlock.Block.prototype.getInputTargetBlock = function (a) {
    return (a = this.getInput(a)) && a.connection && a.connection.targetBlock()
};
//Returns the coordinates of the top-left corner of the block relative to the drawing surface's origin
LearnBlock.Block.prototype.getRelativeToSurfaceXY = function () {
    return this.xy_
};
//Moves a block by a relative offset
LearnBlock.Block.prototype.moveBy = function (a, b) {
    if (this.parentBlock_) throw Error("Block has parent.");
    var c = new LearnBlock.Events.BlockMove(this);
    this.xy_.translate(a, b);
    c.recordNew();
    LearnBlock.Events.fire(c)
};
//Creates a connection of the specified type
LearnBlock.Block.prototype.makeConnection_ = function (a) {
    return new LearnBlock.Connection(this, a)
};
//Recursively checks whether all statement and value inputs are filled with blocks
LearnBlock.Block.prototype.allInputsFilled = function (a) {
    void 0 === a && (a = !0);
    if (!a && this.isShadow()) return !1;
    for (var b = 0, c; c = this.inputList[b]; b++)
        if (c.connection && (c = c.connection.targetBlock(), !c || !c.allInputsFilled(a))) return !1;
    return (b = this.getNextBlock()) ? b.allInputsFilled(a) : !0
};
//Returns a string describing the block in developer terms
LearnBlock.Block.prototype.toDevString = function () {
    var a = this.type ? '"' + this.type + '" block' : "Block";
    this.id && (a += ' (id="' + this.id + '")');
    return a
};

//Class for a drag surface for the currently dragged block
LearnBlock.BlockDragSurfaceSvg = function (a) {
    this.container_ = a;
    this.createDom()
};
LearnBlock.BlockDragSurfaceSvg.prototype.SVG_ = null;
LearnBlock.BlockDragSurfaceSvg.prototype.dragGroup_ = null;
LearnBlock.BlockDragSurfaceSvg.prototype.container_ = null;
LearnBlock.BlockDragSurfaceSvg.prototype.scale_ = 1;
LearnBlock.BlockDragSurfaceSvg.prototype.surfaceXY_ = null;
//Creates the drag surface and injects it into the container
LearnBlock.BlockDragSurfaceSvg.prototype.createDom = function () {
    this.SVG_ || (this.SVG_ = LearnBlock.utils.dom.createSvgElement("svg", {
        xmlns: LearnBlock.utils.dom.SVG_NS,
        "xmlns:html": LearnBlock.utils.dom.HTML_NS,
        "xmlns:xlink": LearnBlock.utils.dom.XLINK_NS,
        version: "1.1",
        "class": "blocklyBlockDragSurface"
    }, this.container_), this.dragGroup_ = LearnBlock.utils.dom.createSvgElement("g", {}, this.SVG_))
};
//Sets the SVG blocks on the drag surface's group and shows the surface
LearnBlock.BlockDragSurfaceSvg.prototype.setBlocksAndShow = function (a) {
    if (this.dragGroup_.childNodes.length) throw Error("Already dragging a block.");
    this.dragGroup_.appendChild(a);
    this.SVG_.style.display = "block";
    this.surfaceXY_ = new LearnBlock.utils.Coordinate(0, 0)
};
//Translates and scales the entire drag surface group to the given position
LearnBlock.BlockDragSurfaceSvg.prototype.translateAndScaleGroup = function (a, b, c) {
    this.scale_ = c;
    a = a.toFixed(0);
    b = b.toFixed(0);
    this.dragGroup_.setAttribute("transform", "translate(" + a + "," + b + ") scale(" + c + ")")
};
//Translates the drag surface's SVG based on its internal state
LearnBlock.BlockDragSurfaceSvg.prototype.translateSurfaceInternal_ = function () {
    var a = this.surfaceXY_.x,
        b = this.surfaceXY_.y;
    a = a.toFixed(0);
    b = b.toFixed(0);
    this.SVG_.style.display = "block";
    LearnBlock.utils.dom.setCssTransform(this.SVG_, "translate3d(" + a + "px, " + b + "px, 0px)")
};
//Translates the entire drag surface during a drag
LearnBlock.BlockDragSurfaceSvg.prototype.translateSurface = function (a, b) {
    this.surfaceXY_ = new LearnBlock.utils.Coordinate(a * this.scale_, b * this.scale_);
    this.translateSurfaceInternal_()
};
//Reports the surface translation in scaled workspace coordinates
LearnBlock.BlockDragSurfaceSvg.prototype.getSurfaceTranslation = function () {
    var a = LearnBlock.utils.getRelativeXY(this.SVG_);
    return new LearnBlock.utils.Coordinate(a.x / this.scale_, a.y / this.scale_)
};
//Provides a reference to the drag group
LearnBlock.BlockDragSurfaceSvg.prototype.getGroup = function () {
    return this.dragGroup_
};
//Gets the current blocks on the drag surface
LearnBlock.BlockDragSurfaceSvg.prototype.getCurrentBlock = function () {
    return this.dragGroup_.firstChild
};
//Clears the group and hides the surface
LearnBlock.BlockDragSurfaceSvg.prototype.clearAndHide = function (a) {
    a ? a.appendChild(this.getCurrentBlock()) : this.dragGroup_.removeChild(this.getCurrentBlock());
    this.SVG_.style.display = "none";
    if (this.dragGroup_.childNodes.length) throw Error("Drag group was not cleared.");
    this.surfaceXY_ = null
};


LearnBlock.blockRendering = {};
LearnBlock.blockRendering.IPathObject = function (a) {};
LearnBlock.blockRendering.PathObject = function (a) {
    this.svgRoot = a;
    this.svgPath = LearnBlock.utils.dom.createSvgElement("path", {
        "class": "blocklyPath"
    }, this.svgRoot);
    this.svgPathLight = LearnBlock.utils.dom.createSvgElement("path", {
        "class": "blocklyPathLight"
    }, this.svgRoot);
    this.svgPathDark = LearnBlock.utils.dom.createSvgElement("path", {
        "class": "blocklyPathDark",
        transform: "translate(1,1)"
    }, this.svgRoot)
};
LearnBlock.blockRendering.PathObject.prototype.setPaths = function (a) {
    this.svgPath.setAttribute("d", a);
    this.svgPathLight.style.display = "none";
    this.svgPathDark.style.display = "none"
};
LearnBlock.blockRendering.PathObject.prototype.flipRTL = function () {
    this.svgPath.setAttribute("transform", "scale(-1 1)")
};

//Utils idGenerator
LearnBlock.utils.IdGenerator = {};
//Next unique ID to use
LearnBlock.utils.IdGenerator.nextId_ = 0;
//Gets the next unique ID
LearnBlock.utils.IdGenerator.getNextUniqueId = function () {
    return "blockly:" + (LearnBlock.utils.IdGenerator.nextId_++).toString(36)
};

//Default implementation of a UI component
LearnBlock.Component = function () {
    this.rightToLeft_ = LearnBlock.Component.defaultRightToLeft;
    this.id_ = null;
    this.inDocument_ = !1;
    this.parent_ = this.element_ = null;
    this.children_ = [];
    this.childIndex_ = {}
};
//The default right to left value
LearnBlock.Component.defaultRightToLeft = !1;
//Errors thrown by the component
LearnBlock.Component.Error = {
    ALREADY_RENDERED: "Component already rendered",
    PARENT_UNABLE_TO_BE_SET: "Unable to set parent component",
    CHILD_INDEX_OUT_OF_BOUNDS: "Child component index out of bounds"
};
//Gets the unique ID for the instance of this component
LearnBlock.Component.prototype.getId = function () {
    return this.id_ || (this.id_ = LearnBlock.utils.IdGenerator.getNextUniqueId())
};
//Gets the component's element
LearnBlock.Component.prototype.getElement = function () {
    return this.element_
};
//Sets the component's root element to the given element
LearnBlock.Component.prototype.setElementInternal = function (a) {
    this.element_ = a
};
//Sets the parent of this component to use for event bubbling
LearnBlock.Component.prototype.setParent = function (a) {
    if (this == a) throw Error(LearnBlock.Component.Error.PARENT_UNABLE_TO_BE_SET);
    if (a && this.parent_ && this.id_ && this.parent_.getChild(this.id_) && this.parent_ != a) throw Error(LearnBlock.Component.Error.PARENT_UNABLE_TO_BE_SET);
    this.parent_ = a
};
//Returns the component's parent, if any
LearnBlock.Component.prototype.getParent = function () {
    return this.parent_
};
//Determines whether the component has been added to the document
LearnBlock.Component.prototype.isInDocument = function () {
    return this.inDocument_
};
//Creates the initial DOM representation for the component
LearnBlock.Component.prototype.createDom = function () {
    this.element_ = document.createElement("div")
};
//Renders the component
LearnBlock.Component.prototype.render = function (a) {
    this.render_(a)
};
//Renders the component before another element
LearnBlock.Component.prototype.renderBefore = function (a) {
    this.render_(a.parentNode, a)
};
//Renders the component
LearnBlock.Component.prototype.render_ = function (a, b) {
    if (this.inDocument_) throw Error(LearnBlock.Component.Error.ALREADY_RENDERED);
    this.element_ || this.createDom();
    a ? a.insertBefore(this.element_, b || null) : document.body.appendChild(this.element_);
    this.parent_ && !this.parent_.isInDocument() || this.enterDocument()
};
//Called when the component's element is known to be in the document
LearnBlock.Component.prototype.enterDocument = function () {
    this.inDocument_ = !0;
    this.forEachChild(function (a) {
        !a.isInDocument() && a.getElement() && a.enterDocument()
    })
};
//Called by dispose to clean up the elements and listeners created by a component
LearnBlock.Component.prototype.exitDocument = function () {
    this.forEachChild(function (a) {
        a.isInDocument() && a.exitDocument()
    });
    this.inDocument_ = !1
};
//Disposes of the object
LearnBlock.Component.prototype.dispose = function () {
    this.disposed_ || (this.disposed_ = !0, this.disposeInternal())
};
//Disposes of the component
LearnBlock.Component.prototype.disposeInternal = function () {
    this.inDocument_ && this.exitDocument();
    this.forEachChild(function (a) {
        a.dispose()
    });
    this.element_ && LearnBlock.utils.dom.removeNode(this.element_);
    this.parent_ = this.element_ = this.childIndex_ = this.children_ = null
};
//Adds the specified component as the last child of this component
LearnBlock.Component.prototype.addChild = function (a, b) {
    this.addChildAt(a, this.getChildCount(), b)
};
//Adds the specified component as a child of this component at the given 0-based index
LearnBlock.Component.prototype.addChildAt = function (a, b, c) {
    if (a.inDocument_ && (c || !this.inDocument_)) throw Error(LearnBlock.Component.Error.ALREADY_RENDERED);
    if (0 > b || b > this.getChildCount()) throw Error(LearnBlock.Component.Error.CHILD_INDEX_OUT_OF_BOUNDS);
    this.childIndex_[a.getId()] = a;
    if (a.getParent() == this) {
        var d = this.children_.indexOf(a); - 1 < d && this.children_.splice(d, 1)
    }
    a.setParent(this);
    this.children_.splice(b, 0, a);
    a.inDocument_ && this.inDocument_ && a.getParent() == this ? (c = this.getContentElement(), b = c.childNodes[b] ||
        null, b != a.getElement() && c.insertBefore(a.getElement(), b)) : c ? (this.element_ || this.createDom(), b = this.getChildAt(b + 1), a.render_(this.getContentElement(), b ? b.element_ : null)) : this.inDocument_ && !a.inDocument_ && a.element_ && a.element_.parentNode && a.element_.parentNode.nodeType == LearnBlock.utils.dom.Node.ELEMENT_NODE && a.enterDocument()
};
//Returns the DOM element into which child components are to be rendered
LearnBlock.Component.prototype.getContentElement = function () {
    return this.element_
};
//Returns true if the component is rendered right-to-left, false otherwise
LearnBlock.Component.prototype.isRightToLeft = function () {
    return this.rightToLeft_
};
//Set is right-to-left
LearnBlock.Component.prototype.setRightToLeft = function (a) {
    if (this.inDocument_) throw Error(LearnBlock.Component.Error.ALREADY_RENDERED);
    this.rightToLeft_ = a
};
//Returns true if the component has children
LearnBlock.Component.prototype.hasChildren = function () {
    return 0 != this.children_.length
};
//Returns the number of children of this component
LearnBlock.Component.prototype.getChildCount = function () {
    return this.children_.length
};
//Returns the child with the given ID, or null if no such child exists
LearnBlock.Component.prototype.getChild = function (a) {
    return a ? this.childIndex_[a] || null : null
};
//Returns the child at the given index, or null if the index is out of bounds
LearnBlock.Component.prototype.getChildAt = function (a) {
    return this.children_[a] || null
};
//Calls the given function on each of this component's children in order
LearnBlock.Component.prototype.forEachChild = function (a, b) {
    for (var c = 0; c < this.children_.length; c++) a.call(b, this.children_[c], c)
};
//Returns the 0-based index of the given child component
LearnBlock.Component.prototype.indexOfChild = function (a) {
    return this.children_.indexOf(a)
};

//Utils aria
LearnBlock.utils.aria = {};
//ARIA states/properties prefix
LearnBlock.utils.aria.ARIA_PREFIX_ = "aria-";
//ARIA role attribute
LearnBlock.utils.aria.ROLE_ATTRIBUTE_ = "role";
//ARIA role values
LearnBlock.utils.aria.Role = {};
//ARIA states and properties
LearnBlock.utils.aria.State = {};
//Sets the role of an element
LearnBlock.utils.aria.setRole = function (a, b) {
    b ? a.setAttribute(LearnBlock.utils.aria.ROLE_ATTRIBUTE_, b) : LearnBlock.utils.aria.removeRole(a)
};
//Gets role of an element
LearnBlock.utils.aria.getRole = function (a) {
    return a.getAttribute(LearnBlock.utils.aria.ROLE_ATTRIBUTE_) || null
};
//Removes role of an element
LearnBlock.utils.aria.removeRole = function (a) {
    a.removeAttribute(LearnBlock.utils.aria.ROLE_ATTRIBUTE_)
};
//Sets the state or property of an element
LearnBlock.utils.aria.setState = function (a, b, c) {
    Array.isArray(c) && (c = c.join(" "));
    b = LearnBlock.utils.aria.getAriaAttributeName_(b);
    a.setAttribute(b, c)
};
//Adds the 'aria-' prefix to ariaName
LearnBlock.utils.aria.getAriaAttributeName_ = function (a) {
    return LearnBlock.utils.aria.ARIA_PREFIX_ + a
};

//A basic menu class
LearnBlock.Menu = function () {
    LearnBlock.Component.call(this);
    this.highlightedIndex_ = -1
};
LearnBlock.utils.object.inherits(LearnBlock.Menu, LearnBlock.Component);
//Creates the menu DOM
LearnBlock.Menu.prototype.createDom = function () {
    var a = document.createElement("div");
    a.id = this.getId();
    this.setElementInternal(a);
    a.className = "goog-menu goog-menu-vertical blocklyNonSelectable";
    a.tabIndex = 0;
    LearnBlock.utils.aria.setRole(a, this.roleName_ || LearnBlock.utils.aria.Role.MENU)
};
//Focuses the menu element
LearnBlock.Menu.prototype.focus = function () {
    var a = this.getElement();
    a && (a.focus(), LearnBlock.utils.dom.addClass(a, "focused"))
};
//Blurs the menu element
LearnBlock.Menu.prototype.blur = function () {
    var a = this.getElement();
    a && (a.blur(), LearnBlock.utils.dom.removeClass(a, "focused"))
};
//Sets the menu accessibility role
LearnBlock.Menu.prototype.setRole = function (a) {
    this.roleName_ = a
};
//Override method
LearnBlock.Menu.prototype.enterDocument = function () {
    LearnBlock.Menu.superClass_.enterDocument.call(this);
    this.forEachChild(function (a) {
        a.isInDocument() && this.registerChildId_(a)
    }, this);
    this.attachEvents_()
};
//Cleans up the container before its DOM is removed from the document
LearnBlock.Menu.prototype.exitDocument = function () {
    this.setHighlightedIndex(-1);
    LearnBlock.Menu.superClass_.exitDocument.call(this)
};
//Override method
LearnBlock.Menu.prototype.disposeInternal = function () {
    LearnBlock.Menu.superClass_.disposeInternal.call(this);
    this.detachEvents_()
};
//Adds the event listeners to the menu
LearnBlock.Menu.prototype.attachEvents_ = function () {
    var a = this.getElement();
    this.mouseOverHandler_ = LearnBlock.bindEventWithChecks_(a, "mouseover", this, this.handleMouseOver_, !0);
    this.clickHandler_ = LearnBlock.bindEventWithChecks_(a, "click", this, this.handleClick_, !0);
    this.mouseEnterHandler_ = LearnBlock.bindEventWithChecks_(a, "mouseenter", this, this.handleMouseEnter_, !0);
    this.mouseLeaveHandler_ = LearnBlock.bindEventWithChecks_(a, "mouseleave", this, this.handleMouseLeave_, !0);
    this.onKeyDownWrapper_ = LearnBlock.bindEventWithChecks_(a,
        "keydown", this, this.handleKeyEvent)
};
//Removes the event listeners from the menu
LearnBlock.Menu.prototype.detachEvents_ = function () {
    LearnBlock.unbindEvent_(this.mouseOverHandler_);
    LearnBlock.unbindEvent_(this.clickHandler_);
    LearnBlock.unbindEvent_(this.mouseEnterHandler_);
    LearnBlock.unbindEvent_(this.mouseLeaveHandler_);
    LearnBlock.unbindEvent_(this.onKeyDownWrapper_)
};
//Map of DOM IDs to child menuitems
LearnBlock.Menu.prototype.childElementIdMap_ = null;
//Creates a DOM ID for the child menuitem and registers it
LearnBlock.Menu.prototype.registerChildId_ = function (a) {
    var b = a.getElement();
    b = b.id || (b.id = a.getId());
    this.childElementIdMap_ || (this.childElementIdMap_ = {});
    this.childElementIdMap_[b] = a
};
//Returns the child menuitem that owns the given DOM node
LearnBlock.Menu.prototype.getMenuItem = function (a) {
    if (this.childElementIdMap_)
        for (var b = this.getElement(); a && a !== b;) {
            var c = a.id;
            if (c in this.childElementIdMap_) return this.childElementIdMap_[c];
            a = a.parentNode
        }
    return null
};
//Unhighlights the current highlighted item
LearnBlock.Menu.prototype.unhighlightCurrent = function () {
    var a = this.getHighlighted();
    a && a.setHighlighted(!1)
};
//Clears the currently highlighted item
LearnBlock.Menu.prototype.clearHighlighted = function () {
    this.unhighlightCurrent();
    this.setHighlightedIndex(-1)
};
//Returns the currently highlighted item
LearnBlock.Menu.prototype.getHighlighted = function () {
    return this.getChildAt(this.highlightedIndex_)
};
//Highlights the item at the given 0-based index
LearnBlock.Menu.prototype.setHighlightedIndex = function (a) {
    var b = this.getChildAt(a);
    b ? (b.setHighlighted(!0), this.highlightedIndex_ = a) : -1 < this.highlightedIndex_ && (this.getHighlighted().setHighlighted(!1), this.highlightedIndex_ = -1);
    b && LearnBlock.utils.style.scrollIntoContainerView(b.getElement(), this.getElement())
};
//Highlights the given item if it exists and is a child of the container
LearnBlock.Menu.prototype.setHighlighted = function (a) {
    this.setHighlightedIndex(this.indexOfChild(a))
};
//Highlights the next highlightable item
LearnBlock.Menu.prototype.highlightNext = function () {
    this.unhighlightCurrent();
    this.highlightHelper(function (a, b) {
        return (a + 1) % b
    }, this.highlightedIndex_)
};
//Highlights the previous highlightable item
LearnBlock.Menu.prototype.highlightPrevious = function () {
    this.unhighlightCurrent();
    this.highlightHelper(function (a, b) {
        a--;
        return 0 > a ? b - 1 : a
    }, this.highlightedIndex_)
};
//Helper function that manages the details of moving the highlight among child menuitems in response to keyboard events
LearnBlock.Menu.prototype.highlightHelper = function (a, b) {
    var c = 0 > b ? -1 : b,
        d = this.getChildCount();
    c = a.call(this, c, d);
    for (var e = 0; e <= d;) {
        var f = this.getChildAt(c);
        if (f && this.canHighlightItem(f)) return this.setHighlightedIndex(c), !0;
        e++;
        c = a.call(this, c, d)
    }
    return !1
};
//Returns whether the given item can be highlighted
LearnBlock.Menu.prototype.canHighlightItem = function (a) {
    return true
};
//Handles mouseover events
LearnBlock.Menu.prototype.handleMouseOver_ = function (a) {
    (a = this.getMenuItem(a.target)) && this.getHighlighted() !== a && (this.unhighlightCurrent(), this.setHighlighted(a))
};
//Handles click events
LearnBlock.Menu.prototype.handleClick_ = function (a) {
    var b = this.getMenuItem(a.target);
    b && b.handleClick(a) && a.preventDefault()
};
//Handles mouse enter events
LearnBlock.Menu.prototype.handleMouseEnter_ = function (a) {
    this.focus()
};
//Handles mouse leave events
LearnBlock.Menu.prototype.handleMouseLeave_ = function (a) {
    this.getElement() && (this.blur(), this.clearHighlighted())
};
//Attempts to handle a keyboard event
LearnBlock.Menu.prototype.handleKeyEvent = function (a) {
    return 0 != this.getChildCount() && this.handleKeyEventInternal(a) ? (a.preventDefault(), a.stopPropagation(), !0) : !1
};
//Attempts to handle a keyboard event
LearnBlock.Menu.prototype.handleKeyEventInternal = function (a) {
    var b = this.getHighlighted();
    if (b && "function" == typeof b.handleKeyEvent && b.handleKeyEvent(a)) return !0;
    if (a.shiftKey || a.ctrlKey || a.metaKey || a.altKey) return !1;
    switch (a.keyCode) {
        case LearnBlock.utils.KeyCodes.ENTER:
            b && b.performActionInternal(a);
            break;
        case LearnBlock.utils.KeyCodes.UP:
            this.highlightPrevious();
            break;
        case LearnBlock.utils.KeyCodes.DOWN:
            this.highlightNext();
            break;
        default:
            return !1
    }
    return !0
};

//Class representing an item in a menu
LearnBlock.MenuItem = function (a, b) {
    LearnBlock.Component.call(this);
    this.setContentInternal(a);
    this.setValue(b);
    this.enabled_ = !0
};
LearnBlock.utils.object.inherits(LearnBlock.MenuItem, LearnBlock.Component);
//Creates the menuitem's DOM
LearnBlock.MenuItem.prototype.createDom = function () {
    var a = document.createElement("div");
    a.id = this.getId();
    this.setElementInternal(a);
    a.className = "goog-menuitem goog-option " + (this.enabled_ ? "" : "goog-menuitem-disabled ") + (this.checked_ ? "goog-option-selected " : "") + (this.isRightToLeft() ? "goog-menuitem-rtl " : "");
    var b = this.getContentWrapperDom();
    a.appendChild(b);
    var c = this.getCheckboxDom();
    c && b.appendChild(c);
    if (this.getContentDom() != null){
        b.appendChild(this.getContentDom());
    }
    LearnBlock.utils.aria.setRole(a, this.roleName_ || (this.checkable_ ?
        LearnBlock.utils.aria.Role.MENUITEMCHECKBOX : LearnBlock.utils.aria.Role.MENUITEM));
    LearnBlock.utils.aria.setState(a, LearnBlock.utils.aria.State.SELECTED, this.checkable_ && this.checked_ || !1)
};
//The HTML element for the checkbox
LearnBlock.MenuItem.prototype.getCheckboxDom = function () {
    if (!this.checkable_) return null;
    var a = document.createElement("div");
    a.className = "goog-menuitem-checkbox";
    return a
};
//The HTML for the content
LearnBlock.MenuItem.prototype.getContentDom = function () {
    var a = this.content_;
    "string" === typeof a && (a = document.createTextNode(a));
    return a
};
//The HTML for the content wrapper
LearnBlock.MenuItem.prototype.getContentWrapperDom = function () {
    var a = document.createElement("div");
    a.className = "goog-menuitem-content";
    return a
};
//Sets the content associated with the menu item
LearnBlock.MenuItem.prototype.setContentInternal = function (a) {
    this.content_ = a
};
//Sets the value associated with the menu item
LearnBlock.MenuItem.prototype.setValue = function (a) {
    this.value_ = a
};
//Gets the value associated with the menu item
LearnBlock.MenuItem.prototype.getValue = function () {
    return this.value_
};
//Sets the menu accessibility role
LearnBlock.MenuItem.prototype.setRole = function (a) {
    this.roleName_ = a
};
//Sets the menu item to be checkable or not
LearnBlock.MenuItem.prototype.setCheckable = function (a) {
    this.checkable_ = a
};
//Checks or unchecks the component
LearnBlock.MenuItem.prototype.setChecked = function (a) {
    if (this.checkable_) {
        this.checked_ = a;
        var b = this.getElement();
        b && (a ? (LearnBlock.utils.dom.addClass(b, "goog-option-selected"), LearnBlock.utils.aria.setState(b, LearnBlock.utils.aria.State.SELECTED, !0)) : (LearnBlock.utils.dom.removeClass(b, "goog-option-selected"), LearnBlock.utils.aria.setState(b, LearnBlock.utils.aria.State.SELECTED, !1)))
    }
};
//Highlights or unhighlights the component
LearnBlock.MenuItem.prototype.setHighlighted = function (a) {
    this.highlight_ = a;
    var b = this.getElement();
    b && (a ? LearnBlock.utils.dom.addClass(b, "goog-menuitem-highlight") : LearnBlock.utils.dom.removeClass(b, "goog-menuitem-highlight"))
};
//Returns true if the menu item is enabled, false otherwise
LearnBlock.MenuItem.prototype.isEnabled = function () {
    return this.enabled_
};
//Enables or disables the menu item
LearnBlock.MenuItem.prototype.setEnabled = function (a) {
    this.enabled_ = a;
    (a = this.getElement()) && (this.enabled_ ? LearnBlock.utils.dom.removeClass(a, "goog-menuitem-disabled") : LearnBlock.utils.dom.addClass(a, "goog-menuitem-disabled"))
};
//Handles click events
LearnBlock.MenuItem.prototype.handleClick = function (a) {
    this.setHighlighted(!0);
    this.performActionInternal()
};
//Performs the appropriate action when the menu item is activated hy the user
LearnBlock.MenuItem.prototype.performActionInternal = function () {
    this.checkable_ && this.setChecked(!this.checked_);
    this.actionHandler_ && this.actionHandler_.call(this.actionHandlerObj_, this)
};
//Sets the handler that's triggered when the menu item is activated by the user
LearnBlock.MenuItem.prototype.onAction = function (a, b) {
    this.actionHandler_ = a;
    this.actionHandlerObj_ = b
};

//Class for a UI menu
LearnBlock.utils.uiMenu = {};
//Gets the size of a rendered ui menu
LearnBlock.utils.uiMenu.getSize = function (a) {
    a = a.getElement();
    var b = LearnBlock.utils.style.getSize(a);
    b.height = a.scrollHeight;
    return b
};
//Adjusts the bounding boxes used to position the widget div
LearnBlock.utils.uiMenu.adjustBBoxesForRTL = function (a, b, c) {
    b.left += c.width;
    b.right += c.width;
    a.left += c.width;
    a.right += c.width
};

//Context menu (right click)
LearnBlock.ContextMenu = {};
LearnBlock.ContextMenu.currentBlock = null;
LearnBlock.ContextMenu.eventWrapper_ = null;
//Constructs and shows the menu
LearnBlock.ContextMenu.show = function (a, b, c) {
    LearnBlock.WidgetDiv.show(LearnBlock.ContextMenu, c, null);
    if (b.length) {
        var d = LearnBlock.ContextMenu.populate_(b, c);
        LearnBlock.ContextMenu.position_(d, a, c);
        setTimeout(function () {
            d.getElement().focus()
        }, 1);
        LearnBlock.ContextMenu.currentBlock = null
    } else LearnBlock.ContextMenu.hide()
};
//Inserts the options in the menu
LearnBlock.ContextMenu.populate_ = function (a, b) {
    var c = new LearnBlock.Menu;
    c.setRightToLeft(b);
    for (var d = 0, e; e = a[d]; d++) {
        var f = new LearnBlock.MenuItem(e.text);
        f.setRightToLeft(b);
        c.addChild(f, !0);
        f.onAction(function () {
            LearnBlock.ContextMenu.hide();
            this.callback()
        }, e)
    }
    return c
};
//Adds the menu and positions it
LearnBlock.ContextMenu.position_ = function (a, b, c) {
    var d = LearnBlock.utils.getViewportBBox();
    b = {
        top: b.clientY + d.top,
        bottom: b.clientY + d.top,
        left: b.clientX + d.left,
        right: b.clientX + d.left
    };
    LearnBlock.ContextMenu.createWidget_(a);
    var e = LearnBlock.utils.uiMenu.getSize(a);
    c && LearnBlock.utils.uiMenu.adjustBBoxesForRTL(d, b, e);
    LearnBlock.WidgetDiv.positionWithAnchor(d, b, e, c);
    a.getElement().focus()
};
//Creates and renders the widget
LearnBlock.ContextMenu.createWidget_ = function (a) {
    a.render(LearnBlock.WidgetDiv.DIV);
    var b = a.getElement();
    LearnBlock.utils.dom.addClass(b, "blocklyContextMenu");
    LearnBlock.bindEventWithChecks_(b, "contextmenu", null, LearnBlock.utils.noEvent);
    a.focus()
};
//Hides the menu
LearnBlock.ContextMenu.hide = function () {
    LearnBlock.WidgetDiv.hideIfOwner(LearnBlock.ContextMenu);
    LearnBlock.ContextMenu.currentBlock = null;
    LearnBlock.ContextMenu.eventWrapper_ && LearnBlock.unbindEvent_(LearnBlock.ContextMenu.eventWrapper_)
};
//Callback functions that creates and configures a block. Places it next to the original block
LearnBlock.ContextMenu.callbackFactory = function (a, b) {
    return function () {
        LearnBlock.Events.disable();
        try {
            var c = LearnBlock.Xml.domToBlock(b, a.workspace),
                d = a.getRelativeToSurfaceXY();
            d.x = a.RTL ? d.x - LearnBlock.SNAP_RADIUS : d.x + LearnBlock.SNAP_RADIUS;
            d.y += 2 * LearnBlock.SNAP_RADIUS;
            c.moveBy(d.x, d.y)
        } finally {
            LearnBlock.Events.enable()
        }
        LearnBlock.Events.isEnabled() && !c.isShadow() && LearnBlock.Events.fire(new LearnBlock.Events.BlockCreate(c));
        c.select()
    }
};
//Deletes the block
LearnBlock.ContextMenu.blockDeleteOption = function (a) {
    //Counts the number of blocks attached to the current block
    var b = a.getDescendants(!1).length,
        c = a.getNextBlock();
    c && (b -= c.getDescendants(!1).length);
    return {
        text: 1 == b ? LearnBlock.Msg.DELETE_BLOCK : LearnBlock.Msg.DELETE_X_BLOCKS.replace("%1", String(b)),
        enabled: !0,
        callback: function () {
            LearnBlock.Events.setGroup(!0);
            a.dispose(!0, !0);
            LearnBlock.Events.setGroup(!1)
        }
    }
};
//Duplicates the block
LearnBlock.ContextMenu.blockDuplicateOption = function (a) {
    var b = a.isDuplicatable();
    return {
        text: LearnBlock.Msg.DUPLICATE_BLOCK,
        enabled: b,
        callback: function () {
            LearnBlock.duplicate_(a)
        }
    }
};

//Class for a connection between blocks that may be rendered on screen
LearnBlock.RenderedConnection = function (a, b) {
    LearnBlock.RenderedConnection.superClass_.constructor.call(this, a, b);
    this.db_ = a.workspace.connectionDBList[b];
    this.dbOpposite_ = a.workspace.connectionDBList[LearnBlock.OPPOSITE_TYPE[b]];
    this.offsetInBlock_ = new LearnBlock.utils.Coordinate(0, 0);
    this.inDB_ = !1;
    this.hidden_ = !this.db_
};
LearnBlock.utils.object.inherits(LearnBlock.RenderedConnection, LearnBlock.Connection);
LearnBlock.RenderedConnection.prototype.dispose = function () {
    LearnBlock.RenderedConnection.superClass_.dispose.call(this);
    this.inDB_ && this.db_.removeConnection_(this)
};
//Returns the distance between a connection and another
LearnBlock.RenderedConnection.prototype.distanceFrom = function (a) {
    var b = this.x_ - a.x_;
    a = this.y_ - a.y_;
    return Math.sqrt(b * b + a * a)
};
//Moves the block(s) belonging to the connection to a point where they don't visually interfere with the specified connection
LearnBlock.RenderedConnection.prototype.bumpAwayFrom_ = function (a) {
    if (!this.sourceBlock_.workspace.isDragging()) {
        var b = this.sourceBlock_.getRootBlock();
        if (!b.isInFlyout) {
            var c = !1;
            if (!b.isMovable()) {
                b = a.getSourceBlock().getRootBlock();
                if (!b.isMovable()) return;
                a = this;
                c = !0
            }
            var d = LearnBlock.selected == b;
            d || b.addSelect();
            var e = a.x_ + LearnBlock.SNAP_RADIUS + Math.floor(Math.random() * LearnBlock.BUMP_RANDOMNESS) - this.x_,
                f = a.y_ + LearnBlock.SNAP_RADIUS + Math.floor(Math.random() * LearnBlock.BUMP_RANDOMNESS) - this.y_;
            c && (f = -f);
            b.RTL &&
                (e = a.x_ - LearnBlock.SNAP_RADIUS - Math.floor(Math.random() * LearnBlock.BUMP_RANDOMNESS) - this.x_);
            b.moveBy(e, f);
            d || b.removeSelect()
        }
    }
};
//Changes the connection's coordinates in absolute coordinates
LearnBlock.RenderedConnection.prototype.moveTo = function (a, b) {
    this.inDB_ && this.db_.removeConnection_(this);
    this.x_ = a;
    this.y_ = b;
    this.hidden_ || this.db_.addConnection(this)
};
//Changes the connection's coordinates
LearnBlock.RenderedConnection.prototype.moveBy = function (a, b) {
    this.moveTo(this.x_ + a, this.y_ + b)
};
//Moves the connection to the location given by its offset
LearnBlock.RenderedConnection.prototype.moveToOffset = function (a) {
    this.moveTo(a.x + this.offsetInBlock_.x, a.y + this.offsetInBlock_.y)
};
//Sets the offset of the connection relative to the top left of its block
LearnBlock.RenderedConnection.prototype.setOffsetInBlock = function (a, b) {
    this.offsetInBlock_.x = a;
    this.offsetInBlock_.y = b
};
//Gets the offset of the connection relative to the top left of its block
LearnBlock.RenderedConnection.prototype.getOffsetInBlock = function () {
    return this.offsetInBlock_
};
//Moves the blocks on either side of the connection right next to each other
LearnBlock.RenderedConnection.prototype.tighten_ = function () {
    var a = this.targetConnection.x_ - this.x_,
        b = this.targetConnection.y_ - this.y_;
    if (0 != a || 0 != b) {
        var c = this.targetBlock(),
            d = c.getSvgRoot();
        if (!d) throw Error("block is not rendered.");
        d = LearnBlock.utils.getRelativeXY(d);
        c.getSvgRoot().setAttribute("transform", "translate(" + (d.x - a) + "," + (d.y - b) + ")");
        c.moveConnections_(-a, -b)
    }
};
//Finds the closest compatible connection to the connection
LearnBlock.RenderedConnection.prototype.closest = function (a, b) {
    return this.dbOpposite_.searchForClosest(this, a, b)
};
//Adds highlighting around this connection
LearnBlock.RenderedConnection.prototype.highlight = function () {
    var a = this.sourceBlock_.workspace.getRenderer().getConstants();
    a = this.type == LearnBlock.INPUT_VALUE || this.type == LearnBlock.OUTPUT_VALUE ? LearnBlock.utils.svgPaths.moveBy(0, -5) + LearnBlock.utils.svgPaths.lineOnAxis("v", 5) + a.PUZZLE_TAB.pathDown + LearnBlock.utils.svgPaths.lineOnAxis("v", 5) : LearnBlock.utils.svgPaths.moveBy(-5, 0) + LearnBlock.utils.svgPaths.lineOnAxis("h", 5) + a.NOTCH.pathLeft + LearnBlock.utils.svgPaths.lineOnAxis("h", 5);
    var b = this.sourceBlock_.getRelativeToSurfaceXY();
    LearnBlock.Connection.highlightedPath_ = LearnBlock.utils.dom.createSvgElement("path", {
        "class": "blocklyHighlightedConnectionPath",
        d: a,
        transform: "translate(" + (this.x_ - b.x) + "," + (this.y_ - b.y) + ")" + (this.sourceBlock_.RTL ? " scale(-1 1)" : "")
    }, this.sourceBlock_.getSvgRoot())
};
//Unhides the connection
LearnBlock.RenderedConnection.prototype.unhideAll = function () {
    this.setHidden(!1);
    var a = [];
    if (this.type != LearnBlock.INPUT_VALUE && this.type != LearnBlock.NEXT_STATEMENT) return a;
    var b = this.targetBlock();
    if (b) {
        if (b.isCollapsed()) {
            var c = [];
            b.outputConnection && c.push(b.outputConnection);
            b.nextConnection && c.push(b.nextConnection);
            b.previousConnection && c.push(b.previousConnection)
        } else c = b.getConnections_(!0);
        for (var d = 0; d < c.length; d++) a.push.apply(a, c[d].unhideAll());
        a.length || (a[0] = b)
    }
    return a
};
//Removes the highlighting around the connection
LearnBlock.RenderedConnection.prototype.unhighlight = function () {
    LearnBlock.utils.dom.removeNode(LearnBlock.Connection.highlightedPath_);
    delete LearnBlock.Connection.highlightedPath_
};
//Sets whether the connections is hidden or not
LearnBlock.RenderedConnection.prototype.setHidden = function (a) {
    (this.hidden_ = a) && this.inDB_ ? this.db_.removeConnection_(this) : a || this.inDB_ || this.db_.addConnection(this)
};
//Hides the connection
LearnBlock.RenderedConnection.prototype.hideAll = function () {
    this.setHidden(!0);
    if (this.targetConnection)
        for (var a = this.targetBlock().getDescendants(!1), b = 0; b < a.length; b++) {
            for (var c = a[b], d = c.getConnections_(!0), e = 0; e < d.length; e++) d[e].setHidden(!0);
        }
};
//Checks if two connections can be dragged to connect to each other
LearnBlock.RenderedConnection.prototype.isConnectionAllowed = function (a, b) {
    return this.distanceFrom(a) > b ? !1 : LearnBlock.RenderedConnection.superClass_.isConnectionAllowed.call(this, a)
};
//Behavior after a connection attempt fails
LearnBlock.RenderedConnection.prototype.onFailedConnect = function (a) {
    this.bumpAwayFrom_(a)
};
//Disconnects two blocks that are connected
LearnBlock.RenderedConnection.prototype.disconnectInternal_ = function (a, b) {
    LearnBlock.RenderedConnection.superClass_.disconnectInternal_.call(this, a, b);
    a.rendered && a.render();
    b.rendered && b.render()
};
//Finds all nearby compatible connections to the connection
LearnBlock.RenderedConnection.prototype.neighbours_ = function (a) {
    return this.dbOpposite_.getNeighbours(this, a)
};
//Connects two connections together
LearnBlock.RenderedConnection.prototype.connect_ = function (a) {
    LearnBlock.RenderedConnection.superClass_.connect_.call(this, a);
    var b = this.getSourceBlock();
    a = a.getSourceBlock();
    b.rendered && a.rendered && (this.type == LearnBlock.NEXT_STATEMENT || this.type == LearnBlock.PREVIOUS_STATEMENT ? a.render() : b.render())
};
//Function to be called when this connection's compatible types have changed
LearnBlock.RenderedConnection.prototype.onCheckChanged_ = function () {
    this.isConnected() && !this.checkType_(this.targetConnection) && ((this.isSuperior() ? this.targetBlock() : this.sourceBlock_).unplug(), this.sourceBlock_.bumpNeighbours())
};

//Class for representing rectangular regions
LearnBlock.utils.Rect = function (a, b, c, d) {
    this.top = a;
    this.bottom = b;
    this.left = c;
    this.right = d
};
//Tests whether the rectangle contains a x/y coordinate
LearnBlock.utils.Rect.prototype.contains = function (a, b) {
    return a >= this.left && a <= this.right && b >= this.top && b <= this.bottom
};

//Block_svg
LearnBlock.BlockSvg = function (a, b, c) {
    this.svgGroup_ = LearnBlock.utils.dom.createSvgElement("g", {}, null);
    this.svgGroup_.translate_ = "";
    this.pathObject = a.getRenderer().makePathObject(this.svgGroup_);
    this.svgPathDark_ = this.pathObject.svgPathDark || null;
    this.svgPath_ = this.pathObject.svgPath || null;
    this.svgPathLight_ = this.pathObject.svgPathLight || null;
    this.svgPath_.tooltip = this;
    this.rendered = !1;
    this.useDragSurface_ = LearnBlock.utils.is3dSupported() && !!a.blockDragSurface_;
    LearnBlock.BlockSvg.superClass_.constructor.call(this, a, b, c);
    this.svgGroup_.dataset && (this.svgGroup_.dataset.id = this.id);
    this.markerSvg_ = this.cursorSvg_ = null
};
LearnBlock.utils.object.inherits(LearnBlock.BlockSvg, LearnBlock.Block);
LearnBlock.BlockSvg.prototype.height = 0;
LearnBlock.BlockSvg.prototype.width = 0;
LearnBlock.BlockSvg.prototype.dragStartXY_ = null;
LearnBlock.BlockSvg.prototype.warningTextDb_ = null;
LearnBlock.BlockSvg.INLINE = -1;
LearnBlock.BlockSvg.COLLAPSED_WARNING_ID = "TEMP_COLLAPSED_WARNING_";
LearnBlock.BlockSvg.SEP_SPACE_Y = 10;
LearnBlock.BlockSvg.MIN_BLOCK_Y = 25;
LearnBlock.BlockSvg.TAB_WIDTH = 8;
LearnBlock.BlockSvg.START_HAT = !1;
//Creates the svg representation of the block
LearnBlock.BlockSvg.prototype.initSvg = function () {
    if (!this.workspace.rendered) throw TypeError("Workspace is headless.");
    for (var a = 0, b; b = this.inputList[a]; a++) b.init();
    this.updateColour();
    this.updateMovable();
    this.workspace.options.readOnly || this.eventsInit_ || LearnBlock.bindEventWithChecks_(this.getSvgRoot(), "mousedown", this, this.onMouseDown_);
    this.eventsInit_ = !0;
    this.getSvgRoot().parentNode || this.workspace.getCanvas().appendChild(this.getSvgRoot())
};
//Selects the block
LearnBlock.BlockSvg.prototype.select = function () {
    if (LearnBlock.selected != this) {
        var a = null;
        if (LearnBlock.selected) {
            a = LearnBlock.selected.id;
            LearnBlock.Events.disable();
            try {
                LearnBlock.selected.unselect()
            } finally {
                LearnBlock.Events.enable()
            }
        }
        a = new LearnBlock.Events.Ui(null, "selected", a, this.id);
        a.workspaceId = this.workspace.id;
        LearnBlock.Events.fire(a);
        LearnBlock.selected = this;
        this.addSelect()
    }
};
//Unselects the block
LearnBlock.BlockSvg.prototype.unselect = function () {
    if (LearnBlock.selected == this) {
        var a = new LearnBlock.Events.Ui(null, "selected", this.id, null);
        a.workspaceId = this.workspace.id;
        LearnBlock.Events.fire(a);
        LearnBlock.selected = null;
        this.removeSelect()
    }
};
//Sets parent of the current block
LearnBlock.BlockSvg.prototype.setParent = function (a) {
    var b = this.parentBlock_;
    if (a != b) {
        LearnBlock.utils.dom.startTextWidthCache();
        LearnBlock.BlockSvg.superClass_.setParent.call(this, a);
        LearnBlock.utils.dom.stopTextWidthCache();
        var c = this.getSvgRoot();
        if (!this.workspace.isClearing && c) {
            var d = this.getRelativeToSurfaceXY();
            a ? (a.getSvgRoot().appendChild(c), a = this.getRelativeToSurfaceXY(), this.moveConnections_(a.x - d.x, a.y - d.y)) : b && (this.workspace.getCanvas().appendChild(c), this.translate(d.x, d.y))
        }
    }
};
//Returns coordinates of the top-left corner of the current block
LearnBlock.BlockSvg.prototype.getRelativeToSurfaceXY = function () {
    var a = 0,
        b = 0,
        c = this.useDragSurface_ ? this.workspace.blockDragSurface_.getGroup() : null,
        d = this.getSvgRoot();
    if (d) {
        do {
            var e = LearnBlock.utils.getRelativeXY(d);
            a += e.x;
            b += e.y;
            this.useDragSurface_ && this.workspace.blockDragSurface_.getCurrentBlock() == d && (e = this.workspace.blockDragSurface_.getSurfaceTranslation(), a += e.x, b += e.y);
            d = d.parentNode
        } while (d && d != this.workspace.getCanvas() && d != c)
    }
    return new LearnBlock.utils.Coordinate(a, b)
};
//Moves block by a relative offset
LearnBlock.BlockSvg.prototype.moveBy = function (a, b) {
    //a: horizontal offset
    //b: vertical offset
    if (this.parentBlock_) throw Error("Block has parent.");
    var c = LearnBlock.Events.isEnabled();
    if (c) var d = new LearnBlock.Events.BlockMove(this);
    var e = this.getRelativeToSurfaceXY();
    this.translate(e.x + a, e.y + b);
    this.moveConnections_(a, b);
    c && (d.recordNew(), LearnBlock.Events.fire(d));
    this.workspace.resizeContents()
};
//Transforms the block
LearnBlock.BlockSvg.prototype.translate = function (a, b) {
    this.getSvgRoot().setAttribute("transform", "translate(" + a + "," + b + ")")
};
//Moves the block to the workspace's drag surface
LearnBlock.BlockSvg.prototype.moveToDragSurface_ = function () {
    if (this.useDragSurface_) {
        var a = this.getRelativeToSurfaceXY();
        this.clearTransformAttributes_();
        this.workspace.blockDragSurface_.translateSurface(a.x, a.y);
        this.workspace.blockDragSurface_.setBlocksAndShow(this.getSvgRoot())
    }
};
//Moves a block to a position
LearnBlock.BlockSvg.prototype.moveTo = function (a) {
    var b = this.getRelativeToSurfaceXY();
    this.moveBy(a.x - b.x, a.y - b.y)
};
//Moves the block back to the workspace block canvas
LearnBlock.BlockSvg.prototype.moveOffDragSurface_ = function (a) {
    this.useDragSurface_ && (this.translate(a.x, a.y), this.workspace.blockDragSurface_.clearAndHide(this.workspace.getCanvas()))
};
//Moves the block during a drag
LearnBlock.BlockSvg.prototype.moveDuringDrag = function (a) {
    this.useDragSurface_ ? this.workspace.blockDragSurface_.translateSurface(a.x, a.y) : (this.svgGroup_.translate_ = "translate(" + a.x + "," + a.y + ")", this.svgGroup_.setAttribute("transform", this.svgGroup_.translate_ + this.svgGroup_.skew_))
};
//Clears the block of "transform" attributes
LearnBlock.BlockSvg.prototype.clearTransformAttributes_ = function () {
    this.getSvgRoot().removeAttribute("transform")
};
//Snaps the block to the nearest grid point
LearnBlock.BlockSvg.prototype.snapToGrid = function () {
    //Not deleted blocks, don't bump blocks during a drag, only top-level blocks, don't move blocks around in a flyout
    if (this.workspace && !this.workspace.isDragging() && !this.getParent() && !this.isInFlyout) {
        var a = this.workspace.getGrid();
        if (a && a.shouldSnap()) {
            var b = a.getSpacing(),
                c = b / 2,
                d = this.getRelativeToSurfaceXY();
            a = Math.round((d.x - c) / b) * b + c - d.x;
            b = Math.round((d.y - c) / b) * b + c - d.y;
            a = Math.round(a);
            b = Math.round(b);
            0 == a && 0 == b || this.moveBy(a, b)
        }
    }
};
//Returns the coordinates of a bounding box describing the dimensions of the block
LearnBlock.BlockSvg.prototype.getBoundingRectangle = function () {
    var a = this.getRelativeToSurfaceXY(this),
        b = this.outputConnection ? LearnBlock.BlockSvg.TAB_WIDTH : 0,
        c = this.getHeightWidth(),
        d = a.y,
        e = a.y + c.height;
    if (this.RTL) {
        var f = a.x - (c.width - b);
        a = a.x + b
    } else f = a.x - b, a = a.x + c.width - b;
    return new LearnBlock.utils.Rect(d, e, f, a)
};
//Notifies every input on the block
LearnBlock.BlockSvg.prototype.markDirty = function () {
    for (var a = 0, b; b = this.inputList[a]; a++) b.markDirty()
};
//Handles a mouse-down on an svg block
LearnBlock.BlockSvg.prototype.onMouseDown_ = function (a) {
    var b = this.workspace && this.workspace.getGesture(a);
    b && b.handleBlockStart(a, this)
};
//Generates the context menu for the current block
LearnBlock.BlockSvg.prototype.generateContextMenu = function () {
    if (this.workspace.options.readOnly || !this.contextMenu) return null;
    var a = this,
        b = [],
        c;
    if (!this.isInFlyout) {
        this.isDeletable() && this.isMovable() && b.push(LearnBlock.ContextMenu.blockDuplicateOption(a));
        this.isDeletable() && b.push(LearnBlock.ContextMenu.blockDeleteOption(a))
    }
    this.customContextMenu && this.customContextMenu(b);
    return b
};
//Shows the context menu for the current block
LearnBlock.BlockSvg.prototype.showContextMenu_ = function (a) {
    var b = this.generateContextMenu();
    b && b.length && (LearnBlock.ContextMenu.show(a, b, this.RTL), LearnBlock.ContextMenu.currentBlock = this)
};
//Moves connections for the current block and the blocks attached to it
LearnBlock.BlockSvg.prototype.moveConnections_ = function (a, b) {
    if (this.rendered) {
        for (var c = this.getConnections_(!1), d = 0; d < c.length; d++) c[d].moveBy(a, b);
        for (d = 0; d < this.childBlocks_.length; d++) this.childBlocks_[d].moveConnections_(a, b)
    }
};
//Adds or removes the dragging class to the current node and its children
LearnBlock.BlockSvg.prototype.setDragging = function (a) {
    if (a) {
        var b = this.getSvgRoot();
        b.translate_ = "";
        b.skew_ = "";
        LearnBlock.draggingConnections_ = LearnBlock.draggingConnections_.concat(this.getConnections_(!0));
        LearnBlock.utils.dom.addClass(this.svgGroup_, "blocklyDragging")
    } else LearnBlock.draggingConnections_ = [], LearnBlock.utils.dom.removeClass(this.svgGroup_, "blocklyDragging");
    for (b = 0; b < this.childBlocks_.length; b++) this.childBlocks_[b].setDragging(a)
};
//Updates the movility of a block
LearnBlock.BlockSvg.prototype.updateMovable = function () {
    this.isMovable() ? LearnBlock.utils.dom.addClass(this.svgGroup_, "blocklyDraggable") : LearnBlock.utils.dom.removeClass(this.svgGroup_, "blocklyDraggable")
};
//Sets whether the block is movable or not
LearnBlock.BlockSvg.prototype.setMovable = function (a) {
    LearnBlock.BlockSvg.superClass_.setMovable.call(this, a);
    this.updateMovable()
};
//Sets whether the block is editable or not
LearnBlock.BlockSvg.prototype.setEditable = function (a) {
    LearnBlock.BlockSvg.superClass_.setEditable.call(this, a);
    for (var b = 0; b < a.length; b++) a[b].updateEditable()
};
//Sets whether the block is an insertion marker block or not
LearnBlock.BlockSvg.prototype.setInsertionMarker = function (a) {
    this.isInsertionMarker_ != a && (this.isInsertionMarker_ = a) && (this.setColour(LearnBlock.INSERTION_MARKER_COLOUR), LearnBlock.utils.dom.addClass(this.svgGroup_, "blocklyInsertionMarker"))
};
//Returns the root node of the svg
LearnBlock.BlockSvg.prototype.getSvgRoot = function () {
    return this.svgGroup_
};
//Disposes the block
LearnBlock.BlockSvg.prototype.dispose = function (a, b) {
    if (this.workspace) {
        LearnBlock.utils.dom.startTextWidthCache();
        var c = this.workspace;
        LearnBlock.selected == this && (this.unselect(), this.workspace.cancelCurrentGesture());
        LearnBlock.ContextMenu.currentBlock == this && LearnBlock.ContextMenu.hide();
        LearnBlock.keyboardAccessibilityMode && LearnBlock.navigation.moveCursorOnBlockDelete(this);
        b && this.rendered && (this.unplug(a), LearnBlock.blockAnimations.disposeUiEffect(this));
        this.rendered = !1;
        if (this.warningTextDb_) {
            for (var d in this.warningTextDb_) clearTimeout(this.warningTextDb_[d]);
            this.warningTextDb_ = null
        }
        LearnBlock.BlockSvg.superClass_.dispose.call(this, a);
        LearnBlock.utils.dom.removeNode(this.svgGroup_);
        c.resizeContents();
        this.svgPathDark_ = this.svgPathLight_ = this.svgPath_ = this.svgGroup_ = null;
        LearnBlock.utils.dom.stopTextWidthCache()
    }
};
//Changes the colour
LearnBlock.BlockSvg.prototype.updateColour = function () {
    this.setBorderColour_();
    this.svgPath_.setAttribute("fill", this.getColour());
    var b = 0;
    for (var a = 0; b = this.inputList[a]; a++)
        for (var c = 0, d; d = b.fieldRow[c]; c++) d.updateColour()
};
//Sets the border colour
LearnBlock.BlockSvg.prototype.setBorderColour_ = function () {
    var a = this.getColourBorder();
    a.colourBorder ? (this.svgPathLight_.style.display = "none", this.svgPathDark_.style.display = "none", this.svgPath_.setAttribute("stroke", a.colourBorder)) : (this.svgPathLight_.style.display = "", this.svgPathDark_.style.display = "", this.svgPath_.setAttribute("stroke", "none"), this.svgPathLight_.setAttribute("stroke", a.colourLight), this.svgPathDark_.setAttribute("fill", a.colourDark))
};
//Sets whether the block is highlighted or not
LearnBlock.BlockSvg.prototype.setHighlighted = function (a) {
    this.rendered && (a ? (this.svgPath_.setAttribute("filter", "url(#" + this.workspace.options.embossFilterId + ")"), this.svgPathLight_.style.display = "none") : (this.svgPath_.setAttribute("filter", "none"), this.svgPathLight_.style.display = "inline"))
};
//Selects the block
LearnBlock.BlockSvg.prototype.addSelect = function () {
    LearnBlock.utils.dom.addClass(this.svgGroup_, "blocklySelected")
};
//Unselects the block
LearnBlock.BlockSvg.prototype.removeSelect = function () {
    LearnBlock.utils.dom.removeClass(this.svgGroup_, "blocklySelected")
};
//Changes the colour
LearnBlock.BlockSvg.prototype.setColour = function (a) {
    LearnBlock.BlockSvg.superClass_.setColour.call(this, a);
    this.rendered && this.updateColour()
};
//Moves the block to the front of the visible workspace
LearnBlock.BlockSvg.prototype.bringToFront = function () {
    var a = this;
    do {
        var b = a.getSvgRoot();
        b.parentNode.appendChild(b);
        a = a.getParent()
    } while (a)
};
//Sets whether the block can chain onto the bottom of another block
LearnBlock.BlockSvg.prototype.setPreviousStatement = function (a, b) {
    LearnBlock.BlockSvg.superClass_.setPreviousStatement.call(this, a, b);
    this.rendered && (this.render(), this.bumpNeighbours())
};
//Sets whether another block can chain onto the bottom of this block
LearnBlock.BlockSvg.prototype.setNextStatement = function (a, b) {
    LearnBlock.BlockSvg.superClass_.setNextStatement.call(this, a, b);
    this.rendered && (this.render(), this.bumpNeighbours())
};
//Sets whether this block returns a value
LearnBlock.BlockSvg.prototype.setOutput = function (a, b) {
    LearnBlock.BlockSvg.superClass_.setOutput.call(this, a, b);
    this.rendered && (this.render(), this.bumpNeighbours())
};
//Sets whether value inputs are arranged horizontally or vertically
LearnBlock.BlockSvg.prototype.setInputsInline = function (a) {
    LearnBlock.BlockSvg.superClass_.setInputsInline.call(this, a);
    this.rendered && (this.render(), this.bumpNeighbours())
};
//Removes an input from this block
LearnBlock.BlockSvg.prototype.removeInput = function (a, b) {
    LearnBlock.BlockSvg.superClass_.removeInput.call(this, a, b);
    this.rendered && (this.render(), this.bumpNeighbours())
};
//Moves a numbered input to a different location on this block
LearnBlock.BlockSvg.prototype.moveNumberedInputBefore = function (a, b) {
    LearnBlock.BlockSvg.superClass_.moveNumberedInputBefore.call(this, a, b);
    this.rendered && (this.render(), this.bumpNeighbours())
};
//Adds a value input, statement input or local variable to this block
LearnBlock.BlockSvg.prototype.appendInput_ = function (a, b) {
    var c = LearnBlock.BlockSvg.superClass_.appendInput_.call(this, a, b);
    this.rendered && (this.render(), this.bumpNeighbours());
    return c
};
//Sets whether the connections are hidden or not
LearnBlock.BlockSvg.prototype.setConnectionsHidden = function (a) {
    var b;
    for (var c = this.getConnections_(!0), d = 0; b = c[d]; d++) b.setHidden(a), b.isSuperior() && (b = b.targetBlock()) && b.setConnectionsHidden(a)

};
//Returns connections originating from this block
LearnBlock.BlockSvg.prototype.getConnections_ = function (a) {
    var b = [];
    if (a || this.rendered)
        if (this.outputConnection && b.push(this.outputConnection), this.previousConnection && b.push(this.previousConnection), this.nextConnection && b.push(this.nextConnection), a || !this.collapsed_) {
            a = 0;
            for (var c; c = this.inputList[a]; a++) c.connection && b.push(c.connection)
        } return b
};
//Creates a connection of the specified type
LearnBlock.BlockSvg.prototype.makeConnection_ = function (a) {
    return new LearnBlock.RenderedConnection(this, a)
};
//Bumps unconnected blocks out of alignment
LearnBlock.BlockSvg.prototype.bumpNeighbours = function () {
    if (this.workspace && !this.workspace.isDragging()) {
        var a = this.getRootBlock();
        if (!a.isInFlyout)
            for (var b = this.getConnections_(!1), c = 0, d; d = b[c]; c++) {
                d.isConnected() && d.isSuperior() && d.targetBlock().bumpNeighbours();
                for (var e = d.neighbours_(LearnBlock.SNAP_RADIUS), f = 0, g; g = e[f]; f++) d.isConnected() && g.isConnected() || g.getSourceBlock().getRootBlock() != a && (d.isSuperior() ? g.bumpAwayFrom_(d) : d.bumpAwayFrom_(g))
            }
    }
};
//Schedules snapping to grid and bumping neighbours to occur after a brief delay
LearnBlock.BlockSvg.prototype.scheduleSnapAndBump = function () {
    var a = this,
        b = LearnBlock.Events.getGroup();
    setTimeout(function () {
        LearnBlock.Events.setGroup(b);
        a.snapToGrid();
        LearnBlock.Events.setGroup(!1)
    }, LearnBlock.BUMP_DELAY / 2);
    setTimeout(function () {
        LearnBlock.Events.setGroup(b);
        a.bumpNeighbours();
        LearnBlock.Events.setGroup(!1)
    }, LearnBlock.BUMP_DELAY)
};
//Positions a block so that it doesn't move the target block when connected
LearnBlock.BlockSvg.prototype.positionNearConnection = function (a, b) {
    a.type != LearnBlock.NEXT_STATEMENT && a.type != LearnBlock.INPUT_VALUE || this.moveBy(b.x_ - a.x_, b.y_ - a.y_)
};
//Renders the block
LearnBlock.BlockSvg.prototype.render = function (a) {
    LearnBlock.utils.dom.startTextWidthCache();
    this.rendered = !0;
    this.workspace.getRenderer().render(this);
    this.updateConnectionLocations_();
    !1 !== a && ((a = this.getParent()) ? a.render(!0) : this.workspace.resizeContents());
    LearnBlock.utils.dom.stopTextWidthCache()
};
//Updates all of the connections on the block with the new locations calculated during rendering
LearnBlock.BlockSvg.prototype.updateConnectionLocations_ = function () {
    var a = this.getRelativeToSurfaceXY();
    this.previousConnection && this.previousConnection.moveToOffset(a);
    this.outputConnection && this.outputConnection.moveToOffset(a);
    for (var b = 0; b < this.inputList.length; b++) {
        var c = this.inputList[b].connection;
        c && (c.moveToOffset(a), c.isConnected() && c.tighten_())
    }
    this.nextConnection && (this.nextConnection.moveToOffset(a), this.nextConnection.isConnected() && this.nextConnection.tighten_())
};
//Adds the cursor svg to this block's svg group
LearnBlock.BlockSvg.prototype.setCursorSvg = function (a) {
    a ? (this.svgGroup_.appendChild(a), this.cursorSvg_ = a) : this.cursorSvg_ = null
};
//Adds the marker svg to this block's svg group
LearnBlock.BlockSvg.prototype.setMarkerSvg = function (a) {
    a ? (this.cursorSvg_ ? this.svgGroup_.insertBefore(a, this.cursorSvg_) : this.svgGroup_.appendChild(a), this.markerSvg_ = a) : this.markerSvg_ = null
};
//Returns a bounding box describing the dimensions of this block and any blocks stacked below it
LearnBlock.BlockSvg.prototype.getHeightWidth = function () {
    var a = this.height,
        b = this.width,
        c = this.getNextBlock();
    c && (c = c.getHeightWidth(), a += c.height - 4, b = Math.max(b, c.width));
    return {
        height: a,
        width: b
    }
};
//Positions a new block correctly, so that it doesn't move the existing block when connected to it
LearnBlock.BlockSvg.prototype.positionNewBlock = function (a, b, c) {
    b.type != LearnBlock.NEXT_STATEMENT && b.type != LearnBlock.INPUT_VALUE || a.moveBy(c.x_ - b.x_, c.y_ - b.y_)
};
//Visual effect to show that if the dragging block is dropped, this block will be replaced
LearnBlock.BlockSvg.prototype.highlightForReplacement = function (a) {
    a ? LearnBlock.utils.dom.addClass(this.svgGroup_, "blocklyReplaceable") : LearnBlock.utils.dom.removeClass(this.svgGroup_, "blocklyReplaceable")
};

//CSS Functions
LearnBlock.Css = {};
//Has CSS already been injected?
LearnBlock.Css.injected_ = !1;
//Adds some CSS
LearnBlock.Css.register = function (a) {
    if (LearnBlock.Css.injected_) throw Error("CSS already injected");
    Array.prototype.push.apply(LearnBlock.Css.CONTENT, a);
    a.length = 0
};
//Injects the CSS into the DOM
LearnBlock.Css.inject = function (a, b) {
    if (!LearnBlock.Css.injected_) {
        LearnBlock.Css.injected_ = !0;
        var c = LearnBlock.Css.CONTENT.join("\n");
        LearnBlock.Css.CONTENT.length = 0;
        if (a) {
            var d = b.replace(/[\\/]$/, "");
            c = c.replace(/<<<PATH>>>/g, d);
            d = document.createElement("style");
            c = document.createTextNode(c);
            d.appendChild(c);
            document.head.insertBefore(d, document.head.firstChild)
        }
    }
};
//CSS content (defined in stiles.css)
LearnBlock.Css.CONTENT = [];

//Dropdown class
LearnBlock.DropDownDiv = function () {};
LearnBlock.DropDownDiv.DIV_ = null;
LearnBlock.DropDownDiv.boundsElement_ = null;
LearnBlock.DropDownDiv.owner_ = null;
LearnBlock.DropDownDiv.positionToField_ = null;
LearnBlock.DropDownDiv.ARROW_SIZE = 16;
LearnBlock.DropDownDiv.BORDER_SIZE = 1;
LearnBlock.DropDownDiv.ARROW_HORIZONTAL_PADDING = 12;
LearnBlock.DropDownDiv.PADDING_Y = 16;
LearnBlock.DropDownDiv.ANIMATION_TIME = .25;
LearnBlock.DropDownDiv.DEFAULT_DROPDOWN_BORDER_COLOR = "#dadce0";
LearnBlock.DropDownDiv.DEFAULT_DROPDOWN_COLOR = "#fff";
LearnBlock.DropDownDiv.animateOutTimer_ = null;
LearnBlock.DropDownDiv.onHide_ = null;
//Creates and inserts the dom element for the div
LearnBlock.DropDownDiv.createDom = function () {
    if (!LearnBlock.DropDownDiv.DIV_) {
        var a = document.createElement("div");
        a.className = "blocklyDropDownDiv";
        a.style.backgroundColor = LearnBlock.DropDownDiv.DEFAULT_DROPDOWN_COLOR;
        a.style.borderColor = LearnBlock.DropDownDiv.DEFAULT_DROPDOWN_BORDER_COLOR;
        document.body.appendChild(a);
        LearnBlock.DropDownDiv.DIV_ = a;
        var b = document.createElement("div");
        b.className = "blocklyDropDownContent";
        a.appendChild(b);
        LearnBlock.DropDownDiv.content_ = b;
        b = document.createElement("div");
        b.className = "blocklyDropDownArrow";
        a.appendChild(b);
        LearnBlock.DropDownDiv.arrow_ = b;
        LearnBlock.DropDownDiv.DIV_.style.opacity = 0;
        LearnBlock.DropDownDiv.DIV_.style.transition = "transform " + LearnBlock.DropDownDiv.ANIMATION_TIME + "s, opacity " + LearnBlock.DropDownDiv.ANIMATION_TIME + "s";
        a.addEventListener("focusin", function () {
            LearnBlock.utils.dom.addClass(a, "focused")
        });
        a.addEventListener("focusout", function () {
            LearnBlock.utils.dom.removeClass(a, "focused")
        })
    }
};
//Sets an element to maintain bounds within
LearnBlock.DropDownDiv.setBoundsElement = function (a) {
    LearnBlock.DropDownDiv.boundsElement_ = a
};
//Provides the div for inserting content into the drop-down
LearnBlock.DropDownDiv.getContentDiv = function () {
    return LearnBlock.DropDownDiv.content_
};
//Clears the content of the drop-down
LearnBlock.DropDownDiv.clearContent = function () {
    LearnBlock.DropDownDiv.content_.innerHTML = "";
    LearnBlock.DropDownDiv.content_.style.width = ""
};
//Sets the colour for the drop-down
LearnBlock.DropDownDiv.setColour = function (a, b) {
    LearnBlock.DropDownDiv.DIV_.style.backgroundColor = a;
    LearnBlock.DropDownDiv.DIV_.style.borderColor = b
};
//Sets the category for the drop-down
LearnBlock.DropDownDiv.setCategory = function (a) {
    LearnBlock.DropDownDiv.DIV_.setAttribute("data-category", a)
};
//Shows and places the drop-down with positioning determined by a particular block
LearnBlock.DropDownDiv.showPositionedByBlock = function (a, b, c, d) {
    var e = b.workspace.scale,
        f = b.width,
        g = b.height;
    f *= e;
    g *= e;
    e = b.getSvgRoot().getBoundingClientRect();
    f = e.left + f / 2;
    g = e.top + g;
    e = e.top;
    d && (e += d);
    LearnBlock.DropDownDiv.setBoundsElement(b.workspace.getParentSvg().parentNode);
    return LearnBlock.DropDownDiv.show(a, b.RTL, f, g, f, e, c)
};
//Shows and places the drop-down with positioning determined by a particular field
LearnBlock.DropDownDiv.showPositionedByField = function (a, b, c) {
    var d = a.getSvgRoot().getBoundingClientRect(),
        e = d.left + d.width / 2,
        f = d.bottom;
    d = d.top;
    c && (d += c);
    c = a.getSourceBlock();
    LearnBlock.DropDownDiv.positionToField_ = !0;
    LearnBlock.DropDownDiv.setBoundsElement(c.workspace.getParentSvg().parentNode);
    return LearnBlock.DropDownDiv.show(a, c.RTL, e, f, e, d, b)
};
//Shows and places the drop-down
LearnBlock.DropDownDiv.show = function (a, b, c, d, e, f, g) {
    LearnBlock.DropDownDiv.owner_ = a;
    LearnBlock.DropDownDiv.onHide_ = g || null;
    a = LearnBlock.DropDownDiv.getPositionMetrics(c, d, e, f);
    a.arrowVisible ? (LearnBlock.DropDownDiv.arrow_.style.display = "", LearnBlock.DropDownDiv.arrow_.style.transform = "translate(" + a.arrowX + "px," + a.arrowY + "px) rotate(45deg)", LearnBlock.DropDownDiv.arrow_.setAttribute("class", a.arrowAtTop ? "blocklyDropDownArrow arrowTop" : "blocklyDropDownArrow arrowBottom")) : LearnBlock.DropDownDiv.arrow_.style.display = "none";
    LearnBlock.DropDownDiv.DIV_.style.direction = b ? "rtl" : "ltr";
    LearnBlock.DropDownDiv.positionInternal_(a.initialX, a.initialY, a.finalX, a.finalY);
    return a.arrowAtTop
};
//Gets sizing info about the bounding element
LearnBlock.DropDownDiv.getBoundsInfo_ = function () {
    var a = LearnBlock.DropDownDiv.boundsElement_.getBoundingClientRect(),
        b = LearnBlock.utils.style.getSize(LearnBlock.DropDownDiv.boundsElement_);
    return {
        left: a.left,
        right: a.left + b.width,
        top: a.top,
        bottom: a.top + b.height,
        width: b.width,
        height: b.height
    }
};
//Helper to position the drop-down and the arrow, maintaining bounds
LearnBlock.DropDownDiv.getPositionMetrics = function (a, b, c, d) {
    var e = LearnBlock.DropDownDiv.getBoundsInfo_(),
        f = LearnBlock.utils.style.getSize(LearnBlock.DropDownDiv.DIV_);
    return b + f.height < e.bottom ? LearnBlock.DropDownDiv.getPositionBelowMetrics(a, b, e, f) : d - f.height > e.top ? LearnBlock.DropDownDiv.getPositionAboveMetrics(c, d, e, f) : b + f.height < document.documentElement.clientHeight ? LearnBlock.DropDownDiv.getPositionBelowMetrics(a, b, e, f) : d - f.height > document.documentElement.clientTop ? LearnBlock.DropDownDiv.getPositionAboveMetrics(c, d,
        e, f) : LearnBlock.DropDownDiv.getPositionTopOfPageMetrics(a, e, f)
};
//Gets the metrics for positioning the div below the source
LearnBlock.DropDownDiv.getPositionBelowMetrics = function (a, b, c, d) {
    a = LearnBlock.DropDownDiv.getPositionX(a, c.left, c.right, d.width);
    return {
        initialX: a.divX,
        initialY: b,
        finalX: a.divX,
        finalY: b + LearnBlock.DropDownDiv.PADDING_Y,
        arrowX: a.arrowX,
        arrowY: -(LearnBlock.DropDownDiv.ARROW_SIZE / 2 + LearnBlock.DropDownDiv.BORDER_SIZE),
        arrowAtTop: !0,
        arrowVisible: !0
    }
};
//Gets the metrics for positioning the div above the source
LearnBlock.DropDownDiv.getPositionAboveMetrics = function (a, b, c, d) {
    a = LearnBlock.DropDownDiv.getPositionX(a, c.left, c.right, d.width);
    return {
        initialX: a.divX,
        initialY: b - d.height,
        finalX: a.divX,
        finalY: b - d.height - LearnBlock.DropDownDiv.PADDING_Y,
        arrowX: a.arrowX,
        arrowY: d.height - 2 * LearnBlock.DropDownDiv.BORDER_SIZE - LearnBlock.DropDownDiv.ARROW_SIZE / 2,
        arrowAtTop: !1,
        arrowVisible: !0
    }
};
//Gets the metrics for positioning the div at the top of the page
LearnBlock.DropDownDiv.getPositionTopOfPageMetrics = function (a, b, c) {
    a = LearnBlock.DropDownDiv.getPositionX(a, b.left, b.right, c.width);
    return {
        initialX: a.divX,
        initialY: 0,
        finalX: a.divX,
        finalY: 0,
        arrowVisible: !1
    }
};
//Gets the x positions for the left side of the DropDownDiv
LearnBlock.DropDownDiv.getPositionX = function (a, b, c, d) {
    var e = a;
    a = LearnBlock.utils.math.clamp(b, a - d / 2, c - d);
    e -= LearnBlock.DropDownDiv.ARROW_SIZE / 2;
    b = LearnBlock.DropDownDiv.ARROW_HORIZONTAL_PADDING;
    d = LearnBlock.utils.math.clamp(b, e - a, d - b - LearnBlock.DropDownDiv.ARROW_SIZE);
    return {
        arrowX: d,
        divX: a
    }
};
//Is the container visible?
LearnBlock.DropDownDiv.isVisible = function () {
    return !!LearnBlock.DropDownDiv.owner_
};
//Hides the menu only if it is owned by the provided object
LearnBlock.DropDownDiv.hideIfOwner = function (a, b) {
    return LearnBlock.DropDownDiv.owner_ === a ? (b ? LearnBlock.DropDownDiv.hideWithoutAnimation() : LearnBlock.DropDownDiv.hide(), !0) : !1
};
//Hides the menu triggering an animation
LearnBlock.DropDownDiv.hide = function () {
    var a = LearnBlock.DropDownDiv.DIV_;
    a.style.transform = "translate(0, 0)";
    a.style.opacity = 0;
    LearnBlock.DropDownDiv.animateOutTimer_ = setTimeout(function () {
        LearnBlock.DropDownDiv.hideWithoutAnimation()
    }, 1E3 * LearnBlock.DropDownDiv.ANIMATION_TIME);
    LearnBlock.DropDownDiv.onHide_ && (LearnBlock.DropDownDiv.onHide_(), LearnBlock.DropDownDiv.onHide_ = null)
};
//Hides the menu without animation
LearnBlock.DropDownDiv.hideWithoutAnimation = function () {
    if (LearnBlock.DropDownDiv.isVisible()) {
        LearnBlock.DropDownDiv.animateOutTimer_ && clearTimeout(LearnBlock.DropDownDiv.animateOutTimer_);
        var a = LearnBlock.DropDownDiv.DIV_;
        a.style.transform = "";
        a.style.left = "";
        a.style.top = "";
        a.style.opacity = 0;
        a.style.display = "none";
        a.style.backgroundColor = LearnBlock.DropDownDiv.DEFAULT_DROPDOWN_COLOR;
        a.style.borderColor = LearnBlock.DropDownDiv.DEFAULT_DROPDOWN_BORDER_COLOR;
        LearnBlock.DropDownDiv.onHide_ && (LearnBlock.DropDownDiv.onHide_(), LearnBlock.DropDownDiv.onHide_ =
            null);
        LearnBlock.DropDownDiv.clearContent();
        LearnBlock.DropDownDiv.owner_ = null
    }
};
//Sets the dropdown div's position
LearnBlock.DropDownDiv.positionInternal_ = function (a, b, c, d) {
    a = Math.floor(a);
    b = Math.floor(b);
    c = Math.floor(c);
    d = Math.floor(d);
    var e = LearnBlock.DropDownDiv.DIV_;
    e.style.left = a + "px";
    e.style.top = b + "px";
    e.style.display = "block";
    e.style.opacity = 1;
    e.style.transform = "translate(" + (c - a) + "px," + (d - b) + "px)"
};
//Repositions the dropdownDiv on window resize
LearnBlock.DropDownDiv.repositionForWindowResize = function () {
    if (LearnBlock.DropDownDiv.owner_) {
        var a = LearnBlock.DropDownDiv.owner_.getSourceBlock(),
            b = a.workspace.scale,
            c = LearnBlock.DropDownDiv.positionToField_ ? LearnBlock.DropDownDiv.owner_.size_.width : a.width,
            d = LearnBlock.DropDownDiv.positionToField_ ? LearnBlock.DropDownDiv.owner_.size_.height : a.height;
        c *= b;
        d *= b;
        a = LearnBlock.DropDownDiv.positionToField_ ? LearnBlock.DropDownDiv.owner_.fieldGroup_.getBoundingClientRect() : a.getSvgRoot().getBoundingClientRect();
        c = a.left + c / 2;
        d = LearnBlock.DropDownDiv.getPositionMetrics(c,
            a.top + d, c, a.top);
        LearnBlock.DropDownDiv.positionInternal_(d.initialX, d.initialY, d.finalX, d.finalY)
    } else LearnBlock.DropDownDiv.hide()
};

//Class for a workspace's grid
LearnBlock.Grid = function (a, b) {
    this.gridPattern_ = a;
    this.spacing_ = b.spacing;
    this.length_ = b.length;
    this.line2_ = (this.line1_ = a.firstChild) && this.line1_.nextSibling;
    this.snapToGrid_ = b.snap
};
LearnBlock.Grid.prototype.scale_ = 1;
//Dispose of the grid and unlink from the DOM
LearnBlock.Grid.prototype.dispose = function () {
    this.gridPattern_ = null
};
//Whether blocks should snap to the grid, based on the initial configuration
LearnBlock.Grid.prototype.shouldSnap = function () {
    return this.snapToGrid_
};
//Gets the spacing of the grid points
LearnBlock.Grid.prototype.getSpacing = function () {
    return this.spacing_
};
//Gets the id of the pattern element
LearnBlock.Grid.prototype.getPatternId = function () {
    return this.gridPattern_.id
};
//Updates the grid with a new scale
LearnBlock.Grid.prototype.update = function (a) {
    this.scale_ = a;
    var b = this.spacing_ * a || 100;
    this.gridPattern_.setAttribute("width", b);
    this.gridPattern_.setAttribute("height", b);
    b = Math.floor(this.spacing_ / 2) + .5;
    var c = b - this.length_ / 2,
        d = b + this.length_ / 2;
    b *= a;
    c *= a;
    d *= a;
    this.setLineAttributes_(this.line1_, a, c, d, b, b);
    this.setLineAttributes_(this.line2_, a, b, b, c, d)
};
//Sets the attributes on one of the lines in the grid
LearnBlock.Grid.prototype.setLineAttributes_ = function (a, b, c, d, e, f) {
    a && (a.setAttribute("stroke-width", b), a.setAttribute("x1", c), a.setAttribute("y1", e), a.setAttribute("x2", d), a.setAttribute("y2", f))
};
//Moves the grid to a new x and y position and makes sure that change is visible
LearnBlock.Grid.prototype.moveTo = function (a, b) {
    this.gridPattern_.setAttribute("x", a);
    this.gridPattern_.setAttribute("y", b);
    (LearnBlock.utils.userAgent.IE || LearnBlock.utils.userAgent.EDGE) && this.update(this.scale_)
};
//Creates the DOM for the grid described by options
LearnBlock.Grid.createDom = function (a, b, c) {
    a = LearnBlock.utils.dom.createSvgElement("pattern", {
        id: "blocklyGridPattern" + a,
        patternUnits: "userSpaceOnUse"
    }, c);
    0 < b.length && 0 < b.spacing ? (LearnBlock.utils.dom.createSvgElement("line", {
        stroke: b.colour
    }, a), 1 < b.length && LearnBlock.utils.dom.createSvgElement("line", {
        stroke: b.colour
    }, a)) : LearnBlock.utils.dom.createSvgElement("line", {}, a);
    return a
};

//Parses the user-specified options
LearnBlock.Options = function (a) {
    var b = !!a.readOnly;
    if (b) var c = null,
        d = !1,
        e = !1,
        f = !1,
        g = !1,
        h = !1,
        k = !1;
    else {
        c = LearnBlock.Options.parseToolboxTree(a.toolbox || null);
        d = !(!c || !c.getElementsByTagName("category").length);
        e = a.trashcan;
        void 0 === e && (e = d);
        var l = a.maxTrashcanContents;
        e ? void 0 === l && (l = 32) : l = 0;
        f = a.collapse;
        void 0 === f && (f = d);
        g = a.comments;
        void 0 === g && (g = d);
        h = a.disable;
        void 0 === h && (h = d);
        k = a.sounds;
        void 0 === k && (k = !0)
    }
    var m = !!a.rtl,
        n = a.horizontalLayout;
    void 0 === n && (n = !1);
    var p = a.toolboxPosition;
    p = "end" === p ? !1 :
        !0;
    p = n ? p ? LearnBlock.TOOLBOX_AT_TOP : LearnBlock.TOOLBOX_AT_BOTTOM : p == m ? LearnBlock.TOOLBOX_AT_RIGHT : LearnBlock.TOOLBOX_AT_LEFT;
    var q = a.css;
    void 0 === q && (q = !0);
    var r = "https://blockly-demo.appspot.com/static/media/";
    a.media ? r = a.media : a.path && (r = a.path + "media/");
    var t = void 0 === a.oneBasedIndex ? !0 : !!a.oneBasedIndex,
        u = a.theme,
        v = a.keyMap || LearnBlock.user.keyMap.createDefaultKeyMap(),
        w = a.renderer || "geras";
    this.RTL = m;
    this.oneBasedIndex = t;
    this.collapse = f;
    this.comments = g;
    this.disable = h;
    this.readOnly = b;
    this.maxBlocks = a.maxBlocks ||
        Infinity;
    this.maxInstances = a.maxInstances;
    this.pathToMedia = r;
    this.hasCategories = d;
    this.moveOptions = LearnBlock.Options.parseMoveOptions(a, d);
    this.hasScrollbars = this.moveOptions.scrollbars;
    this.maxTrashcanContents = l;
    this.hasSounds = k;
    this.hasCss = q;
    this.horizontalLayout = n;
    this.languageTree = c;
    this.gridOptions = LearnBlock.Options.parseGridOptions_(a);
    this.zoomOptions = LearnBlock.Options.parseZoomOptions_(a);
    this.toolboxPosition = p;
    this.theme = u;
    this.keyMap = v;
    this.renderer = w
};
LearnBlock.Options.prototype.parentWorkspace = null;
LearnBlock.Options.prototype.setMetrics = null;
LearnBlock.Options.prototype.getMetrics = null;
//Parses the user-specified move options
LearnBlock.Options.parseMoveOptions = function (a, b) {
    var c = a.move || {},
        d = {};
    d.scrollbars = void 0 === c.scrollbars && void 0 === a.scrollbars ? b : !!c.scrollbars || !!a.scrollbars;
    d.wheel = d.scrollbars && void 0 !== c.wheel ? !!c.wheel : !1;
    d.drag = d.scrollbars ? void 0 === c.drag ? !0 : !!c.drag : !1;
    return d
};
//Parses the user-specified zoom options
LearnBlock.Options.parseZoomOptions_ = function (a) {
    a = a.zoom || {};
    var b = {};
    b.controls = void 0 === a.controls ? !1 : !!a.controls;
    b.wheel = void 0 === a.wheel ? !1 : !!a.wheel;
    b.startScale = void 0 === a.startScale ? 1 : Number(a.startScale);
    b.maxScale = void 0 === a.maxScale ? 3 : Number(a.maxScale);
    b.minScale = void 0 === a.minScale ? .3 : Number(a.minScale);
    b.scaleSpeed = void 0 === a.scaleSpeed ? 1.2 : Number(a.scaleSpeed);
    return b
};
//Parses the user-specified grid options
LearnBlock.Options.parseGridOptions_ = function (a) {
    a = a.grid || {};
    var b = {};
    b.spacing = Number(a.spacing) || 0;
    b.colour = a.colour || "#888";
    b.length = Number(a.length) || 1;
    b.snap = 0 < b.spacing && !!a.snap;
    return b
};
//Parses the provided toolbox tree into a consistent DOM format
LearnBlock.Options.parseToolboxTree = function (a) {
    if (a) {
        if ("string" != typeof a && (LearnBlock.utils.userAgent.IE && a.outerHTML ? a = a.outerHTML : a instanceof Element || (a = null)), "string" == typeof a && (a = LearnBlock.Xml.textToDom(a), "xml" != a.nodeName.toLowerCase())) throw TypeError("Toolbox should be an <xml> document.");
    } else a = null;
    return a
};

//Blocks are moved into the SVG during a drag
LearnBlock.WorkspaceDragSurfaceSvg = function (a) {
    this.container_ = a;
    this.createDom()
};
//The SVG drag surface
LearnBlock.WorkspaceDragSurfaceSvg.prototype.SVG_ = null;
LearnBlock.WorkspaceDragSurfaceSvg.prototype.dragGroup_ = null;
LearnBlock.WorkspaceDragSurfaceSvg.prototype.container_ = null;
//Dom structure when the workspace is being dragged
LearnBlock.WorkspaceDragSurfaceSvg.prototype.createDom = function () {
    this.SVG_ || (this.SVG_ = LearnBlock.utils.dom.createSvgElement("svg", {
        xmlns: LearnBlock.utils.dom.SVG_NS,
        "xmlns:html": LearnBlock.utils.dom.HTML_NS,
        "xmlns:xlink": LearnBlock.utils.dom.XLINK_NS,
        version: "1.1",
        "class": "blocklyWsDragSurface blocklyOverflowVisible"
    }, null), this.container_.appendChild(this.SVG_))
};
//Translates the entire drag surface during a drag
LearnBlock.WorkspaceDragSurfaceSvg.prototype.translateSurface = function (a, b) {
    var c = a.toFixed(0),
        d = b.toFixed(0);
    this.SVG_.style.display = "block";
    LearnBlock.utils.dom.setCssTransform(this.SVG_, "translate3d(" + c + "px, " + d + "px, 0px)")
};
//Reports the surface translation in scaled workspace coordinates
LearnBlock.WorkspaceDragSurfaceSvg.prototype.getSurfaceTranslation = function () {
    return LearnBlock.utils.getRelativeXY(this.SVG_)
};
//Moves the blockCanvas out of the surface SVG and on to newSurface
LearnBlock.WorkspaceDragSurfaceSvg.prototype.clearAndHide = function (a) {
    if (!a) throw Error("Couldn't clear and hide the drag surface: missing new surface.");
    var b = this.SVG_.childNodes[0];
    if (!(b && LearnBlock.utils.dom.hasClass(b, "blocklyBlockCanvas"))) throw Error("Couldn't clear and hide the drag surface. A node was missing.");
    null != this.previousSibling_ ? LearnBlock.utils.dom.insertAfter(b, this.previousSibling_) : a.insertBefore(b, a.firstChild);
    this.SVG_.style.display = "none";
    if (this.SVG_.childNodes.length) throw Error("Drag surface was not cleared.");
    LearnBlock.utils.dom.setCssTransform(this.SVG_, "");
    this.previousSibling_ = null
};
//Sets the SVG to have the block canvas in it and then show the surface
LearnBlock.WorkspaceDragSurfaceSvg.prototype.setContentsAndShow = function (a, c, d, e, f) {
    if (this.SVG_.childNodes.length) throw Error("Already dragging a block.");
    this.previousSibling_ = c;
    a.setAttribute("transform", "translate(0, 0) scale(" + f + ")");
    this.SVG_.setAttribute("width", d);
    this.SVG_.setAttribute("height", e);
    this.SVG_.appendChild(a);
    this.SVG_.style.display = "block"
};


LearnBlock.blockRendering.rendererMap_ = {};
LearnBlock.blockRendering.useDebugger = !1;
LearnBlock.blockRendering.register = function (a, b) {
    if (LearnBlock.blockRendering.rendererMap_[a]) throw Error("Renderer has already been registered.");
    LearnBlock.blockRendering.rendererMap_[a] = b
};
LearnBlock.blockRendering.unregister = function (a) {
    LearnBlock.blockRendering.rendererMap_[a] ? delete LearnBlock.blockRendering.rendererMap_[a] : console.warn('No renderer mapping for name "' + a + '" found to unregister')
};
LearnBlock.blockRendering.startDebugger = function () {
    LearnBlock.blockRendering.useDebugger = !0
};
LearnBlock.blockRendering.stopDebugger = function () {
    LearnBlock.blockRendering.useDebugger = !1
};
LearnBlock.blockRendering.init = function (a) {
    if (!LearnBlock.blockRendering.rendererMap_[a]) throw Error("Renderer not registered: ", a);
    var b = function () {
        b.superClass_.constructor.call(this)
    };
    LearnBlock.utils.object.inherits(b, LearnBlock.blockRendering.rendererMap_[a]);
    a = new b;
    a.init();
    return a
};

//Database for blocks connections
LearnBlock.ConnectionDB = function () {
    this.connections_ = []
};
//Adds a connection
LearnBlock.ConnectionDB.prototype.addConnection = function (a) {
    if (a.inDB_) throw Error("Connection already in database.");
    if (!a.getSourceBlock().isInFlyout) {
        var b = this.findPositionForConnection_(a);
        this.connections_.splice(b, 0, a);
        a.inDB_ = !0
    }
};
//Finds the given connection
LearnBlock.ConnectionDB.prototype.findConnection = function (a) {
    if (!this.connections_.length) return -1;
    var b = this.findPositionForConnection_(a);
    if (b >= this.connections_.length) return -1;
    for (var c = a.y_, d = b; 0 <= d && this.connections_[d].y_ == c;) {
        if (this.connections_[d] == a) return d;
        d--
    }
    for (; b < this.connections_.length && this.connections_[b].y_ == c;) {
        if (this.connections_[b] == a) return b;
        b++
    }
    return -1
};
//Finds a candidate position for inserting this connection into the list
LearnBlock.ConnectionDB.prototype.findPositionForConnection_ = function (a) {
    if (!this.connections_.length) return 0;
    for (var b = 0, c = this.connections_.length; b < c;) {
        var d = Math.floor((b + c) / 2);
        if (this.connections_[d].y_ < a.y_) b = d + 1;
        else if (this.connections_[d].y_ > a.y_) c = d;
        else {
            b = d;
            break
        }
    }
    return b
};
//Removes a connection from the database
LearnBlock.ConnectionDB.prototype.removeConnection_ = function (a) {
    if (!a.inDB_) throw Error("Connection not in database.");
    var b = this.findConnection(a);
    if (-1 == b) throw Error("Unable to find connection in connectionDB.");
    a.inDB_ = !1;
    this.connections_.splice(b, 1)
};
//Finds all nearby connections to the given connection
LearnBlock.ConnectionDB.prototype.getNeighbours = function (a, b) {
    function c(a) {
        var c = e - d[a].x_,
            g = f - d[a].y_;
        Math.sqrt(c * c + g * g) <= b && l.push(d[a]);
        return g < b
    }
    for (var d = this.connections_, e = a.x_, f = a.y_, g = 0, h = d.length - 2, k = h; g < k;) d[k].y_ < f ? g = k : h = k, k = Math.floor((g + h) / 2);
    var l = [];
    h = g = k;
    if (d.length) {
        for (; 0 <= g && c(g);) g--;
        do h++; while (h < d.length && c(h))
    }
    return l
};
//Is the candidate connection close to the reference connection?
LearnBlock.ConnectionDB.prototype.isInYRange_ = function (a, b, c) {
    return Math.abs(this.connections_[a].y_ - b) <= c
};
//Finds the closest compatible connection to this connection
LearnBlock.ConnectionDB.prototype.searchForClosest = function (a, b, c) {
    if (!this.connections_.length) return {
        connection: null,
        radius: b
    };
    var d = a.y_,
        e = a.x_;
    a.x_ = e + c.x;
    a.y_ = d + c.y;
    var f = this.findPositionForConnection_(a);
    c = null;
    for (var g = b, h, k = f - 1; 0 <= k && this.isInYRange_(k, a.y_, b);) h = this.connections_[k], a.isConnectionAllowed(h, g) && (c = h, g = h.distanceFrom(a)), k--;
    for (; f < this.connections_.length && this.isInYRange_(f, a.y_, b);) h = this.connections_[f], a.isConnectionAllowed(h, g) && (c = h, g = h.distanceFrom(a)), f++;
    a.x_ = e;
    a.y_ =
        d;
    return {
        connection: c,
        radius: g
    }
};
//Initializes a set of connection DBs for a workspace
LearnBlock.ConnectionDB.init = function () {
    var a = [];
    a[LearnBlock.INPUT_VALUE] = new LearnBlock.ConnectionDB;
    a[LearnBlock.OUTPUT_VALUE] = new LearnBlock.ConnectionDB;
    a[LearnBlock.NEXT_STATEMENT] = new LearnBlock.ConnectionDB;
    a[LearnBlock.PREVIOUS_STATEMENT] = new LearnBlock.ConnectionDB;
    return a
};

//Class for a gesture
LearnBlock.TouchGesture = function (a, b) {
    LearnBlock.TouchGesture.superClass_.constructor.call(this, a, b);
    this.isMultiTouch_ = !1;
    this.cachedPoints_ = {};
    this.startDistance_ = this.previousScale_ = 0;
    this.onStartWrapper_ = null
};
LearnBlock.utils.object.inherits(LearnBlock.TouchGesture, LearnBlock.Gesture);
//Starts a gesture
LearnBlock.TouchGesture.prototype.doStart = function (a) {
    LearnBlock.TouchGesture.superClass_.doStart.call(this, a);
    !this.isEnding_ && LearnBlock.Touch.isTouchEvent(a)
};
//Binds gesture events
LearnBlock.TouchGesture.prototype.bindMouseEvents = function (a) {
    this.onStartWrapper_ = LearnBlock.bindEventWithChecks_(document, "mousedown", null, this.handleStart.bind(this), !0);
    this.onMoveWrapper_ = LearnBlock.bindEventWithChecks_(document, "mousemove", null, this.handleMove.bind(this), !0);
    this.onUpWrapper_ = LearnBlock.bindEventWithChecks_(document, "mouseup", null, this.handleUp.bind(this), !0);
    a.preventDefault();
    a.stopPropagation()
};
//Handles a mouse down or pointer down event
LearnBlock.TouchGesture.prototype.handleStart = function (a) {
    !this.isDragging() && LearnBlock.Touch.isTouchEvent(a) && (this.handleTouchStart(a), this.isMultiTouch() && LearnBlock.longStop_())
};
//Handles a mouse move or pointer move event
LearnBlock.TouchGesture.prototype.handleMove = function (a) {
    this.isDragging() ? LearnBlock.Touch.shouldHandleEvent(a) && LearnBlock.TouchGesture.superClass_.handleMove.call(this, a) : this.isMultiTouch() ? (LearnBlock.Touch.isTouchEvent(a) && this.handleTouchMove(a), LearnBlock.longStop_()) : LearnBlock.TouchGesture.superClass_.handleMove.call(this, a)
};
//Handles a mouse up or pointer up event
LearnBlock.TouchGesture.prototype.handleUp = function (a) {
    LearnBlock.Touch.isTouchEvent(a) && !this.isDragging() && this.handleTouchEnd(a);
    !this.isMultiTouch() || this.isDragging() ? LearnBlock.Touch.shouldHandleEvent(a) && LearnBlock.TouchGesture.superClass_.handleUp.call(this, a) : (a.preventDefault(), a.stopPropagation(), this.dispose())
};
//Whether the gesture is part of a multi-touch gesture
LearnBlock.TouchGesture.prototype.isMultiTouch = function () {
    return this.isMultiTouch_
};
//Severs all links from this object
LearnBlock.TouchGesture.prototype.dispose = function () {
    LearnBlock.TouchGesture.superClass_.dispose.call(this);
    this.onStartWrapper_ && LearnBlock.unbindEvent_(this.onStartWrapper_)
};
//Handles a touch end or pointer end event
LearnBlock.TouchGesture.prototype.handleTouchEnd = function (a) {};
//Helper function returning the current touch point coordinate
LearnBlock.TouchGesture.prototype.getTouchPoint = function (a) {
    return this.startWorkspace_ ? new LearnBlock.utils.Coordinate(a.pageX ? a.pageX : a.changedTouches[0].pageX, a.pageY ? a.pageY : a.changedTouches[0].pageY) : null
};

//Class for a workspace
LearnBlock.WorkspaceSvg = function (a, b, c) {
    LearnBlock.WorkspaceSvg.superClass_.constructor.call(this, a);
    this.getMetrics = a.getMetrics || LearnBlock.WorkspaceSvg.getTopLevelWorkspaceMetrics_;
    this.setMetrics = a.setMetrics || LearnBlock.WorkspaceSvg.setTopLevelWorkspaceMetrics_;
    this.connectionDBList = LearnBlock.ConnectionDB.init();
    b && (this.blockDragSurface_ = b);
    c && (this.workspaceDragSurface_ = c);
    this.useWorkspaceDragSurface_ = this.workspaceDragSurface_ && LearnBlock.utils.is3dSupported();
    this.highlightedBlocks_ = [];
    this.grid_ = this.options.gridPattern ? new LearnBlock.Grid(a.gridPattern, a.gridOptions) : null;
    this.markerSvg_ = this.cursorSvg_ = null;
    LearnBlock.Variables && LearnBlock.Variables.flyoutCategory && this.registerToolboxCategoryCallback(LearnBlock.VARIABLE_CATEGORY_NAME, LearnBlock.Variables.flyoutCategory);
    LearnBlock.VariablesDynamic && LearnBlock.VariablesDynamic.flyoutCategory && this.registerToolboxCategoryCallback(LearnBlock.VARIABLE_DYNAMIC_CATEGORY_NAME, LearnBlock.VariablesDynamic.flyoutCategory);
    LearnBlock.Procedures && LearnBlock.Procedures.flyoutCategory && this.registerToolboxCategoryCallback(LearnBlock.PROCEDURE_CATEGORY_NAME, LearnBlock.Procedures.flyoutCategory);
    this.renderer_ = LearnBlock.blockRendering.init(this.options.renderer || "geras")
};
LearnBlock.utils.object.inherits(LearnBlock.WorkspaceSvg, LearnBlock.Workspace);
LearnBlock.WorkspaceSvg.prototype.resizeHandlerWrapper_ = null;
LearnBlock.WorkspaceSvg.prototype.rendered = !0;
LearnBlock.WorkspaceSvg.prototype.isVisible_ = !0;
LearnBlock.WorkspaceSvg.prototype.isFlyout = !1;
LearnBlock.WorkspaceSvg.prototype.resizesEnabled_ = !0;
LearnBlock.WorkspaceSvg.prototype.scrollX = 0;
LearnBlock.WorkspaceSvg.prototype.scrollY = 0;
LearnBlock.WorkspaceSvg.prototype.startScrollX = 0;
LearnBlock.WorkspaceSvg.prototype.startScrollY = 0;
LearnBlock.WorkspaceSvg.prototype.dragDeltaXY_ = null;
LearnBlock.WorkspaceSvg.prototype.scale = 1;
LearnBlock.WorkspaceSvg.prototype.scrollbar = null;
LearnBlock.WorkspaceSvg.prototype.flyout_ = null;
LearnBlock.WorkspaceSvg.prototype.toolbox_ = null;
LearnBlock.WorkspaceSvg.prototype.currentGesture_ = null;
LearnBlock.WorkspaceSvg.prototype.blockDragSurface_ = null;
LearnBlock.WorkspaceSvg.prototype.workspaceDragSurface_ = null;
LearnBlock.WorkspaceSvg.prototype.useWorkspaceDragSurface_ = !1;
LearnBlock.WorkspaceSvg.prototype.isDragSurfaceActive_ = !1;
LearnBlock.WorkspaceSvg.prototype.injectionDiv_ = null;
LearnBlock.WorkspaceSvg.prototype.lastRecordedPageScroll_ = null;
LearnBlock.WorkspaceSvg.prototype.flyoutButtonCallbacks_ = {};
LearnBlock.WorkspaceSvg.prototype.toolboxCategoryCallbacks_ = {};
LearnBlock.WorkspaceSvg.prototype.configureContextMenu = null;
LearnBlock.WorkspaceSvg.prototype.targetWorkspace = null;
LearnBlock.WorkspaceSvg.prototype.inverseScreenCTM_ = null;
LearnBlock.WorkspaceSvg.prototype.inverseScreenCTMDirty_ = !0;
//Gets the block renderer attached to this workspace
LearnBlock.WorkspaceSvg.prototype.getRenderer = function () {
    return this.renderer_
};
//Sets the cursor for use with keyboard navigation
LearnBlock.WorkspaceSvg.prototype.setCursor = function (a) {
    this.cursor_ && this.cursor_.getDrawer() && this.cursor_.getDrawer().dispose();
    if (this.cursor_ = a) this.cursor_.setDrawer(this.getRenderer().makeCursorDrawer(this, !1)), this.setCursorSvg(this.cursor_.getDrawer().createDom())
};
//Sets the marker for use with keyboard navigation
LearnBlock.WorkspaceSvg.prototype.setMarker = function (a) {
    this.marker_ && this.marker_.getDrawer() && this.marker_.getDrawer().dispose();
    if (this.marker_ = a) this.marker_.setDrawer(this.getRenderer().makeCursorDrawer(this, !0)), this.setMarkerSvg(this.marker_.getDrawer().createDom())
};
//Adds the cursor svg to this workspaces svg group
LearnBlock.WorkspaceSvg.prototype.setCursorSvg = function (a) {
    a ? this.svgBlockCanvas_ && (this.svgBlockCanvas_.appendChild(a), this.cursorSvg_ = a) : this.cursorSvg_ = null
};
//Adds the marker svg to this workspaces svg group
LearnBlock.WorkspaceSvg.prototype.setMarkerSvg = function (a) {
    a ? this.svgBlockCanvas_ && (this.cursorSvg_ ? this.svgBlockCanvas_.insertBefore(a, this.cursorSvg_) : this.svgBlockCanvas_.appendChild(a), this.markerSvg_ = a) : this.markerSvg_ = null
};
//Getter for the inverted screen CTM
LearnBlock.WorkspaceSvg.prototype.getInverseScreenCTM = function () {
    if (this.inverseScreenCTMDirty_) {
        var a = this.getParentSvg().getScreenCTM();
        a && (this.inverseScreenCTM_ = a.inverse(), this.inverseScreenCTMDirty_ = !1)
    }
    return this.inverseScreenCTM_
};
//Marks the inverse screen CTM as dirty
LearnBlock.WorkspaceSvg.prototype.updateInverseScreenCTM = function () {
    this.inverseScreenCTMDirty_ = !0
};
//Getter for isVisible
LearnBlock.WorkspaceSvg.prototype.isVisible = function () {
    return this.isVisible_
};
//Returns the absolute coordinates of the top-left corner of the element
LearnBlock.WorkspaceSvg.prototype.getSvgXY = function (a) {
    var b = 0,
        c = 0,
        d = 1;
    if (LearnBlock.utils.dom.containsNode(this.getCanvas(), a) || LearnBlock.utils.dom.containsNode(this.getBubbleCanvas(), a)) d = this.scale;
    do {
        var e = LearnBlock.utils.getRelativeXY(a);
        if (a == this.getCanvas()) d = 1;
        b += e.x * d;
        c += e.y * d;
        a = a.parentNode
    } while (a && a != this.getParentSvg());
    return new LearnBlock.utils.Coordinate(b, c)
};
//Returns the position of the workspace origin
LearnBlock.WorkspaceSvg.prototype.getOriginOffsetInPixels = function () {
    return LearnBlock.utils.getInjectionDivXY_(this.svgBlockCanvas_)
};
//Returns the injection div that is a parent of the workspace
LearnBlock.WorkspaceSvg.prototype.getInjectionDiv = function () {
    if (!this.injectionDiv_)
        for (var a = this.svgGroup_; a;) {
            if (-1 != (" " + (a.getAttribute("class") || "") + " ").indexOf(" injectionDiv ")) {
                this.injectionDiv_ = a;
                break
            }
            a = a.parentNode
        }
    return this.injectionDiv_
};
//Saves resize handler data so it can be deleted later in dispose
LearnBlock.WorkspaceSvg.prototype.setResizeHandlerWrapper = function (a) {
    this.resizeHandlerWrapper_ = a
};
//Creates the workspace DOM elements
LearnBlock.WorkspaceSvg.prototype.createDom = function (a) {
    this.svgGroup_ = LearnBlock.utils.dom.createSvgElement("g", {
        "class": "blocklyWorkspace"
    }, null);
    a && (this.svgBackground_ = LearnBlock.utils.dom.createSvgElement("rect", {
        height: "100%",
        width: "100%",
        "class": a
    }, this.svgGroup_), "blocklyMainBackground" == a && this.grid_ ? this.svgBackground_.style.fill = "url(#" + this.grid_.getPatternId() + ")" : this.themeManager_.subscribe(this.svgBackground_, "workspace", "fill"));
    this.svgBlockCanvas_ = LearnBlock.utils.dom.createSvgElement("g", {
        "class": "blocklyBlockCanvas"
    }, this.svgGroup_);
    this.isFlyout || (LearnBlock.bindEventWithChecks_(this.svgGroup_, "mousedown", this, this.onMouseDown_, !1, !0), LearnBlock.bindEventWithChecks_(this.svgGroup_, "wheel", this, this.onMouseWheel_));
    if (this.options.hasCategories) {
        if (!LearnBlock.Toolbox) throw Error("Missing require for LearnBlock.Toolbox");
        this.toolbox_ = new LearnBlock.Toolbox(this)
    }
    this.grid_ && this.grid_.update(this.scale);
    this.cursor_.setDrawer(this.getRenderer().makeCursorDrawer(this, !1));
    a = this.cursor_.getDrawer().createDom();
    this.svgGroup_.appendChild(a);
    this.marker_.setDrawer(this.getRenderer().makeCursorDrawer(this, !0));
    a = this.marker_.getDrawer().createDom();
    this.svgGroup_.appendChild(a);
    return this.svgGroup_
};
//Dispose of the workspace
LearnBlock.WorkspaceSvg.prototype.dispose = function () {
    this.rendered = !1;
    this.currentGesture_ && this.currentGesture_.cancel();
    this.svgGroup_ && (LearnBlock.utils.dom.removeNode(this.svgGroup_), this.svgGroup_ = null);
    this.toolbox_ && (this.toolbox_.dispose(), this.toolbox_ = null);
    this.flyout_ && (this.flyout_.dispose(), this.flyout_ = null);
    this.scrollbar && (this.scrollbar.dispose(), this.scrollbar = null);
    this.zoomControls_ &&
        (this.zoomControls_.dispose(), this.zoomControls_ = null);
    this.marker_ && this.marker_.getDrawer().dispose();
    this.getCursor() && this.getCursor().getDrawer().dispose();
    this.audioManager_ && (this.audioManager_.dispose(), this.audioManager_ = null);
    this.grid_ && (this.grid_.dispose(), this.grid_ = null);
    this.themeManager_ && this.themeManager_.unsubscribe(this.svgBackground_);
    LearnBlock.WorkspaceSvg.superClass_.dispose.call(this);
    this.flyoutButtonCallbacks_ = this.toolboxCategoryCallbacks_ = this.connectionDBList = null;
    if (!this.options.parentWorkspace) {
        var a =
            this.getParentSvg().parentNode;
        a && LearnBlock.utils.dom.removeNode(a)
    }
    this.resizeHandlerWrapper_ && (LearnBlock.unbindEvent_(this.resizeHandlerWrapper_), this.resizeHandlerWrapper_ = null)
};
//Obtains a newly created block
LearnBlock.WorkspaceSvg.prototype.newBlock = function (a, b) {
    return new LearnBlock.BlockSvg(this, a, b)
};
//Adds a flyout element in an element with the given tag name
LearnBlock.WorkspaceSvg.prototype.addFlyout_ = function (a) {
    var b = {
        disabledPatternId: this.options.disabledPatternId,
        parentWorkspace: this,
        RTL: this.RTL,
        oneBasedIndex: this.options.oneBasedIndex,
        horizontalLayout: this.horizontalLayout,
        toolboxPosition: this.options.toolboxPosition,
        renderer: this.options.renderer
    };
    if (!LearnBlock.VerticalFlyout) throw Error("Missing require for LearnBlock.VerticalFlyout");
    else this.flyout_ = new LearnBlock.VerticalFlyout(b);
    this.flyout_.autoClose = !1;
    return this.flyout_.createDom(a)
};
//Getter for the flyout associated with the workspace
LearnBlock.WorkspaceSvg.prototype.getFlyout = function () {
    return this.flyout_ ? this.flyout_ : this.toolbox_ ? this.toolbox_.flyout_ : null
};
//Getter for the toolbox associated with the workspace
LearnBlock.WorkspaceSvg.prototype.getToolbox = function () {
    return this.toolbox_
};
//Updates items that use screen coordinate calculations
LearnBlock.WorkspaceSvg.prototype.updateScreenCalculations_ = function () {
    this.updateInverseScreenCTM()
};
//Resizes the parts of the workspace that change when the workspace contents change
LearnBlock.WorkspaceSvg.prototype.resizeContents = function () {
    if (this.resizesEnabled_ && this.rendered) {
        if (this.scrollbar) {
            var a = this.getMetrics();
            this.scrollbar.hScroll.resizeContentHorizontal(a);
            this.scrollbar.vScroll.resizeContentVertical(a)
        }
        this.updateInverseScreenCTM()
    }
};
//Resizes and repositions all of the workspace chrome
LearnBlock.WorkspaceSvg.prototype.resize = function () {
    this.toolbox_ && this.toolbox_.position();
    this.flyout_ && this.flyout_.position();
    this.scrollbar && this.scrollbar.resize();
    this.updateScreenCalculations_()
};
//Resizes and repositions workspace chrome if the page has a new scroll position
LearnBlock.WorkspaceSvg.prototype.updateScreenCalculationsIfScrolled = function () {
    var a = LearnBlock.utils.getDocumentScroll();
    LearnBlock.utils.Coordinate.equals(this.lastRecordedPageScroll_, a) || (this.lastRecordedPageScroll_ = a, this.updateScreenCalculations_())
};
//Gets the SVG element that forms the drawing surface
LearnBlock.WorkspaceSvg.prototype.getCanvas = function () {
    return this.svgBlockCanvas_
};
//Gets the SVG element that contains this workspace
LearnBlock.WorkspaceSvg.prototype.getParentSvg = function () {
    if (this.cachedParentSvg_) return this.cachedParentSvg_;
    for (var a = this.svgGroup_; a;) {
        if ("svg" == a.tagName) return this.cachedParentSvg_ = a;
        a = a.parentNode
    }
    return null
};
//Translates the workspace to new coordinates
LearnBlock.WorkspaceSvg.prototype.translate = function (a, b) {
    if (this.useWorkspaceDragSurface_ && this.isDragSurfaceActive_) this.workspaceDragSurface_.translateSurface(a, b);
    else {
        var c = "translate(" + a + "," + b + ") scale(" + this.scale + ")";
        this.svgBlockCanvas_.setAttribute("transform", c);
    }
    this.blockDragSurface_ && this.blockDragSurface_.translateAndScaleGroup(a, b, this.scale);
    this.grid_ && this.grid_.moveTo(a, b)
};
//Takes the contents out of the drag surface and puts them back into the workspace SVG
LearnBlock.WorkspaceSvg.prototype.resetDragSurface = function () {
    if (this.useWorkspaceDragSurface_) {
        this.isDragSurfaceActive_ = !1;
        var a = this.workspaceDragSurface_.getSurfaceTranslation();
        this.workspaceDragSurface_.clearAndHide(this.svgGroup_);
        a = "translate(" + a.x + "," + a.y + ") scale(" + this.scale + ")";
        this.svgBlockCanvas_.setAttribute("transform", a);
    }
};
//Moves contents of the workspace to the drag surface
LearnBlock.WorkspaceSvg.prototype.setupDragSurface = function () {
    if (this.useWorkspaceDragSurface_ && !this.isDragSurfaceActive_) {
        this.isDragSurfaceActive_ = !0;
        var a = this.svgBlockCanvas_.previousSibling,
            b = parseInt(this.getParentSvg().getAttribute("width"), 10),
            c = parseInt(this.getParentSvg().getAttribute("height"), 10),
            d = LearnBlock.utils.getRelativeXY(this.svgBlockCanvas_);
        this.workspaceDragSurface_.setContentsAndShow(this.svgBlockCanvas_, a, b, c, this.scale);
        this.workspaceDragSurface_.translateSurface(d.x,
            d.y)
    }
};
//Returns the workspace's block drag surface
LearnBlock.WorkspaceSvg.prototype.getBlockDragSurface = function () {
    return this.blockDragSurface_
};
//Returns the horizontal offset of the workspace
LearnBlock.WorkspaceSvg.prototype.getWidth = function () {
    var a = this.getMetrics();
    return a ? a.viewWidth / this.scale : 0
};
//Toggles the visibility of the workspace
LearnBlock.WorkspaceSvg.prototype.setVisible = function (a) {
    this.scrollbar && this.scrollbar.setContainerVisible(a);
    this.getFlyout() && this.getFlyout().setContainerVisible(a);
    this.getParentSvg().style.display = a ? "block" : "none";
    this.toolbox_ && (this.toolbox_.HtmlDiv.style.display = a ? "block" : "none");
    if (a) {
        for (var b = this.getAllBlocks(!1), c = b.length - 1; 0 <= c; c--) b[c].markDirty();
        this.render();
        this.toolbox_ && this.toolbox_.position()
    } else LearnBlock.hideChaff(!0);
    this.isVisible_ = a
};
//Renders all blocks in workspace
LearnBlock.WorkspaceSvg.prototype.render = function () {
    for (var a = this.getAllBlocks(!1), b = a.length - 1; 0 <= b; b--) a[b].render(!1);
    if (this.currentGesture_)
        for (a = this.currentGesture_.getInsertionMarkers(), b = 0; b < a.length; b++) a[b].render(!1)
};
//Highlights or unhighlights a block in the workspace
LearnBlock.WorkspaceSvg.prototype.highlightBlock = function (a, b) {
    if (void 0 === b) {
        for (var c = 0, d; d = this.highlightedBlocks_[c]; c++) d.setHighlighted(!1);
        this.highlightedBlocks_.length = 0
    }
    if (d = a ? this.getBlockById(a) : null)(c = void 0 === b || b) ? -1 == this.highlightedBlocks_.indexOf(d) && this.highlightedBlocks_.push(d) : LearnBlock.utils.arrayRemove(this.highlightedBlocks_, d), d.setHighlighted(c)
};
//Pastes the provided block onto the workspace
LearnBlock.WorkspaceSvg.prototype.paste = function (a) {
    !this.rendered || a.getElementsByTagName("block").length >= this.remainingCapacity() || (this.currentGesture_ && this.currentGesture_.cancel(), "comment" == a.tagName.toLowerCase() ? this.pasteWorkspaceComment_(a) : this.pasteBlock_(a))
};
LearnBlock.WorkspaceSvg.prototype.pasteBlock_ = function (a) {
    LearnBlock.Events.disable();
    try {
        var b = LearnBlock.Xml.domToBlock(a, this),
            c = this.getMarker().getCurNode();
        if (LearnBlock.keyboardAccessibilityMode && c) {
            LearnBlock.navigation.insertBlock(b, c.getLocation());
            return
        }
        var d = parseInt(a.getAttribute("x"), 10),
            e = parseInt(a.getAttribute("y"), 10);
        if (!isNaN(d) && !isNaN(e)) {
            this.RTL && (d = -d);
            do {
                a = !1;
                var f = this.getAllBlocks(!1);
                c = 0;
                for (var g; g = f[c]; c++) {
                    var h = g.getRelativeToSurfaceXY();
                    if (1 >= Math.abs(d - h.x) && 1 >= Math.abs(e - h.y)) {
                        a = !0;
                        break
                    }
                }
                if (!a) {
                    var k = b.getConnections_(!1);
                    c = 0;
                    for (var l; l = k[c]; c++)
                        if (l.closest(LearnBlock.SNAP_RADIUS, new LearnBlock.utils.Coordinate(d, e)).connection) {
                            a = !0;
                            break
                        }
                }
                a && (d = this.RTL ? d - LearnBlock.SNAP_RADIUS : d + LearnBlock.SNAP_RADIUS, e += 2 * LearnBlock.SNAP_RADIUS)
            } while (a);
            b.moveBy(d, e)
        }
    } finally {
        LearnBlock.Events.enable()
    }
    LearnBlock.Events.isEnabled() && LearnBlock.Events.fire(new LearnBlock.Events.BlockCreate(b));
    b.select()
};
//Refreshes the toolbox unless there's a drag in progress
LearnBlock.WorkspaceSvg.prototype.refreshToolboxSelection = function () {
    var a = this.isFlyout ? this.targetWorkspace : this;
    a && !a.currentGesture_ && a.toolbox_ && a.toolbox_.flyout_ && a.toolbox_.refreshSelection()
};
//Renames a variable by updating its name in the variable map
LearnBlock.WorkspaceSvg.prototype.renameVariableById = function (a, b) {
    LearnBlock.WorkspaceSvg.superClass_.renameVariableById.call(this, a, b);
    this.refreshToolboxSelection()
};
//Deletes a variable by the passed in ID
LearnBlock.WorkspaceSvg.prototype.deleteVariableById = function (a) {
    LearnBlock.WorkspaceSvg.superClass_.deleteVariableById.call(this, a);
    this.refreshToolboxSelection()
};
//Creates a new variable with the given name
LearnBlock.WorkspaceSvg.prototype.createVariable = function (a, b, c) {
    a = LearnBlock.WorkspaceSvg.superClass_.createVariable.call(this, a, b, c);
    this.refreshToolboxSelection();
    return a
};
//Handles a mouse-down on SVG drawing surface
LearnBlock.WorkspaceSvg.prototype.onMouseDown_ = function (a) {
    var b = this.getGesture(a);
    b && b.handleWsStart(a, this)
};
//Starts tracking a drag of an object on this workspace
LearnBlock.WorkspaceSvg.prototype.startDrag = function (a, b) {
    var c = LearnBlock.utils.mouseToSvg(a, this.getParentSvg(), this.getInverseScreenCTM());
    c.x /= this.scale;
    c.y /= this.scale;
    this.dragDeltaXY_ = LearnBlock.utils.Coordinate.difference(b, c)
};
//Tracks a drag of an object on this workspace
LearnBlock.WorkspaceSvg.prototype.moveDrag = function (a) {
    a = LearnBlock.utils.mouseToSvg(a, this.getParentSvg(), this.getInverseScreenCTM());
    a.x /= this.scale;
    a.y /= this.scale;
    return LearnBlock.utils.Coordinate.sum(this.dragDeltaXY_, a)
};
//Is the user currently dragging a block or scrolling the flyout/workspace?
LearnBlock.WorkspaceSvg.prototype.isDragging = function () {
    return null != this.currentGesture_ && this.currentGesture_.isDragging()
};
//Is this workspace draggable?
LearnBlock.WorkspaceSvg.prototype.isDraggable = function () {
    return this.options.moveOptions && this.options.moveOptions.drag
};
//Should the workspace have bounded content?
LearnBlock.WorkspaceSvg.prototype.isContentBounded = function () {
    return this.options.moveOptions && this.options.moveOptions.scrollbars || this.options.moveOptions && this.options.moveOptions.wheel || this.options.moveOptions && this.options.moveOptions.drag || this.options.zoomOptions && this.options.zoomOptions.controls || this.options.zoomOptions && this.options.zoomOptions.wheel
};
//Is this workspace movable?
LearnBlock.WorkspaceSvg.prototype.isMovable = function () {
    return this.options.moveOptions && this.options.moveOptions.scrollbars || this.options.moveOptions && this.options.moveOptions.wheel || this.options.moveOptions && this.options.moveOptions.drag || this.options.zoomOptions && this.options.zoomOptions.wheel
};
//Handles a mouse-wheel on SVG drawing surface
LearnBlock.WorkspaceSvg.prototype.onMouseWheel_ = function (a) {
    if (LearnBlock.Gesture.inProgress()) a.preventDefault(), a.stopPropagation();
    else {
        var b = this.options.zoomOptions && this.options.zoomOptions.wheel,
            c = this.options.moveOptions && this.options.moveOptions.wheel;
        if (b || c) {
            var d = LearnBlock.utils.getScrollDeltaPixels(a);
            !b || !a.ctrlKey && c ? (b = this.scrollX - d.x, c = this.scrollY - d.y, a.shiftKey && !d.x && (b = this.scrollX - d.y, c = this.scrollY), this.scroll(b, c)) : (d = -d.y / 50, b = LearnBlock.utils.mouseToSvg(a, this.getParentSvg(), this.getInverseScreenCTM()),
                this.zoom(b.x, b.y, d));
            a.preventDefault()
        }
    }
};
//Calculates the bounding box for the blocks on the workspace
LearnBlock.WorkspaceSvg.prototype.getBlocksBoundingBox = function () {
    var a = this.getTopBlocks(!1);
    if (!a.length) return new LearnBlock.utils.Rect(0, 0, 0, 0);
    var b = a[0].getBoundingRectangle();
    for (var c = 1; c < a.length; c++) {
        var d = a[c].getBoundingRectangle();
        d.top < b.top && (b.top = d.top);
        d.bottom > b.bottom && (b.bottom = d.bottom);
        d.left < b.left && (b.left = d.left);
        d.right > b.right && (b.right = d.right)
    }
    return b
};
//Shows the context menu for the workspace
LearnBlock.WorkspaceSvg.prototype.showContextMenu_ = function (a) {
    function b(a) {
        if (a.isDeletable()) p = p.concat(a.getDescendants(!1));
        else {
            a = a.getChildren(!1);
            for (var c = 0; c < a.length; c++) b(a[c])
        }
    }

    function c() {
        LearnBlock.Events.setGroup(f);
        var a = p.shift();
        a && (a.workspace ? (a.dispose(!1, !0), setTimeout(c, 10)) : c());
        LearnBlock.Events.setGroup(!1)
    }
    if (!this.options.readOnly && !this.isFlyout) {
        var d = [],
            e = this.getTopBlocks(!0),
            f = LearnBlock.utils.genUid(),
            g = this,
            h = {};
        h.text = LearnBlock.Msg.UNDO;
        h.enabled = 0 < this.undoStack_.length;
        h.callback =
            this.undo.bind(this, !1);
        d.push(h);
        h = {};
        h.text = LearnBlock.Msg.REDO;
        h.enabled = 0 < this.redoStack_.length;
        h.callback = this.undo.bind(this, !0);
        d.push(h);
        var p = [];
        for (var l = 0; l < e.length; l++) b(e[l]);
        h = {
            text: 1 == p.length ? LearnBlock.Msg.DELETE_BLOCK : LearnBlock.Msg.DELETE_X_BLOCKS.replace("%1", String(p.length)),
            enabled: 0 < p.length,
            callback: function () {
                g.currentGesture_ && g.currentGesture_.cancel();
                2 > p.length ? c() : LearnBlock.confirm(LearnBlock.Msg.DELETE_ALL_BLOCKS.replace("%1", p.length), function (a) {
                    a &&
                        c()
                })
            }
        };
        d.push(h);
        this.configureContextMenu && this.configureContextMenu(d);
        LearnBlock.ContextMenu.show(a, d, this.RTL)
    }
};
//Modifies the block tree on the existing toolbox
LearnBlock.WorkspaceSvg.prototype.updateToolbox = function (a) {
    if (a = LearnBlock.Options.parseToolboxTree(a)) {
        if (!this.options.languageTree) throw Error("Existing toolbox is null.  Can't create new toolbox.");
        if (a.getElementsByTagName("category").length) {
            if (!this.toolbox_) throw Error("Existing toolbox has no categories.  Can't change mode.");
            this.options.languageTree = a;
            this.toolbox_.renderTree(a)
        } else {
            if (!this.flyout_) throw Error("Existing toolbox has categories.  Can't change mode.");
            this.options.languageTree =
                a;
            this.flyout_.show(a.childNodes)
        }
    } else if (this.options.languageTree) throw Error("Can't nullify an existing toolbox.");
};
//Marks the workspace as the currently focused main workspace
LearnBlock.WorkspaceSvg.prototype.markFocused = function () {
    this.options.parentWorkspace ? this.options.parentWorkspace.markFocused() : (LearnBlock.mainWorkspace = this, this.setBrowserFocus())
};
//Sets the workspace to have focus in the browser
LearnBlock.WorkspaceSvg.prototype.setBrowserFocus = function () {
    document.activeElement && document.activeElement.blur();
    try {
        this.getParentSvg().focus()
    } catch (a) {
        try {
            this.getParentSvg().parentNode.setActive()
        } catch (b) {
            this.getParentSvg().parentNode.focus()
        }
    }
};
//Adds a transition class to the block canvas to animate any transform changes
LearnBlock.WorkspaceSvg.prototype.beginCanvasTransition = function () {
    LearnBlock.utils.dom.addClass(this.svgBlockCanvas_, "blocklyCanvasTransitioning");
};
//Removes transition class from the block canvas
LearnBlock.WorkspaceSvg.prototype.endCanvasTransition = function () {
    LearnBlock.utils.dom.removeClass(this.svgBlockCanvas_, "blocklyCanvasTransitioning");
};
//Sets the workspace's zoom factor
LearnBlock.WorkspaceSvg.prototype.setScale = function (a) {
    this.options.zoomOptions.maxScale && a > this.options.zoomOptions.maxScale ? a = this.options.zoomOptions.maxScale : this.options.zoomOptions.minScale && a < this.options.zoomOptions.minScale && (a = this.options.zoomOptions.minScale);
    this.scale = a;
    LearnBlock.hideChaff(!1);
    this.flyout_ && (this.flyout_.reflow());
    this.grid_ && this.grid_.update(this.scale);
    a = this.getMetrics();
    this.scrollX -= a.absoluteLeft;
    this.scrollY -= a.absoluteTop;
    a.viewLeft += a.absoluteLeft;
    a.viewTop += a.absoluteTop;
    this.scroll(this.scrollX, this.scrollY);
    this.scrollbar && (this.flyout_ ? (this.scrollbar.hScroll.resizeViewHorizontal(a), this.scrollbar.vScroll.resizeViewVertical(a)) : (this.scrollbar.hScroll.resizeContentHorizontal(a), this.scrollbar.vScroll.resizeContentVertical(a)))
};
//Scrolls the workspace to a specified offset
LearnBlock.WorkspaceSvg.prototype.scroll = function (a, b) {
    LearnBlock.hideChaff(!0);
    var c = this.getMetrics(),
        d = c.contentWidth + c.contentLeft - c.viewWidth,
        e = c.contentHeight + c.contentTop - c.viewHeight;
    a = Math.min(a, -c.contentLeft);
    b = Math.min(b, -c.contentTop);
    a = Math.max(a, -d);
    b = Math.max(b, -e);
    this.scrollX = a;
    this.scrollY = b;
    this.scrollbar && (this.scrollbar.hScroll.setHandlePosition(-(a + c.contentLeft) * this.scrollbar.hScroll.ratio_), this.scrollbar.vScroll.setHandlePosition(-(b + c.contentTop) * this.scrollbar.vScroll.ratio_));
    a += c.absoluteLeft;
    b += c.absoluteTop;
    this.translate(a, b)
};
//Gets the dimensions of the given workspace component in pixels
LearnBlock.WorkspaceSvg.getDimensionsPx_ = function (a) {
    var b = 0,
        c = 0;
    a && (b = a.getWidth(), c = a.getHeight());
    return {
        width: b,
        height: c
    }
};
//Gets the content dimensions of the given workspace
LearnBlock.WorkspaceSvg.getContentDimensions_ = function (a, b) {
    return a.isContentBounded() ? LearnBlock.WorkspaceSvg.getContentDimensionsBounded_(a, b) : LearnBlock.WorkspaceSvg.getContentDimensionsExact_(a)
};
//Gets the bounding box for all workspace contents
LearnBlock.WorkspaceSvg.getContentDimensionsExact_ = function (a) {
    var b = a.getBlocksBoundingBox(),
        c = a.scale;
    a = b.top * c;
    var d = b.bottom * c,
        e = b.left * c;
    b = b.right * c;
    return {
        top: a,
        bottom: d,
        left: e,
        right: b,
        width: b - e,
        height: d - a
    }
};
//Calculates the size of a scrollable workspace
LearnBlock.WorkspaceSvg.getContentDimensionsBounded_ = function (a, b) {
    var c = LearnBlock.WorkspaceSvg.getContentDimensionsExact_(a),
        d = b.width,
        e = b.height,
        f = d / 2,
        g = e / 2,
        h = Math.min(c.left - f, c.right - d),
        k = Math.min(c.top - g, c.bottom - e);
    return {
        left: h,
        top: k,
        height: Math.max(c.bottom + g, c.top + e) - k,
        width: Math.max(c.right + f, c.left + d) - h
    }
};
//Returns an object with all the metrics required to size scrollbars for a top level workspace
LearnBlock.WorkspaceSvg.getTopLevelWorkspaceMetrics_ = function () {
    var a = LearnBlock.WorkspaceSvg.getDimensionsPx_(this.toolbox_),
        b = LearnBlock.WorkspaceSvg.getDimensionsPx_(this.flyout_),
        c = LearnBlock.svgSize(this.getParentSvg()),
        d = {
            height: c.height,
            width: c.width
        };
    if (this.toolbox_)
        if (this.toolboxPosition == LearnBlock.TOOLBOX_AT_TOP || this.toolboxPosition == LearnBlock.TOOLBOX_AT_BOTTOM) d.height -= a.height;
        else {
            if (this.toolboxPosition == LearnBlock.TOOLBOX_AT_LEFT || this.toolboxPosition == LearnBlock.TOOLBOX_AT_RIGHT) d.width -= a.width
        }
    else if (this.flyout_)
        if (this.toolboxPosition ==
            LearnBlock.TOOLBOX_AT_TOP || this.toolboxPosition == LearnBlock.TOOLBOX_AT_BOTTOM) d.height -= b.height;
        else if (this.toolboxPosition == LearnBlock.TOOLBOX_AT_LEFT || this.toolboxPosition == LearnBlock.TOOLBOX_AT_RIGHT) d.width -= b.width;
    var e = LearnBlock.WorkspaceSvg.getContentDimensions_(this, d),
        f = 0;
    this.toolbox_ && this.toolboxPosition == LearnBlock.TOOLBOX_AT_LEFT ? f = a.width : this.flyout_ && this.toolboxPosition == LearnBlock.TOOLBOX_AT_LEFT && (f = b.width);
    var g = 0;
    this.toolbox_ && this.toolboxPosition == LearnBlock.TOOLBOX_AT_TOP ? g = a.height : this.flyout_ &&
        this.toolboxPosition == LearnBlock.TOOLBOX_AT_TOP && (g = b.height);
    return {
        contentHeight: e.height,
        contentWidth: e.width,
        contentTop: e.top,
        contentLeft: e.left,
        viewHeight: d.height,
        viewWidth: d.width,
        viewTop: -this.scrollY,
        viewLeft: -this.scrollX,
        absoluteTop: g,
        absoluteLeft: f,
        svgHeight: c.height,
        svgWidth: c.width,
        toolboxWidth: a.width,
        toolboxHeight: a.height,
        flyoutWidth: b.width,
        flyoutHeight: b.height,
        toolboxPosition: this.toolboxPosition
    }
};
//Sets the X/Y translations of a top level workspace
LearnBlock.WorkspaceSvg.setTopLevelWorkspaceMetrics_ = function (a) {
    var b = this.getMetrics();
    "number" == typeof a.x && (this.scrollX = -b.contentWidth * a.x - b.contentLeft);
    "number" == typeof a.y && (this.scrollY = -b.contentHeight * a.y - b.contentTop);
    this.translate(this.scrollX + b.absoluteLeft, this.scrollY + b.absoluteTop)
};
//Updates whether the workspace has resizes enabled
LearnBlock.WorkspaceSvg.prototype.setResizesEnabled = function (a) {
    var b = !this.resizesEnabled_ && a;
    this.resizesEnabled_ = a;
    b && this.resizeContents()
};
//Dispose of all blocks in workspace
LearnBlock.WorkspaceSvg.prototype.clear = function () {
    this.setResizesEnabled(!1);
    LearnBlock.WorkspaceSvg.superClass_.clear.call(this);
    this.setResizesEnabled(!0)
};
//Registers a callback function for clicks on buttons in the flyout
LearnBlock.WorkspaceSvg.prototype.registerButtonCallback = function (a, b) {
    if ("function" != typeof b) throw TypeError("Button callbacks must be functions.");
    this.flyoutButtonCallbacks_[a] = b
};
//Gets the callback function for clicks on buttons in the flyout
LearnBlock.WorkspaceSvg.prototype.getButtonCallback = function (a) {
    return (a = this.flyoutButtonCallbacks_[a]) ? a : null
};
//Removes a callback for a click on a button in the flyout
LearnBlock.WorkspaceSvg.prototype.removeButtonCallback = function (a) {
    this.flyoutButtonCallbacks_[a] = null
};
//Registers a callback function for populating custom toolbox categories in this workspace
LearnBlock.WorkspaceSvg.prototype.registerToolboxCategoryCallback = function (a, b) {
    if ("function" != typeof b) throw TypeError("Toolbox category callbacks must be functions.");
    this.toolboxCategoryCallbacks_[a] = b
};
//Gets the callback function for populating custom toolbox categories in this workspace
LearnBlock.WorkspaceSvg.prototype.getToolboxCategoryCallback = function (a) {
    return this.toolboxCategoryCallbacks_[a] || null
};
//Removes a callback for a click on a custom category's name in the toolbox
LearnBlock.WorkspaceSvg.prototype.removeToolboxCategoryCallback = function (a) {
    this.toolboxCategoryCallbacks_[a] = null
};
//Looks up the gesture that is tracking this touch stream on this workspace
LearnBlock.WorkspaceSvg.prototype.getGesture = function (a) {
    var b = "mousedown" == a.type || "touchstart" == a.type || "pointerdown" == a.type,
        c = this.currentGesture_;
    return c ? b && c.hasStarted() ? (console.warn("Tried to start the same gesture twice."), c.cancel(), null) : c : b ? this.currentGesture_ = new LearnBlock.TouchGesture(a, this) : null
};
//Clears the reference to the current gesture
LearnBlock.WorkspaceSvg.prototype.clearGesture = function () {
    this.currentGesture_ = null
};
//Cancels the current gesture, if one exists
LearnBlock.WorkspaceSvg.prototype.cancelCurrentGesture = function () {
    this.currentGesture_ && this.currentGesture_.cancel()
};
//Gets the grid object for the workspace, or null if there is none
LearnBlock.WorkspaceSvg.prototype.getGrid = function () {
    return this.grid_
};
//Refreshes all blocks on the workspace, toolbox and flyout after a theme update
LearnBlock.WorkspaceSvg.prototype.refreshTheme = function () {
    LearnBlock.WorkspaceSvg.superClass_.refreshTheme.call(this);
    this.refreshToolboxSelection();
    this.toolbox_ && this.toolbox_.updateColourFromTheme()
};

//Injects an editor into the specified container element
LearnBlock.inject = function (a, b) {
    "string" == typeof a && (a = document.getElementById(a) || document.querySelector(a));
    if (!LearnBlock.utils.dom.containsNode(document, a)) throw Error("Error: container is not in current document.");
    var c = new LearnBlock.Options(b || {}),
        d = document.createElement("div");
    d.className = "injectionDiv";
    a.appendChild(d);
    var e = LearnBlock.createDom_(d, c),
        f = new LearnBlock.BlockDragSurfaceSvg(d);
    d = new LearnBlock.WorkspaceDragSurfaceSvg(d);
    e = LearnBlock.createMainWorkspace_(e, c,
        f, d);
    LearnBlock.user.keyMap.setKeyMap(c.keyMap);
    LearnBlock.init_(e);
    LearnBlock.mainWorkspace = e;
    LearnBlock.svgResize(e);
    return e
};
//Creates the SVG image
LearnBlock.createDom_ = function (a, b) {
    a.setAttribute("dir", "LTR");
    LearnBlock.Component.defaultRightToLeft = b.RTL;
    LearnBlock.Css.inject(b.hasCss, b.pathToMedia);
    var c = LearnBlock.utils.dom.createSvgElement("svg", {
            xmlns: LearnBlock.utils.dom.SVG_NS,
            "xmlns:html": LearnBlock.utils.dom.HTML_NS,
            "xmlns:xlink": LearnBlock.utils.dom.XLINK_NS,
            version: "1.1",
            "class": "blocklySvg"
        }, a),
        d = LearnBlock.utils.dom.createSvgElement("defs", {}, c),
        e = String(Math.random()).substring(2),
        f = LearnBlock.utils.dom.createSvgElement("filter", {
            id: "blocklyEmbossFilter" +
                e
        }, d);
    LearnBlock.utils.dom.createSvgElement("feGaussianBlur", {
        "in": "SourceAlpha",
        stdDeviation: 1,
        result: "blur"
    }, f);
    var g = LearnBlock.utils.dom.createSvgElement("feSpecularLighting", {
        "in": "blur",
        surfaceScale: 1,
        specularConstant: .5,
        specularExponent: 10,
        "lighting-color": "white",
        result: "specOut"
    }, f);
    LearnBlock.utils.dom.createSvgElement("fePointLight", {
        x: -5E3,
        y: -1E4,
        z: 2E4
    }, g);
    LearnBlock.utils.dom.createSvgElement("feComposite", {
        "in": "specOut",
        in2: "SourceAlpha",
        operator: "in",
        result: "specOut"
    }, f);
    LearnBlock.utils.dom.createSvgElement("feComposite", {
        "in": "SourceGraphic",
        in2: "specOut",
        operator: "arithmetic",
        k1: 0,
        k2: 1,
        k3: 1,
        k4: 0
    }, f);
    b.embossFilterId = f.id;
    f = LearnBlock.utils.dom.createSvgElement("pattern", {
        id: "blocklyDisabledPattern" + e,
        patternUnits: "userSpaceOnUse",
        width: 10,
        height: 10
    }, d);
    LearnBlock.utils.dom.createSvgElement("rect", {
        width: 10,
        height: 10,
        fill: "#aaa"
    }, f);
    LearnBlock.utils.dom.createSvgElement("path", {
        d: "M 0 0 L 10 10 M 10 0 L 0 10",
        stroke: "#cc0"
    }, f);
    b.disabledPatternId = f.id;
    b.gridPattern = LearnBlock.Grid.createDom(e, b.gridOptions, d);
    return c
};
//Creates a main workspace and adds it to the SVG
LearnBlock.createMainWorkspace_ = function (a, b, c, d) {
    b.parentWorkspace = null;
    var e = new LearnBlock.WorkspaceSvg(b, c, d);
    e.scale = b.zoomOptions.startScale;
    a.appendChild(e.createDom("blocklyMainBackground"));
    !b.hasCategories && b.languageTree && (c = e.addFlyout_("svg"), LearnBlock.utils.dom.insertAfter(c, a));
    b.zoomOptions && b.zoomOptions.controls && e.addZoomControls();
    e.getThemeManager().subscribe(a, "workspace", "background-color");
    e.translate(0, 0);
    LearnBlock.mainWorkspace = e;
    b.readOnly || e.isMovable() ||
        e.addChangeListener(function (a) {
            if (!e.isDragging() && !e.isMovable() && -1 != LearnBlock.Events.BUMP_EVENTS.indexOf(a.type)) {
                var b = Object.create(null),
                    c = e.getMetrics(),
                    d = e.scale;
                b.RTL = e.RTL;
                b.viewLeft = c.viewLeft / d;
                b.viewTop = c.viewTop / d;
                b.viewRight = (c.viewLeft + c.viewWidth) / d;
                b.viewBottom = (c.viewTop + c.viewHeight) / d;
                e.isContentBounded() ? (c = e.getBlocksBoundingBox(), b.contentLeft = c.left, b.contentTop = c.top, b.contentRight = c.right, b.contentBottom = c.bottom) : (b.contentLeft = c.contentLeft / d, b.contentTop = c.contentTop /
                    d, b.contentRight = (c.contentLeft + c.contentWidth) / d, b.contentBottom = (c.contentTop + c.contentHeight) / d);
                if (b.contentTop < b.viewTop || b.contentBottom > b.viewBottom || b.contentLeft < b.viewLeft || b.contentRight > b.viewRight) {
                    c = null;
                    a && (c = LearnBlock.Events.getGroup(), LearnBlock.Events.setGroup(a.group));
                    switch (a.type) {
                        case LearnBlock.Events.BLOCK_CREATE:
                        case LearnBlock.Events.BLOCK_MOVE:
                            var f = e.getBlockById(a.blockId);
                            f = f.getRootBlock();
                            break;
                        case LearnBlock.Events.COMMENT_CREATE:
                        case LearnBlock.Events.COMMENT_MOVE:
                            f = e.getCommentById(a.commentId)
                    }
                    if (f) {
                        d =
                            f.getBoundingRectangle();
                        d.height = d.bottom - d.top;
                        d.width = d.right - d.left;
                        var m = b.viewTop,
                            n = b.viewBottom - d.height;
                        n = Math.max(m, n);
                        m = LearnBlock.utils.math.clamp(m, d.top, n) - d.top;
                        n = b.viewLeft;
                        var p = b.viewRight - d.width;
                        b.RTL ? n = Math.min(p, n) : p = Math.max(n, p);
                        b = LearnBlock.utils.math.clamp(n, d.left, p) - d.left;
                        f.moveBy(b, m)
                    }
                    a && (a.group || console.log("WARNING: Moved object in bounds but there was no event group. This may break undo."), null !== c && LearnBlock.Events.setGroup(c))
                }
            }
        });
    LearnBlock.svgResize(e);
    LearnBlock.WidgetDiv.createDom();
    LearnBlock.DropDownDiv.createDom();
    return e
};
//Initializes LearnBlock with various handlers
LearnBlock.init_ = function (a) {
    var b = a.options,
        c = a.getParentSvg();
    LearnBlock.bindEventWithChecks_(c.parentNode, "contextmenu", null, function (a) {
        LearnBlock.utils.isTargetInput(a) || a.preventDefault()
    });
    c = LearnBlock.bindEventWithChecks_(window, "resize", null, function () {
        LearnBlock.hideChaff(!0);
        LearnBlock.svgResize(a)
    });
    a.setResizeHandlerWrapper(c);
    LearnBlock.inject.bindDocumentEvents_();
    b.languageTree && (a.toolbox_ ? a.toolbox_.init(a) : a.flyout_ && (a.flyout_.init(a), a.flyout_.show(b.languageTree.childNodes), a.flyout_.scrollToStart()));
    c = LearnBlock.Scrollbar.scrollbarThickness;
    b.moveOptions && b.moveOptions.scrollbars ? (a.scrollbar = new LearnBlock.ScrollbarPair(a), a.scrollbar.resize()) : a.setMetrics({
        x: .5,
        y: .5
    });
};
//Binds document events
LearnBlock.inject.bindDocumentEvents_ = function () {
    LearnBlock.documentEventsBound_ || (LearnBlock.bindEventWithChecks_(document, "scroll", null, function () {
        for (var a = LearnBlock.Workspace.getAll(), b = 0, c; c = a[b]; b++) c.updateInverseScreenCTM && c.updateInverseScreenCTM()
    }), LearnBlock.bindEventWithChecks_(document, "keydown", null, LearnBlock.onKeyDown_), LearnBlock.bindEvent_(document, "touchend", null, LearnBlock.longStop_), LearnBlock.bindEvent_(document, "touchcancel", null, LearnBlock.longStop_), LearnBlock.utils.userAgent.IPAD && LearnBlock.bindEventWithChecks_(window,
        "orientationchange", document,
        function () {
            LearnBlock.svgResize(LearnBlock.getMainWorkspace())
        }));
    LearnBlock.documentEventsBound_ = !0
};

//Class for a single action
LearnBlock.Action = function (a, b) {
    this.name = a;
    this.desc = b
};

//Class for an AST node
LearnBlock.ASTNode = function (a, b, c) {
    if (!b) throw Error("Cannot create a node without a location.");
    this.type_ = a;
    this.isConnection_ = LearnBlock.ASTNode.isConnectionType_(a);
    this.location_ = b;
    this.processParams_(c || null)
};
//Object holding different types for an AST node
LearnBlock.ASTNode.types = {
    FIELD: "field",
    BLOCK: "block",
    INPUT: "input",
    OUTPUT: "output",
    NEXT: "next",
    PREVIOUS: "previous",
    STACK: "stack",
    WORKSPACE: "workspace"
};
//The default y offset to use when moving the cursor
LearnBlock.ASTNode.DEFAULT_OFFSET_Y = -20;
//Whether an AST node of the given type points to a connection
LearnBlock.ASTNode.isConnectionType_ = function (a) {
    switch (a) {
        case LearnBlock.ASTNode.types.PREVIOUS:
        case LearnBlock.ASTNode.types.NEXT:
        case LearnBlock.ASTNode.types.INPUT:
        case LearnBlock.ASTNode.types.OUTPUT:
            return !0
    }
    return !1
};
//Creates an AST node pointing to a field
LearnBlock.ASTNode.createFieldNode = function (a) {
    return new LearnBlock.ASTNode(LearnBlock.ASTNode.types.FIELD, a)
};
//Creates an AST node pointing to a connection
LearnBlock.ASTNode.createConnectionNode = function (a) {
    return a ? a.type == LearnBlock.INPUT_VALUE || a.type == LearnBlock.NEXT_STATEMENT && a.getParentInput() ? LearnBlock.ASTNode.createInputNode(a.getParentInput()) : a.type == LearnBlock.NEXT_STATEMENT ? new LearnBlock.ASTNode(LearnBlock.ASTNode.types.NEXT, a) : a.type == LearnBlock.OUTPUT_VALUE ? new LearnBlock.ASTNode(LearnBlock.ASTNode.types.OUTPUT, a) : a.type == LearnBlock.PREVIOUS_STATEMENT ? new LearnBlock.ASTNode(LearnBlock.ASTNode.types.PREVIOUS, a) : null : null
};
//Creates an AST node pointing to an input
LearnBlock.ASTNode.createInputNode = function (a) {
    return a ? new LearnBlock.ASTNode(LearnBlock.ASTNode.types.INPUT, a.connection) : null
};
//Creates an AST node pointing to a block
LearnBlock.ASTNode.createBlockNode = function (a) {
    return new LearnBlock.ASTNode(LearnBlock.ASTNode.types.BLOCK, a)
};
//Creates an AST node of type stack
LearnBlock.ASTNode.createStackNode = function (a) {
    return new LearnBlock.ASTNode(LearnBlock.ASTNode.types.STACK, a)
};
//Creates an AST node pointing to a workspace
LearnBlock.ASTNode.createWorkspaceNode = function (a, b) {
    return new LearnBlock.ASTNode(LearnBlock.ASTNode.types.WORKSPACE, a, {
        wsCoordinate: b
    })
};
//Parses the optional parameters
LearnBlock.ASTNode.prototype.processParams_ = function (a) {
    a && a.wsCoordinate && (this.wsCoordinate_ = a.wsCoordinate)
};
//Gets the value pointed to by this node
LearnBlock.ASTNode.prototype.getLocation = function () {
    return this.location_
};
//The type of the current location
LearnBlock.ASTNode.prototype.getType = function () {
    return this.type_
};
//The coordinate on the workspace
LearnBlock.ASTNode.prototype.getWsCoordinate = function () {
    return this.wsCoordinate_
};
//Whether the node points to a connection
LearnBlock.ASTNode.prototype.isConnection = function () {
    return this.isConnection_
};
//Gets either the previous editable field, or get the first editable field for the given input
LearnBlock.ASTNode.prototype.findPreviousEditableField_ = function (a, b, c) {
    b = b.fieldRow;
    a = b.indexOf(a);
    for (c = (c ? b.length : a) - 1; a = b[c]; c--)
        if (a.EDITABLE) return b = a, LearnBlock.ASTNode.createFieldNode(b);
    return null
};
//Given an input, finds the next editable field or an input with a non null connection in the same block
LearnBlock.ASTNode.prototype.findNextForInput_ = function () {
    var a = this.location_.getParentInput(),
        b = a.getSourceBlock();
    a = b.inputList.indexOf(a) + 1;
    for (var c; c = b.inputList[a]; a++) {
        for (var d = c.fieldRow, e = 0, f; f = d[e]; e++)
            if (f.EDITABLE) return LearnBlock.ASTNode.createFieldNode(f);
        if (c.connection) return LearnBlock.ASTNode.createInputNode(c)
    }
    return null
};
//Given a field, finds the next editable field or an input with a non null connection in the same block
LearnBlock.ASTNode.prototype.findNextForField_ = function () {
    var a = this.location_,
        b = a.getParentInput(),
        c = a.getSourceBlock(),
        d = c.inputList.indexOf(b);
    for (a = b.fieldRow.indexOf(a) + 1; b = c.inputList[d]; d++) {
        for (var e = b.fieldRow; a < e.length;) {
            if (e[a].EDITABLE) return LearnBlock.ASTNode.createFieldNode(e[a]);
            a++
        }
        a = 0;
        if (b.connection) return LearnBlock.ASTNode.createInputNode(b)
    }
    return null
};
//Given an input, finds the previous editable field or an input with a non null connection in the same block
LearnBlock.ASTNode.prototype.findPrevForInput_ = function () {
    for (var a = this.location_.getParentInput(), b = a.getSourceBlock(), c = b.inputList.indexOf(a), d; d = b.inputList[c]; c--) {
        if (d.connection && d !== a) return LearnBlock.ASTNode.createInputNode(d);
        d = d.fieldRow;
        for (var e = d.length - 1, f; f = d[e]; e--)
            if (f.EDITABLE) return LearnBlock.ASTNode.createFieldNode(f)
    }
    return null
};
//Given a field, finds the previous editable field or an input with a non null connection in the same block
LearnBlock.ASTNode.prototype.findPrevForField_ = function () {
    var a = this.location_,
        b = a.getParentInput(),
        c = a.getSourceBlock(),
        d = c.inputList.indexOf(b);
    a = b.fieldRow.indexOf(a) - 1;
    for (var e; e = c.inputList[d]; d--) {
        if (e.connection && e !== b) return LearnBlock.ASTNode.createInputNode(e);
        for (e = e.fieldRow; - 1 < a;) {
            if (e[a].EDITABLE) return LearnBlock.ASTNode.createFieldNode(e[a]);
            a--
        }
        0 <= d - 1 && (a = c.inputList[d - 1].fieldRow.length - 1)
    }
    return null
};
//Navigates between stacks of blocks on the workspace
LearnBlock.ASTNode.prototype.navigateBetweenStacks_ = function (a) {
    var b = this.getLocation();
    b instanceof LearnBlock.Block || (b = b.getSourceBlock());
    if (!b || !b.workspace) return null;
    var c = b.getRootBlock();
    b = c.workspace.getTopBlocks(!0);
    for (var d = 0, e; e = b[d]; d++)
        if (c.id == e.id) return a = d + (a ? 1 : -1), -1 == a || a == b.length ? null : LearnBlock.ASTNode.createStackNode(b[a]);
    throw Error("Couldn't find " + (a ? "next" : "previous") + " stack?!");
};
//Finds the top most AST node for a given block
LearnBlock.ASTNode.prototype.findTopASTNodeForBlock_ = function (a) {
    var b = a.previousConnection || a.outputConnection;
    return b ? LearnBlock.ASTNode.createConnectionNode(b) : LearnBlock.ASTNode.createBlockNode(a)
};
//Gets the AST node pointing to the input that the block is nested under or if the block is not nested then get the stack AST node
LearnBlock.ASTNode.prototype.getOutAstNodeForBlock_ = function (a) {
    if (!a) return null;
    a = a.getTopStackBlock();
    var b = a.previousConnection || a.outputConnection;
    return b && b.targetConnection && b.targetConnection.getParentInput() ? LearnBlock.ASTNode.createInputNode(b.targetConnection.getParentInput()) : LearnBlock.ASTNode.createStackNode(a)
};
//Finds the first editable field or input with a connection on a given block
LearnBlock.ASTNode.prototype.findFirstFieldOrInput_ = function (a) {
    a = a.inputList;
    for (var b = 0, c; c = a[b]; b++) {
        for (var d = c.fieldRow, e = 0, f; f = d[e]; e++)
            if (f.EDITABLE) return LearnBlock.ASTNode.createFieldNode(f);
        if (c.connection) return LearnBlock.ASTNode.createInputNode(c)
    }
    return null
};
//Finds the element to the right of the current element in the AST
LearnBlock.ASTNode.prototype.next = function () {
    switch (this.type_) {
        case LearnBlock.ASTNode.types.STACK:
            return this.navigateBetweenStacks_(!0);
        case LearnBlock.ASTNode.types.OUTPUT:
            return LearnBlock.ASTNode.createBlockNode(this.location_.getSourceBlock());
        case LearnBlock.ASTNode.types.FIELD:
            return this.findNextForField_();
        case LearnBlock.ASTNode.types.INPUT:
            return this.findNextForInput_();
        case LearnBlock.ASTNode.types.BLOCK:
            var a = this.location_.nextConnection;
            if (a) return LearnBlock.ASTNode.createConnectionNode(a);
            break;
        case LearnBlock.ASTNode.types.PREVIOUS:
            return LearnBlock.ASTNode.createBlockNode(this.location_.getSourceBlock());
        case LearnBlock.ASTNode.types.NEXT:
            if (a = this.location_.targetConnection) return LearnBlock.ASTNode.createConnectionNode(a)
    }
    return null
};
//Finds the element one level below and all the way to the left of the current location
LearnBlock.ASTNode.prototype["in"] = function () {
    switch (this.type_) {
        case LearnBlock.ASTNode.types.WORKSPACE:
            var a = this.location_.getTopBlocks(!0);
            if (0 < a.length) return LearnBlock.ASTNode.createStackNode(a[0]);
            break;
        case LearnBlock.ASTNode.types.STACK:
            return this.findTopASTNodeForBlock_(this.location_);
        case LearnBlock.ASTNode.types.BLOCK:
            return this.findFirstFieldOrInput_(this.location_);
        case LearnBlock.ASTNode.types.INPUT:
            if (a = this.location_.targetConnection) return LearnBlock.ASTNode.createConnectionNode(a)
    }
    return null
};
//Finds the element to the left of the current element in the AST
LearnBlock.ASTNode.prototype.prev = function () {
    switch (this.type_) {
        case LearnBlock.ASTNode.types.STACK:
            return this.navigateBetweenStacks_(!1);
        case LearnBlock.ASTNode.types.FIELD:
            return this.findPrevForField_();
        case LearnBlock.ASTNode.types.INPUT:
            return this.findPrevForInput_();
        case LearnBlock.ASTNode.types.BLOCK:
            var a = this.location_.outputConnection;
            if (a = this.location_.previousConnection || a) return LearnBlock.ASTNode.createConnectionNode(a);
            break;
        case LearnBlock.ASTNode.types.PREVIOUS:
            if ((a = this.location_.targetConnection) &&
                !a.getParentInput()) return LearnBlock.ASTNode.createConnectionNode(a);
            break;
        case LearnBlock.ASTNode.types.NEXT:
            return LearnBlock.ASTNode.createBlockNode(this.location_.getSourceBlock())
    }
    return null
};
//Finds the next element that is one position above and all the way to the left of the current location
LearnBlock.ASTNode.prototype.out = function () {
    switch (this.type_) {
        case LearnBlock.ASTNode.types.STACK:
            var a = this.location_.getRelativeToSurfaceXY();
            a = new LearnBlock.utils.Coordinate(a.x, a.y + LearnBlock.ASTNode.DEFAULT_OFFSET_Y);
            return LearnBlock.ASTNode.createWorkspaceNode(this.location_.workspace, a);
        case LearnBlock.ASTNode.types.OUTPUT:
            return (a = this.location_.targetConnection) ? LearnBlock.ASTNode.createConnectionNode(a) : LearnBlock.ASTNode.createStackNode(this.location_.getSourceBlock());
        case LearnBlock.ASTNode.types.FIELD:
            return LearnBlock.ASTNode.createBlockNode(this.location_.getSourceBlock());
        case LearnBlock.ASTNode.types.INPUT:
            return LearnBlock.ASTNode.createBlockNode(this.location_.getSourceBlock());
        case LearnBlock.ASTNode.types.BLOCK:
            return this.getOutAstNodeForBlock_(this.location_);
        case LearnBlock.ASTNode.types.PREVIOUS:
            return this.getOutAstNodeForBlock_(this.location_.getSourceBlock());
        case LearnBlock.ASTNode.types.NEXT:
            return this.getOutAstNodeForBlock_(this.location_.getSourceBlock())
    }
    return null
};

//Key codes for common characters
LearnBlock.utils.KeyCodes = {};

//Holds the serialized key to key action mapping
LearnBlock.user = {};
LearnBlock.user.keyMap = {};
LearnBlock.user.keyMap.map_ = {};
//Object holding valid modifiers
LearnBlock.user.keyMap.modifierKeys = {
    SHIFT: "Shift",
    CONTROL: "Control",
    ALT: "Alt",
    META: "Meta"
};
//Updates the key map to contain the new action
LearnBlock.user.keyMap.setActionForKey = function (a, b) {
    var c = LearnBlock.user.keyMap.getKeyByAction(b);
    c && delete LearnBlock.user.keyMap.map_[c];
    LearnBlock.user.keyMap.map_[a] = b
};
//Creates a new key map
LearnBlock.user.keyMap.setKeyMap = function (a) {
    LearnBlock.user.keyMap.map_ = a
};
//Gets the current key map
LearnBlock.user.keyMap.getKeyMap = function () {
    var a = {};
    LearnBlock.utils.object.mixin(a, LearnBlock.user.keyMap.map_);
    return a
};
//Gets the action by the serialized key code
LearnBlock.user.keyMap.getActionByKeyCode = function (a) {
    return LearnBlock.user.keyMap.map_[a]
};
//Gets the serialized key that corresponds to the action
LearnBlock.user.keyMap.getKeyByAction = function (a) {
    for (var b = Object.keys(LearnBlock.user.keyMap.map_), c = 0, d; d = b[c]; c++)
        if (LearnBlock.user.keyMap.map_[d].name === a.name) return d;
    return null
};
//Serializes the key event
LearnBlock.user.keyMap.serializeKeyEvent = function (a) {
    for (var b = LearnBlock.utils.object.values(LearnBlock.user.keyMap.modifierKeys), c = "", d = 0, e; e = b[d]; d++) a.getModifierState(e) && (c += e);
    return c += a.keyCode
};
//Creates the serialized key code that will be used in the key map
LearnBlock.user.keyMap.createSerializedKey = function (a, b) {
    for (var c = "", d = LearnBlock.utils.object.values(LearnBlock.user.keyMap.modifierKeys), e = 0, f; f = b[e]; e++)
        if (-1 < d.indexOf(f)) c += f;
        else throw Error(f + " is not a valid modifier key.");
    return c + a
};
//Creates the default key map
LearnBlock.user.keyMap.createDefaultKeyMap = function () {
    var a = {},
        b = LearnBlock.user.keyMap.createSerializedKey(LearnBlock.utils.KeyCodes.K, [LearnBlock.user.keyMap.modifierKeys.CONTROL]);
    a[LearnBlock.utils.KeyCodes.W] = LearnBlock.navigation.ACTION_PREVIOUS;
    a[LearnBlock.utils.KeyCodes.A] = LearnBlock.navigation.ACTION_OUT;
    a[LearnBlock.utils.KeyCodes.S] = LearnBlock.navigation.ACTION_NEXT;
    a[LearnBlock.utils.KeyCodes.D] = LearnBlock.navigation.ACTION_IN;
    a[LearnBlock.utils.KeyCodes.I] = LearnBlock.navigation.ACTION_INSERT;
    a[LearnBlock.utils.KeyCodes.ENTER] =
        LearnBlock.navigation.ACTION_MARK;
    a[LearnBlock.utils.KeyCodes.X] = LearnBlock.navigation.ACTION_DISCONNECT;
    a[LearnBlock.utils.KeyCodes.T] = LearnBlock.navigation.ACTION_TOOLBOX;
    a[LearnBlock.utils.KeyCodes.E] = LearnBlock.navigation.ACTION_EXIT;
    a[LearnBlock.utils.KeyCodes.ESC] = LearnBlock.navigation.ACTION_EXIT;
    a[b] = LearnBlock.navigation.ACTION_TOGGLE_KEYBOARD_NAV;
    return a
};

//Class for navigation
LearnBlock.navigation = {};
LearnBlock.navigation.loggingCallback = null;
LearnBlock.navigation.STATE_FLYOUT = 1;
LearnBlock.navigation.STATE_WS = 2;
LearnBlock.navigation.STATE_TOOLBOX = 3;
LearnBlock.navigation.currentState_ = LearnBlock.navigation.STATE_WS;
//Object holding default action names
LearnBlock.navigation.actionNames = {
    PREVIOUS: "previous",
    NEXT: "next",
    IN: "in",
    OUT: "out",
    INSERT: "insert",
    MARK: "mark",
    DISCONNECT: "disconnect",
    TOOLBOX: "toolbox",
    EXIT: "exit",
    TOGGLE_KEYBOARD_NAV: "toggle_keyboard_nav"
};
//If a toolbox exists, sets the navigation state to toolbox and select the first category in the toolbox
LearnBlock.navigation.focusToolbox_ = function () {
    var a = LearnBlock.getMainWorkspace(),
        b = a.getToolbox();
    b && (LearnBlock.navigation.currentState_ = LearnBlock.navigation.STATE_TOOLBOX, LearnBlock.navigation.resetFlyout_(!1), a.getMarker().getCurNode() || LearnBlock.navigation.markAtCursor_(), b.selectFirstCategory())
};
//Changes focus to the flyout
LearnBlock.navigation.focusFlyout_ = function () {
    LearnBlock.navigation.currentState_ = LearnBlock.navigation.STATE_FLYOUT;
    var a = LearnBlock.getMainWorkspace();
    var b = a.getToolbox();
    b = b ? b.flyout_ : a.getFlyout();
    a.getMarker().getCurNode() || LearnBlock.navigation.markAtCursor_();
    b && b.getWorkspace() && (a = b.getWorkspace().getTopBlocks(!0), 0 < a.length && (a = a[0], a = LearnBlock.ASTNode.createStackNode(a), LearnBlock.navigation.getFlyoutCursor_().setCurNode(a)))
};
//Finds where the cursor should go on the workspace
LearnBlock.navigation.focusWorkspace_ = function () {
    LearnBlock.hideChaff();
    var a = LearnBlock.getMainWorkspace(),
        b = a.getCursor(),
        c = !!a.getToolbox(),
        d = a.getTopBlocks(!0);
    LearnBlock.navigation.resetFlyout_(c);
    LearnBlock.navigation.currentState_ = LearnBlock.navigation.STATE_WS;
    0 < d.length ? b.setCurNode(LearnBlock.navigation.getTopNode(d[0])) : (c = new LearnBlock.utils.Coordinate(100, 100), a = LearnBlock.ASTNode.createWorkspaceNode(a, c), b.setCurNode(a))
};
//Gets the cursor from the flyouts workspace
LearnBlock.navigation.getFlyoutCursor_ = function () {
    var a = LearnBlock.getMainWorkspace(),
        b = null;
    a.rendered && (b = (a = (b = a.getToolbox()) ? b.flyout_ : a.getFlyout()) ? a.workspace_.getCursor() : null);
    return b
};
//If there is a marked connection, tries connecting the block from the flyout to that connection
LearnBlock.navigation.insertFromFlyout = function () {
    var a = LearnBlock.getMainWorkspace(),
        b = a.getFlyout();
    if (b && b.isVisible()) {
        var c = LearnBlock.navigation.getFlyoutCursor_().getCurNode().getLocation();
        b = b.createBlock(c), b.render(), b.setConnectionsHidden(!1), a.getCursor().setCurNode(LearnBlock.ASTNode.createBlockNode(b)), LearnBlock.navigation.modify_() || LearnBlock.navigation.warn_("Something went wrong while inserting a block from the flyout."), LearnBlock.navigation.focusWorkspace_(), a.getCursor().setCurNode(LearnBlock.navigation.getTopNode(b)),
            LearnBlock.navigation.removeMark_()
    } else LearnBlock.navigation.warn_("Trying to insert from the flyout when the flyout does not  exist or is not visible")
};
//Resets flyout information, and optionally closes the flyout
LearnBlock.navigation.resetFlyout_ = function (a) {
    LearnBlock.navigation.getFlyoutCursor_() && (LearnBlock.navigation.getFlyoutCursor_().hide(), a && LearnBlock.getMainWorkspace().getFlyout().hide())
};
//Warns the user if the cursor or marker is on a type that can not be connected
LearnBlock.navigation.modifyWarn_ = function () {
    var a = LearnBlock.getMainWorkspace().getMarker().getCurNode(),
        b = LearnBlock.getMainWorkspace().getCursor().getCurNode();
    if (!a) return LearnBlock.navigation.warn_("Cannot insert with no marked node."), !1;
    if (!b) return LearnBlock.navigation.warn_("Cannot insert with no cursor node."), !1;
    a = a.getType();
    b = b.getType();
    return a == LearnBlock.ASTNode.types.FIELD ? (LearnBlock.navigation.warn_("Should not have been able to mark a field."), !1) : a == LearnBlock.ASTNode.types.BLOCK ? (LearnBlock.navigation.warn_("Should not have been able to mark a block."),
        !1) : a == LearnBlock.ASTNode.types.STACK ? (LearnBlock.navigation.warn_("Should not have been able to mark a stack."), !1) : b == LearnBlock.ASTNode.types.FIELD ? (LearnBlock.navigation.warn_("Cannot attach a field to anything else."), !1) : b == LearnBlock.ASTNode.types.WORKSPACE ? (LearnBlock.navigation.warn_("Cannot attach a workspace to anything else."), !1) : !0
};
//Disconnects the block from its parent and moves to the position of the workspace node
LearnBlock.navigation.moveBlockToWorkspace_ = function (a, b) {
    if (a.isShadow()) return LearnBlock.navigation.warn_("Cannot move a shadow block to the workspace."), !1;
    a.getParent() && a.unplug(!1);
    a.moveTo(b.getWsCoordinate());
    return !0
};
//Handles the modifier key
LearnBlock.navigation.modify_ = function () {
    var a = LearnBlock.getMainWorkspace().getMarker().getCurNode(),
        b = LearnBlock.getMainWorkspace().getCursor().getCurNode();
    if (!LearnBlock.navigation.modifyWarn_()) return !1;
    var c = a.getType(),
        d = b.getType(),
        e = b.getLocation(),
        f = a.getLocation();
    if (a.isConnection() && b.isConnection()) return LearnBlock.navigation.connect_(e, f);
    if (a.isConnection() && (d == LearnBlock.ASTNode.types.BLOCK || d == LearnBlock.ASTNode.types.STACK)) return LearnBlock.navigation.insertBlock(e, f);
    if (c == LearnBlock.ASTNode.types.WORKSPACE) return b =
        LearnBlock.navigation.getSourceBlock_(b), LearnBlock.navigation.moveBlockToWorkspace_(b, a);
    LearnBlock.navigation.warn_("Unexpected state in LearnBlock.navigation.modify_.");
    return !1
};
//If one of the connections source blocks is a child of the other, disconnects the child
LearnBlock.navigation.disconnectChild_ = function (a, b) {
    var c = a.getSourceBlock(),
        d = b.getSourceBlock();
    c.getRootBlock() == d.getRootBlock() && (-1 < c.getDescendants(!1).indexOf(d) ? LearnBlock.navigation.getInferiorConnection_(b).disconnect() : LearnBlock.navigation.getInferiorConnection_(a).disconnect())
};
//If the two blocks are compatible, moves the moving connection to the target connection and connect them
LearnBlock.navigation.moveAndConnect_ = function (a, b) {
    if (!a || !b) return !1;
    var c = a.getSourceBlock();
    return b.canConnectWithReason_(a) == LearnBlock.Connection.CAN_CONNECT ? (LearnBlock.navigation.disconnectChild_(a, b), b.isSuperior() || c.getRootBlock().positionNearConnection(a, b), b.connect(a), !0) : !1
};
//If the given connection is superior, finds the inferior connection on the source block
LearnBlock.navigation.getInferiorConnection_ = function (a) {
    var b = a.getSourceBlock();
    return a.isSuperior() ? b.previousConnection ? b.previousConnection : b.outputConnection ? b.outputConnection : null : a
};
//If the given connection is inferior, tries to find a superior connection to connect to
LearnBlock.navigation.getSuperiorConnection_ = function (a) {
    return a.isSuperior() ? a : a.targetConnection ? a.targetConnection : null
};
//Tries to connect the  given connections
LearnBlock.navigation.connect_ = function (a, b) {
    if (!a || !b) return !1;
    var c = LearnBlock.navigation.getInferiorConnection_(a),
        d = LearnBlock.navigation.getSuperiorConnection_(b),
        e = LearnBlock.navigation.getSuperiorConnection_(a),
        f = LearnBlock.navigation.getInferiorConnection_(b);
    if (c && d && LearnBlock.navigation.moveAndConnect_(c, d) || e && f && LearnBlock.navigation.moveAndConnect_(e, f) || LearnBlock.navigation.moveAndConnect_(a, b)) return !0;
    try {
        b.checkConnection_(a)
    } catch (g) {
        LearnBlock.navigation.warn_("Connection failed with error: " + g)
    }
    return !1
};
//Tries to connect the given block to the destination connection
LearnBlock.navigation.insertBlock = function (a, b) {
    switch (b.type) {
        case LearnBlock.PREVIOUS_STATEMENT:
            if (LearnBlock.navigation.connect_(a.nextConnection, b)) return !0;
            break;
        case LearnBlock.NEXT_STATEMENT:
            if (LearnBlock.navigation.connect_(a.previousConnection, b)) return !0;
            break;
        case LearnBlock.INPUT_VALUE:
            if (LearnBlock.navigation.connect_(a.outputConnection, b)) return !0;
            break;
        case LearnBlock.OUTPUT_VALUE:
            for (var c = 0; c < a.inputList.length; c++) {
                var d = a.inputList[c].connection;
                if (d && d.type === LearnBlock.INPUT_VALUE && LearnBlock.navigation.connect_(d,
                        b)) return !0
            }
            if (a.outputConnection && LearnBlock.navigation.connect_(a.outputConnection, b)) return !0
    }
    LearnBlock.navigation.warn_("This block can not be inserted at the marked location.");
    return !1
};
//Disconnects the connection that the cursor is pointing to, and bumps blocks
LearnBlock.navigation.disconnectBlocks_ = function () {
    var a = LearnBlock.getMainWorkspace(),
        b = a.getCursor().getCurNode();
    if (b.isConnection()) {
        var c = b.getLocation();
        c.isConnected() ? (b = c.isSuperior() ? c : c.targetConnection, c = c.isSuperior() ? c.targetConnection : c, c.getSourceBlock().isShadow() ? LearnBlock.navigation.log_("Cannot disconnect a shadow block") : (b.disconnect(), c.bumpAwayFrom_(b), b.getSourceBlock().getRootBlock().bringToFront(), b = LearnBlock.ASTNode.createConnectionNode(b), a.getCursor().setCurNode(b))) : LearnBlock.navigation.log_("Cannot disconnect unconnected connection")
    } else LearnBlock.navigation.log_("Cannot disconnect blocks when the cursor is not on a connection")
};
//Moves the marker to the cursor's current location
LearnBlock.navigation.markAtCursor_ = function () {
    var a = LearnBlock.getMainWorkspace();
    a.getMarker().setCurNode(a.getCursor().getCurNode())
};
//Removes the marker from its current location and hide it
LearnBlock.navigation.removeMark_ = function () {
    var a = LearnBlock.getMainWorkspace();
    a.getMarker().setCurNode(null);
    a.getMarker().hide()
};
//Sets the current navigation state
LearnBlock.navigation.setState = function (a) {
    LearnBlock.navigation.currentState_ = a
};
//Finds the source block of the location on a given node
LearnBlock.navigation.getSourceBlock_ = function (a) {
    return a ? a.getType() === LearnBlock.ASTNode.types.BLOCK ? a.getLocation() : a.getType() === LearnBlock.ASTNode.types.STACK ? a.getLocation() : a.getType() === LearnBlock.ASTNode.types.WORKSPACE ? null : a.getLocation().getSourceBlock() : null
};
//Gets the top node on a block
LearnBlock.navigation.getTopNode = function (a) {
    var b = a.previousConnection || a.outputConnection;
    return b ? LearnBlock.ASTNode.createConnectionNode(b) : LearnBlock.ASTNode.createBlockNode(a)
};
//Before a block is deleted, moves the cursor to the appropriate position
LearnBlock.navigation.moveCursorOnBlockDelete = function (a) {
    var b = LearnBlock.getMainWorkspace();
    if (b && (b = b.getCursor())) {
        var c = b.getCurNode();
        c = LearnBlock.navigation.getSourceBlock_(c);
        c === a ? c.getParent() ? (a = c.previousConnection || c.outputConnection) && b.setCurNode(LearnBlock.ASTNode.createConnectionNode(a.targetConnection)) : b.setCurNode(LearnBlock.ASTNode.createWorkspaceNode(c.workspace, c.getRelativeToSurfaceXY())) : -1 < a.getChildren(!1).indexOf(c) && b.setCurNode(LearnBlock.ASTNode.createWorkspaceNode(c.workspace, c.getRelativeToSurfaceXY()))
    }
};
//When a block that the cursor is on is mutated, moves the cursor to the block level
LearnBlock.navigation.moveCursorOnBlockMutation = function (a) {
    var b = LearnBlock.getMainWorkspace().getCursor();
    if (b) {
        var c = b.getCurNode();
        c = LearnBlock.navigation.getSourceBlock_(c);
        c === a && b.setCurNode(LearnBlock.ASTNode.createBlockNode(c))
    }
};
//Enables accessibility mode
LearnBlock.navigation.enableKeyboardAccessibility = function () {
    LearnBlock.keyboardAccessibilityMode || (LearnBlock.keyboardAccessibilityMode = !0, LearnBlock.navigation.focusWorkspace_())
};
//Disables accessibility mode
LearnBlock.navigation.disableKeyboardAccessibility = function () {
    if (LearnBlock.keyboardAccessibilityMode) {
        var a = LearnBlock.getMainWorkspace();
        LearnBlock.keyboardAccessibilityMode = !1;
        a.getCursor().hide();
        a.getMarker().hide();
        LearnBlock.navigation.getFlyoutCursor_() && LearnBlock.navigation.getFlyoutCursor_().hide()
    }
};
//Navigation log handler
LearnBlock.navigation.log_ = function (a) {
    LearnBlock.navigation.loggingCallback ? LearnBlock.navigation.loggingCallback("log", a) : console.log(a)
};
//Navigation warning handler
LearnBlock.navigation.warn_ = function (a) {
    LearnBlock.navigation.loggingCallback ? LearnBlock.navigation.loggingCallback("warn", a) : console.warn(a)
};
//Navigation error handler
LearnBlock.navigation.error_ = function (a) {
    LearnBlock.navigation.loggingCallback ? LearnBlock.navigation.loggingCallback("error", a) : console.error(a)
};
//Handler for all the keyboard navigation events
LearnBlock.navigation.onKeyPress = function (a) {
    a = LearnBlock.user.keyMap.serializeKeyEvent(a);
    return (a = LearnBlock.user.keyMap.getActionByKeyCode(a)) ? LearnBlock.navigation.onBlocklyAction(a) : !1
};
//Executes any actions on the flyout, workspace, or toolbox that correspond to the given action
LearnBlock.navigation.onBlocklyAction = function (a) {
    var b = LearnBlock.getMainWorkspace().options.readOnly,
        c = !1;
    LearnBlock.keyboardAccessibilityMode ? b ? -1 < LearnBlock.navigation.READONLY_ACTION_LIST.indexOf(a) && (c = LearnBlock.navigation.handleActions_(a)) : c = LearnBlock.navigation.handleActions_(a) : a.name === LearnBlock.navigation.actionNames.TOGGLE_KEYBOARD_NAV && (LearnBlock.navigation.enableKeyboardAccessibility(), c = !0);
    return c
};
//Handles the action or dispatches to the appropriate action handler
LearnBlock.navigation.handleActions_ = function (a) {
    var b = LearnBlock.getMainWorkspace();
    if (a.name === LearnBlock.navigation.actionNames.TOGGLE_KEYBOARD_NAV) return LearnBlock.navigation.disableKeyboardAccessibility(), !0;
    if (a.name === LearnBlock.navigation.actionNames.TOOLBOX) return b.getToolbox() ? LearnBlock.navigation.focusToolbox_() : LearnBlock.navigation.focusFlyout_(), !0;
    if (LearnBlock.navigation.currentState_ === LearnBlock.navigation.STATE_WS) {
        b = b.getCursor().getCurNode();
        var c = !1;
        b && b.getType() === LearnBlock.ASTNode.types.FIELD && (c =
            b.getLocation().onBlocklyAction(a));
        c || (c = LearnBlock.navigation.workspaceOnAction_(a));
        return c
    }
    return LearnBlock.navigation.currentState_ === LearnBlock.navigation.STATE_FLYOUT ? LearnBlock.navigation.flyoutOnAction_(a) : LearnBlock.navigation.currentState_ === LearnBlock.navigation.STATE_TOOLBOX ? LearnBlock.navigation.toolboxOnAction_(a) : !1
};
//Handles all actions performed on the workspace
LearnBlock.navigation.workspaceOnAction_ = function (a) {
    var b = LearnBlock.getMainWorkspace();
    switch (a.name) {
        case LearnBlock.navigation.actionNames.PREVIOUS:
            return b.getCursor().prev(), !0;
        case LearnBlock.navigation.actionNames.OUT:
            return b.getCursor().out(), !0;
        case LearnBlock.navigation.actionNames.NEXT:
            return b.getCursor().next(), !0;
        case LearnBlock.navigation.actionNames.IN:
            return b.getCursor()["in"](), !0;
        case LearnBlock.navigation.actionNames.INSERT:
            return LearnBlock.navigation.modify_(), !0;
        case LearnBlock.navigation.actionNames.MARK:
            return LearnBlock.navigation.handleEnterForWS_(),
                !0;
        case LearnBlock.navigation.actionNames.DISCONNECT:
            return LearnBlock.navigation.disconnectBlocks_(), !0;
        default:
            return !1
    }
};
//Handles all actions performed on the flyout
LearnBlock.navigation.flyoutOnAction_ = function (a) {
    switch (a.name) {
        case LearnBlock.navigation.actionNames.PREVIOUS:
            return LearnBlock.navigation.getFlyoutCursor_().prev(), !0;
        case LearnBlock.navigation.actionNames.OUT:
            return LearnBlock.navigation.focusToolbox_(), !0;
        case LearnBlock.navigation.actionNames.NEXT:
            return LearnBlock.navigation.getFlyoutCursor_().next(), !0;
        case LearnBlock.navigation.actionNames.MARK:
            return LearnBlock.navigation.insertFromFlyout(), !0;
        case LearnBlock.navigation.actionNames.EXIT:
            return LearnBlock.navigation.focusWorkspace_(),
                !0;
        default:
            return !1
    }
};
//Handles all actions performed on the toolbox
LearnBlock.navigation.toolboxOnAction_ = function (a) {
    if (a.name === LearnBlock.navigation.actionNames.EXIT) return LearnBlock.navigation.focusWorkspace_(), !0;
    var b = LearnBlock.getMainWorkspace().getToolbox().onBlocklyAction(a);
    return b || a.name !== LearnBlock.navigation.actionNames.IN ? b : (LearnBlock.navigation.focusFlyout_(), !0)
};
//Handles hitting the enter key on the workspace
LearnBlock.navigation.handleEnterForWS_ = function () {
    var a = LearnBlock.getMainWorkspace().getCursor().getCurNode(),
        b = a.getType();
    b == LearnBlock.ASTNode.types.FIELD ? a.getLocation().showEditor_() : a.isConnection() || b == LearnBlock.ASTNode.types.WORKSPACE ? LearnBlock.navigation.markAtCursor_() : b == LearnBlock.ASTNode.types.BLOCK ? LearnBlock.navigation.warn_("Cannot mark a block.") : b == LearnBlock.ASTNode.types.STACK && LearnBlock.navigation.warn_("Cannot mark a stack.")
};
//Navigation actions
LearnBlock.navigation.ACTION_PREVIOUS = new LearnBlock.Action(LearnBlock.navigation.actionNames.PREVIOUS, "Go to the previous location.");
LearnBlock.navigation.ACTION_OUT = new LearnBlock.Action(LearnBlock.navigation.actionNames.OUT, "Go to the parent of the current location.");
LearnBlock.navigation.ACTION_NEXT = new LearnBlock.Action(LearnBlock.navigation.actionNames.NEXT, "Go to the next location.");
LearnBlock.navigation.ACTION_IN = new LearnBlock.Action(LearnBlock.navigation.actionNames.IN, "Go to the first child of the current location.");
LearnBlock.navigation.ACTION_INSERT = new LearnBlock.Action(LearnBlock.navigation.actionNames.INSERT, "Connect the current location to the marked location.");
LearnBlock.navigation.ACTION_MARK = new LearnBlock.Action(LearnBlock.navigation.actionNames.MARK, "Mark the current location.");
LearnBlock.navigation.ACTION_DISCONNECT = new LearnBlock.Action(LearnBlock.navigation.actionNames.DISCONNECT, "Dicsonnect the block at thecurrent location from its parent.");
LearnBlock.navigation.ACTION_TOOLBOX = new LearnBlock.Action(LearnBlock.navigation.actionNames.TOOLBOX, "Open the toolbox.");
LearnBlock.navigation.ACTION_EXIT = new LearnBlock.Action(LearnBlock.navigation.actionNames.EXIT, "Close the current modal, such as a toolbox or field editor.");
LearnBlock.navigation.ACTION_TOGGLE_KEYBOARD_NAV = new LearnBlock.Action(LearnBlock.navigation.actionNames.TOGGLE_KEYBOARD_NAV, "Turns on and off keyboard navigation.");
LearnBlock.navigation.READONLY_ACTION_LIST = [LearnBlock.navigation.ACTION_PREVIOUS, LearnBlock.navigation.ACTION_OUT, LearnBlock.navigation.ACTION_IN, LearnBlock.navigation.ACTION_NEXT, LearnBlock.navigation.ACTION_TOGGLE_KEYBOARD_NAV];

//Class for a database of entity names (variables, functions...)
LearnBlock.Names = function (a, b) {
    this.variablePrefix_ = b || "";
    this.reservedDict_ = Object.create(null);
    if (a)
        for (var c = a.split(","), d = 0; d < c.length; d++) this.reservedDict_[c[d]] = !0;
    this.reset()
};
//Constant to separate developer variable names from user-defined variable names
LearnBlock.Names.DEVELOPER_VARIABLE_TYPE = "DEVELOPER_VARIABLE";
//Empties the database and starts from scratch
LearnBlock.Names.prototype.reset = function () {
    this.db_ = Object.create(null);
    this.dbReverse_ = Object.create(null);
    this.variableMap_ = null
};
//Sets the variable map that maps from variable name to variable object
LearnBlock.Names.prototype.setVariableMap = function (a) {
    this.variableMap_ = a
};
//Gets the name for a user-defined variable, based on its ID
LearnBlock.Names.prototype.getNameForUserVariable_ = function (a) {
    return this.variableMap_ ? (a = this.variableMap_.getVariableById(a)) ? a.name : null : (console.log("Deprecated call to LearnBlock.Names.prototype.getName without defining a variable map. To fix, add the folowing code in your generator's init() function:\nLearnBlock.YourGeneratorName.variableDB_.setVariableMap(workspace.getVariableMap());"), null)
};
//Converts a LearnBlock entity name to a legal exportable entity name
LearnBlock.Names.prototype.getName = function (a, b) {
    if (b == LearnBlock.Variables.NAME_TYPE) {
        var c = this.getNameForUserVariable_(a);
        c && (a = c)
    }
    c = a.toLowerCase() + "_" + b;
    var d = b == LearnBlock.Variables.NAME_TYPE || b == LearnBlock.Names.DEVELOPER_VARIABLE_TYPE ? this.variablePrefix_ : "";
    if (c in this.db_) return d + this.db_[c];
    var e = this.getDistinctName(a, b);
    this.db_[c] = e.substr(d.length);
    return e
};
//Converts a LearnBlock entity name to a legal exportable entity name
LearnBlock.Names.prototype.getDistinctName = function (a, b) {
    for (var c = this.safeName_(a), d = ""; this.dbReverse_[c + d] || c + d in this.reservedDict_;) d = d ? d + 1 : 2;
    c += d;
    this.dbReverse_[c] = !0;
    return (b == LearnBlock.Variables.NAME_TYPE || b == LearnBlock.Names.DEVELOPER_VARIABLE_TYPE ? this.variablePrefix_ : "") + c
};
//Given a proposed entity name, generates a name that conforms to the [_A-Za-z][_A-Za-z0-9]* format
LearnBlock.Names.prototype.safeName_ = function (a) {
    a ? (a = encodeURI(a.replace(/ /g, "_")).replace(/[^\w]/g, "_"), -1 != "0123456789".indexOf(a[0]) && (a = "my_" + a)) : a = LearnBlock.Msg.UNNAMED_KEY || "unnamed";
    return a
};
//Do the given two entity names refer to the same entity?
LearnBlock.Names.equals = function (a, b) {
    return a.toLowerCase() == b.toLowerCase()
};

//Procedures
LearnBlock.Procedures = {};
LearnBlock.Procedures.NAME_TYPE = LearnBlock.PROCEDURE_CATEGORY_NAME;
//Finds all the procedures created by the user
LearnBlock.Procedures.allProcedures = function (a) {
    a = a.getAllBlocks(!1);
    for (var b = [], c = [], d = 0; d < a.length; d++)
        if (a[d].getProcedureDef) {
            var e = a[d].getProcedureDef();
            e && (e[2] ? b.push(e) : c.push(e))
        } c.sort(LearnBlock.Procedures.procTupleComparator_);
    b.sort(LearnBlock.Procedures.procTupleComparator_);
    return [c, b]
};
//Comparison function
LearnBlock.Procedures.procTupleComparator_ = function (a, b) {
    return a[0].toLowerCase().localeCompare(b[0].toLowerCase())
};
//Ensures two identically-named procedures don't exist
LearnBlock.Procedures.findLegalName = function (a, b) {
    if (b.isInFlyout) return a;
    for (a = a || LearnBlock.Msg.UNNAMED_KEY || "unnamed"; !LearnBlock.Procedures.isLegalName_(a, b.workspace, b);) {
        var c = a.match(/^(.*?)(\d+)$/);
        a = c ? c[1] + (parseInt(c[2], 10) + 1) : a + "2"
    }
    return a
};
//Ensures the procedure's name is legal
LearnBlock.Procedures.isLegalName_ = function (a, b, c) {
    return !LearnBlock.Procedures.isNameUsed(a, b, c)
};
//Ensures the procedure's name is used
LearnBlock.Procedures.isNameUsed = function (a, b, c) {
    b = b.getAllBlocks(!1);
    for (var d = 0; d < b.length; d++)
        if (b[d] != c && b[d].getProcedureDef) {
            var e = b[d].getProcedureDef();
            if (LearnBlock.Names.equals(e[0], a)) return !0
        } return !1
};
//Renames the procedure
LearnBlock.Procedures.rename = function (a) {
    a = a.trim();
    var b = LearnBlock.Procedures.findLegalName(a, this.getSourceBlock()),
        c = this.getValue();
    if (c != a && c != b) {
        a = this.getSourceBlock().workspace.getAllBlocks(!1);
        for (var d = 0; d < a.length; d++) a[d].renameProcedure && a[d].renameProcedure(c, b)
    }
    return b
};
//Constructs the blocks required by the flyout for the procedure category
LearnBlock.Procedures.flyoutCategory = function (a) {
    function b(a, b) {
        for (var d = 0; d < a.length; d++) {
            var e = a[d][0],
                f = a[d][1],
                g = LearnBlock.utils.xml.createElement("block");
            g.setAttribute("type", b);
            g.setAttribute("gap", 16);
            var n = LearnBlock.utils.xml.createElement("mutation");
            n.setAttribute("name", e);
            g.appendChild(n);
            c.push(g)
        }
    }
    var c = [];
    //Only procedures with no return and no parameters
    if (LearnBlock.Blocks.procedures_defnoreturn) {
        var d = LearnBlock.utils.xml.createElement("block");
        d.setAttribute("type", "procedures_defnoreturn");
        d.setAttribute("gap", 16);
        var e = LearnBlock.utils.xml.createElement("field");
        e.setAttribute("name", "NAME");
        e.appendChild(LearnBlock.utils.xml.createTextNode(LearnBlock.Msg.PROCEDURES_DEFNORETURN_PROCEDURE));
        d.appendChild(e);
        c.push(d)
    }
    a = LearnBlock.Procedures.allProcedures(a);
    b(a[0], "procedures_callnoreturn");
    return c
};
//Finds all the callers of a named procedure
LearnBlock.Procedures.getCallers = function (a, b) {
    for (var c = [], d = b.getAllBlocks(!1), e = 0; e < d.length; e++)
        if (d[e].getProcedureCall) {
            var f = d[e].getProcedureCall();
            f && LearnBlock.Names.equals(f, a) && c.push(d[e])
        } return c
};
//When a procedure definition changes its parameters, finds and edits all its callers
LearnBlock.Procedures.mutateCallers = function (a) {
    var b = LearnBlock.Events.recordUndo,
        c = a.getProcedureDef()[0],
        d = a.mutationToDom(!0);
    a = LearnBlock.Procedures.getCallers(c, a.workspace);
    c = 0;
    for (var e; e = a[c]; c++) {
        var f = e.mutationToDom();
        f = f && LearnBlock.Xml.domToText(f);
        e.domToMutation(d);
        var g = e.mutationToDom();
        g = g && LearnBlock.Xml.domToText(g);
        f != g && (LearnBlock.Events.recordUndo = !1, LearnBlock.Events.fire(new LearnBlock.Events.BlockChange(e, "mutation", null, f, g)), LearnBlock.Events.recordUndo = b)
    }
};
//Finds the definition block for the named procedure
LearnBlock.Procedures.getDefinition = function (a, b) {
    for (var c = b.getTopBlocks(!1), d = 0; d < c.length; d++)
        if (c[d].getProcedureDef) {
            var e = c[d].getProcedureDef();
            if (e && LearnBlock.Names.equals(e[0], a)) return c[d]
        } return null
};

//Variable model
//Info for the variable: name, id, type
LearnBlock.VariableModel = function (a, b, c, d) {
    this.workspace = a;
    this.name = b;
    this.type = c || "";
    this.id_ = d || LearnBlock.utils.genUid();
    LearnBlock.Events.fire(new LearnBlock.Events.VarCreate(this))
};
//Returns the variable id
LearnBlock.VariableModel.prototype.getId = function () {
    return this.id_
};
//Compare function for the variablemodel objects
LearnBlock.VariableModel.compareByName = function (a, b) {
    var c = a.name.toLowerCase(),
        d = b.name.toLowerCase();
    return c < d ? -1 : c == d ? 0 : 1
};

//Variables
LearnBlock.Variables = {};
LearnBlock.Variables.allUsedVarModels = function (a) {
    var b = a.getAllBlocks(!1);
    a = Object.create(null);
    for (var c = 0; c < b.length; c++) {
        var d = b[c].getVarModels();
        if (d)
            for (var e = 0; e < d.length; e++) {
                var f = d[e],
                    g = f.getId();
                g && (a[g] = f)
            }
    }
    b = [];
    for (g in a) b.push(a[g]);
    return b
};
//Returns a new variable name that is not yet being used
LearnBlock.Variables.generateUniqueName = function (a) {
    a = a.getAllVariables();
    var b = "";
    if (a.length)
        for (var c = 1, d = 0, e = "ijkmnopqrstuvwxyzabcdefgh".charAt(d); !b;) {
            for (var f = !1, g = 0; g < a.length; g++)
                if (a[g].name.toLowerCase() == e) {
                    f = !0;
                    break
                } f ? (d++, 25 == d && (d = 0, c++), e = "ijkmnopqrstuvwxyzabcdefgh".charAt(d), 1 < c && (e += c)) : b = e
        } else b = "i";
    return b
};
//Handles "Create Variable" button
LearnBlock.Variables.createVariableButtonHandler = function (a, b, c) {
    var d = c || "",
        e = function (c) {
            LearnBlock.Variables.promptName(LearnBlock.Msg.NEW_VARIABLE_TITLE, c, function (c) {
                if (c) {
                    var f = LearnBlock.Variables.nameUsedWithAnyType_(c, a);
                    if (f) {
                        var g = c.toLowerCase();
                        if (f.type == d) var l = LearnBlock.Msg.VARIABLE_ALREADY_EXISTS.replace("%1", g);
                        else l = LearnBlock.Msg.VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE, l = l.replace("%1", g).replace("%2", f.type);
                        LearnBlock.alert(l, function () {
                            e(c)
                        })
                    } else a.createVariable(c, d), b && b(c)
                } else b && b(null)
            })
        };
    e("")
};
LearnBlock.Variables.createVariable = LearnBlock.Variables.createVariableButtonHandler;
//Renames a variable with the given workspace, variableType, and oldName
LearnBlock.Variables.renameVariable = function (a, b, c) {
    var d = function (e) {
        var f = LearnBlock.Msg.RENAME_VARIABLE_TITLE.replace("%1", b.name);
        LearnBlock.Variables.promptName(f, e, function (e) {
            if (e) {
                var f = LearnBlock.Variables.nameUsedWithOtherType_(e, b.type, a);
                f ? (f = LearnBlock.Msg.VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE.replace("%1", e.toLowerCase()).replace("%2", f.type), LearnBlock.alert(f, function () {
                    d(e)
                })) : (a.renameVariableById(b.getId(), e), c && c(e))
            } else c && c(null)
        })
    };
    d("")
};
//Prompts the user for a new variable name
LearnBlock.Variables.promptName = function (a, b, c) {
    LearnBlock.prompt(a, b, function (a) {
        a && (a = a.replace(/[\s\xa0]+/g, " ").trim(), a == LearnBlock.Msg.RENAME_VARIABLE || a == LearnBlock.Msg.NEW_VARIABLE) && (a = null);
        c(a)
    })
};
//Checks whether there exists a variable with the given name but a different type
LearnBlock.Variables.nameUsedWithOtherType_ = function (a, b, c) {
    c = c.getVariableMap().getAllVariables();
    a = a.toLowerCase();
    for (var d = 0, e; e = c[d]; d++)
        if (e.name.toLowerCase() == a && e.type != b) return e;
    return null
};
//Checks whether there exists a variable with the given name of any type
LearnBlock.Variables.nameUsedWithAnyType_ = function (a, b) {
    var c = b.getVariableMap().getAllVariables();
    a = a.toLowerCase();
    for (var d = 0, e; e = c[d]; d++)
        if (e.name.toLowerCase() == a) return e;
    return null
};
//Generates DOM objects representing a variable field
LearnBlock.Variables.generateVariableFieldDom = function (a) {
    var b = LearnBlock.utils.xml.createElement("field");
    b.setAttribute("name", "VAR");
    b.setAttribute("id", a.getId());
    b.setAttribute("variabletype", a.type);
    a = LearnBlock.utils.xml.createTextNode(a.name);
    b.appendChild(a);
    return b
};
//Helper function to look up or create a variable on the given workspace
LearnBlock.Variables.getOrCreateVariablePackage = function (a, b, c, d) {
    var e = LearnBlock.Variables.getVariable(a, b, c, d);
    e || (e = LearnBlock.Variables.createVariable_(a, b, c, d));
    return e
};
//Looks up a variable on the given workspace
LearnBlock.Variables.getVariable = function (a, b, c, d) {
    var e = a.getPotentialVariableMap();
    if (b) {
        var f = a.getVariableById(b);
        !f && e && (f = e.getVariableById(b));
        if (f) return f
    }
    if (c) {
        if (void 0 == d) throw Error("Tried to look up a variable by name without a type");
        f = a.getVariable(c, d);
        !f && e && (f = e.getVariable(c, d))
    }
    return f
};
//Helper function to create a variable on the given workspace
LearnBlock.Variables.createVariable_ = function (a, b, c, d) {
    var e = a.getPotentialVariableMap();
    c || (c = LearnBlock.Variables.generateUniqueName(a.isFlyout ? a.targetWorkspace : a));
    return e ? e.createVariable(c, d, b) : a.createVariable(c, d, b)
};
//Helper function to get the list of variables that have been added to the workspace after adding a new block
LearnBlock.Variables.getAddedVariables = function (a, b) {
    var c = a.getAllVariables(),
        d = [];
    if (b.length != c.length)
        for (var e = 0; e < c.length; e++) {
            var f = c[e]; - 1 == b.indexOf(f) && d.push(f)
        }
    return d
};

//The HTML container
LearnBlock.WidgetDiv = {};
LearnBlock.WidgetDiv.DIV = null;
LearnBlock.WidgetDiv.owner_ = null;
LearnBlock.WidgetDiv.dispose_ = null;
//Creates the widget div and injects it onto the page
LearnBlock.WidgetDiv.createDom = function () {
    LearnBlock.WidgetDiv.DIV || (LearnBlock.WidgetDiv.DIV = document.createElement("div"), LearnBlock.WidgetDiv.DIV.className = "blocklyWidgetDiv", document.body.appendChild(LearnBlock.WidgetDiv.DIV))
};
//Initializes and displays the widget div
LearnBlock.WidgetDiv.show = function (a, b, c) {
    LearnBlock.WidgetDiv.hide();
    LearnBlock.WidgetDiv.owner_ = a;
    LearnBlock.WidgetDiv.dispose_ = c;
    a = LearnBlock.utils.style.getViewportPageOffset();
    LearnBlock.WidgetDiv.DIV.style.top = a.y + "px";
    LearnBlock.WidgetDiv.DIV.style.direction = b ? "rtl" : "ltr";
    LearnBlock.WidgetDiv.DIV.style.display = "block"
};
//Destroys the widget and hides the div
LearnBlock.WidgetDiv.hide = function () {
    LearnBlock.WidgetDiv.owner_ && (LearnBlock.WidgetDiv.owner_ = null, LearnBlock.WidgetDiv.DIV.style.display = "none", LearnBlock.WidgetDiv.DIV.style.left = "", LearnBlock.WidgetDiv.DIV.style.top = "", LearnBlock.WidgetDiv.dispose_ && LearnBlock.WidgetDiv.dispose_(), LearnBlock.WidgetDiv.dispose_ = null, LearnBlock.WidgetDiv.DIV.innerHTML = "")
};
//Is the container visible?
LearnBlock.WidgetDiv.isVisible = function () {
    return !!LearnBlock.WidgetDiv.owner_
};
//Destroys the widget and hides the div if it is being used by the specified object
LearnBlock.WidgetDiv.hideIfOwner = function (a) {
    LearnBlock.WidgetDiv.owner_ == a && LearnBlock.WidgetDiv.hide()
};
//Sets the widget div's position and height
LearnBlock.WidgetDiv.positionInternal_ = function (a, b, c) {
    LearnBlock.WidgetDiv.DIV.style.left = a + "px";
    LearnBlock.WidgetDiv.DIV.style.top = b + "px";
    LearnBlock.WidgetDiv.DIV.style.height = c + "px"
};
//Positions the widget div based on an anchor rectangle
LearnBlock.WidgetDiv.positionWithAnchor = function (a, b, c, d) {
    var e = LearnBlock.WidgetDiv.calculateY_(a, b, c);
    a = LearnBlock.WidgetDiv.calculateX_(a, b, c, d);
    0 > e ? LearnBlock.WidgetDiv.positionInternal_(a, 0, c.height + e) : LearnBlock.WidgetDiv.positionInternal_(a, e, c.height)
};
//Calculates an x position such that the widget will not be offscreen on the right or left
LearnBlock.WidgetDiv.calculateX_ = function (a, b, c, d) {
    if (d) return b = Math.max(b.right - c.width, a.left), Math.min(b, a.right - c.width);
    b = Math.min(b.left, a.right - c.width);
    return Math.max(b, a.left)
};
//Calculates an y position such that the widget will not be offscreen on the top or bottom
LearnBlock.WidgetDiv.calculateY_ = function (a, b, c) {
    return b.bottom + c.height >= a.bottom ? b.top - c.height : b.bottom
};

//Class for LearnBlock
LearnBlock.VERSION = "3.20191014.4";
LearnBlock.mainWorkspace = null;
LearnBlock.selected = null;
LearnBlock.cursor = null;
LearnBlock.keyboardAccessibilityMode = !1;
LearnBlock.draggingConnections_ = [];
LearnBlock.clipboardXml_ = null;
LearnBlock.clipboardSource_ = null;
LearnBlock.clipboardTypeCounts_ = null;
LearnBlock.cache3dSupported_ = null;
//Returns the dimensions of the specified SVG image
LearnBlock.svgSize = function (a) {
    return {
        width: a.cachedWidth_,
        height: a.cachedHeight_
    }
};
//Sizes the workspace when the contents change
LearnBlock.resizeSvgContents = function (a) {
    a.resizeContents()
};
//Sizes the SVG image to completely fill its container
LearnBlock.svgResize = function (a) {
    for (; a.options.parentWorkspace;) a = a.options.parentWorkspace;
    var b = a.getParentSvg(),
        c = b.parentNode;
    if (c) {
        var d = c.offsetWidth;
        c = c.offsetHeight;
        b.cachedWidth_ != d && (b.setAttribute("width", d + "px"), b.cachedWidth_ = d);
        b.cachedHeight_ != c && (b.setAttribute("height", c + "px"), b.cachedHeight_ = c);
        a.resize()
    }
};
//Handles a key-down on SVG drawing surface
LearnBlock.onKeyDown_ = function (a) {
    var b = LearnBlock.mainWorkspace;
    if (!(LearnBlock.utils.isTargetInput(a) || b.rendered && !b.isVisible()))
        if (b.options.readOnly) LearnBlock.navigation.onKeyPress(a);
        else {
            var c = !1;
            if (a.keyCode == LearnBlock.utils.KeyCodes.ESC) LearnBlock.hideChaff(), LearnBlock.navigation.onBlocklyAction(LearnBlock.navigation.ACTION_EXIT);
            else {
                if (LearnBlock.navigation.onKeyPress(a)) return;
                if (a.keyCode == LearnBlock.utils.KeyCodes.BACKSPACE || a.keyCode == LearnBlock.utils.KeyCodes.DELETE) {
                    a.preventDefault();
                    if (LearnBlock.Gesture.inProgress()) return;
                    LearnBlock.selected && LearnBlock.selected.isDeletable() && (c = !0)
                } else if (a.altKey || a.ctrlKey || a.metaKey) {
                    if (LearnBlock.Gesture.inProgress()) return;
                    LearnBlock.selected && LearnBlock.selected.isDeletable() && LearnBlock.selected.isMovable() && (a.keyCode == LearnBlock.utils.KeyCodes.C ? (LearnBlock.hideChaff(), LearnBlock.copy_(LearnBlock.selected)) : a.keyCode != LearnBlock.utils.KeyCodes.X || LearnBlock.selected.workspace.isFlyout || (LearnBlock.copy_(LearnBlock.selected), c = !0));
                    a.keyCode == LearnBlock.utils.KeyCodes.V ? LearnBlock.clipboardXml_ && (a = LearnBlock.clipboardSource_,
                        a.isFlyout && (a = a.targetWorkspace), LearnBlock.clipboardTypeCounts_ && a.isCapacityAvailable(LearnBlock.clipboardTypeCounts_) && (LearnBlock.Events.setGroup(!0), a.paste(LearnBlock.clipboardXml_), LearnBlock.Events.setGroup(!1))) : a.keyCode == LearnBlock.utils.KeyCodes.Z && (LearnBlock.hideChaff(), b.undo(a.shiftKey))
                }
            }
            c && !LearnBlock.selected.workspace.isFlyout && (LearnBlock.Events.setGroup(!0), LearnBlock.hideChaff(), LearnBlock.selected.dispose(!0, !0), LearnBlock.Events.setGroup(!1))
        }
};
//Copies a block onto the local clipboard
LearnBlock.copy_ = function (a) {
    if (a.isComment) var b = a.toXmlWithXY();
    else {
        b = LearnBlock.Xml.blockToDom(a, !0);
        LearnBlock.Xml.deleteNext(b);
        var c = a.getRelativeToSurfaceXY();
        b.setAttribute("x", a.RTL ? -c.x : c.x);
        b.setAttribute("y", c.y)
    }
    LearnBlock.clipboardXml_ = b;
    LearnBlock.clipboardSource_ = a.workspace;
    LearnBlock.clipboardTypeCounts_ = a.isComment ? null : LearnBlock.utils.getBlockTypeCounts(a, !0)
};
//Duplicates the block and its children
LearnBlock.duplicate_ = function (a) {
    var b = LearnBlock.clipboardXml_,
        c = LearnBlock.clipboardSource_;
    LearnBlock.copy_(a);
    a.workspace.paste(LearnBlock.clipboardXml_);
    LearnBlock.clipboardXml_ = b;
    LearnBlock.clipboardSource_ = c
};
//Cancels the native context menu
LearnBlock.onContextMenu_ = function (a) {
    LearnBlock.utils.isTargetInput(a) || a.preventDefault()
};
//Closes context menus, dropdown selections, etc
LearnBlock.hideChaff = function (a) {
    LearnBlock.WidgetDiv.hide();
    LearnBlock.DropDownDiv.hideWithoutAnimation()
    a || (a = LearnBlock.getMainWorkspace(), a.toolbox_.clearSelection())
};
//Returns the main workspace
LearnBlock.getMainWorkspace = function () {
    return LearnBlock.mainWorkspace
};
//Wrapper to window.alert()
LearnBlock.alert = function (a, b) {
    alert(a);
    b && b()
};
//Wrapper to window.confirm()
LearnBlock.confirm = function (a, b) {
    b(confirm(a))
};
//Wrapper to window.prompt()
LearnBlock.prompt = function (a, b, c) {
    c(prompt(a, b))
};
//Helper function for defining a block from JSON
LearnBlock.jsonInitFactory_ = function (a) {
    return function () {
        this.jsonInit(a)
    }
};
//Defines blocks from an array of JSON block definitions
LearnBlock.defineBlocksWithJsonArray = function (a) {
    for (var b = 0; b < a.length; b++) {
        var c = a[b];
        if (c) {
            var d = c.type;
            null == d || "" === d ? console.warn("Block definition #" + b + " in JSON array is missing a type attribute. Skipping.") : (LearnBlock.Blocks[d] && console.warn("Block definition #" + b + ' in JSON array overwrites prior definition of "' + d + '".'), LearnBlock.Blocks[d] = {
                init: LearnBlock.jsonInitFactory_(c)
            })
        } else console.warn("Block definition #" + b + " in JSON array is " + c + ". Skipping.")
    }
};
//Binds an event to a function call. When calling the function, verifies that it belongs to the touch stream that is currently being processed
LearnBlock.bindEventWithChecks_ = function (a, b, c, d, e, f) {
    var g = !1,
        h = function (a) {
            var b = !e;
            a = LearnBlock.Touch.splitEventByTouches(a);
            for (var f = 0, h; h = a[f]; f++)
                if (!b || LearnBlock.Touch.shouldHandleEvent(h)) LearnBlock.Touch.setClientFromTouch(h), c ? d.call(c, h) : d(h), g = !0
        },
        k = [];
    if (LearnBlock.utils.global.PointerEvent && b in LearnBlock.Touch.TOUCH_MAP)
        for (var l = 0, m; m = LearnBlock.Touch.TOUCH_MAP[b][l]; l++) a.addEventListener(m, h, !1), k.push([a, m, h]);
    else if (a.addEventListener(b, h, !1), k.push([a, b, h]), b in LearnBlock.Touch.TOUCH_MAP) {
        var n =
            function (a) {
                h(a);
                var b = !f;
                g && b && a.preventDefault()
            };
        for (l = 0; m = LearnBlock.Touch.TOUCH_MAP[b][l]; l++) a.addEventListener(m, n, !1), k.push([a, m, n])
    }
    return k
};
//Binds an event to a function call
LearnBlock.bindEvent_ = function (a, b, c, d) {
    var e = function (a) {
            c ? d.call(c, a) : d(a)
        },
        f = [];
    if (LearnBlock.utils.global.PointerEvent && b in LearnBlock.Touch.TOUCH_MAP)
        for (var g = 0, h; h = LearnBlock.Touch.TOUCH_MAP[b][g]; g++) a.addEventListener(h, e, !1), f.push([a, h, e]);
    else if (a.addEventListener(b, e, !1), f.push([a, b, e]), b in LearnBlock.Touch.TOUCH_MAP) {
        var k = function (a) {
            if (a.changedTouches && 1 == a.changedTouches.length) {
                var b = a.changedTouches[0];
                a.clientX = b.clientX;
                a.clientY = b.clientY
            }
            e(a);
            a.preventDefault()
        };
        for (g = 0; h = LearnBlock.Touch.TOUCH_MAP[b][g]; g++) a.addEventListener(h,
            k, !1), f.push([a, h, k])
    }
    return f
};
//Unbinds one or more events event from a function call
LearnBlock.unbindEvent_ = function (a) {
    for (; a.length;) {
        var b = a.pop(),
            c = b[2];
        b[0].removeEventListener(b[1], c, !1)
    }
    return c
};
//Is the given string a number?
LearnBlock.isNumber = function (a) {
    return /^\s*-?\d+(\.\d+)?\s*$/.test(a)
};
//Converts a hue (HSV model) into an RGB hex triplet
LearnBlock.hueToHex = function (a) {
    return LearnBlock.utils.colour.hsvToHex(a, LearnBlock.HSV_SATURATION, 255 * LearnBlock.HSV_VALUE)
};

//Tree class
LearnBlock.tree = {};
//An abstract base class for a node in the tree
LearnBlock.tree.BaseNode = function (a, b) {
    LearnBlock.Component.call(this);
    this.config_ = b;
    this.content_ = a;
    this.expanded_ = this.selected_ = !1;
    this.toolTip_ = null;
    this.isUserCollapsible_ = !0;
    this.depth_ = -1
};
LearnBlock.utils.object.inherits(LearnBlock.tree.BaseNode, LearnBlock.Component);
//Map of nodes in existence
LearnBlock.tree.BaseNode.allNodes = {};
//Override method
LearnBlock.tree.BaseNode.prototype.disposeInternal = function () {
    LearnBlock.tree.BaseNode.superClass_.disposeInternal.call(this);
    this.tree && (this.tree = null);
    this.setElementInternal(null)
};
//Adds roles and states
LearnBlock.tree.BaseNode.prototype.initAccessibility = function () {
    var a = this.getElement();
    if (a) {
        var b = this.getLabelElement();
        b && !b.id && (b.id = this.getId() + ".label");
        LearnBlock.utils.aria.setRole(a, LearnBlock.utils.aria.Role.TREEITEM);
        LearnBlock.utils.aria.setState(a, LearnBlock.utils.aria.State.SELECTED, !1);
        LearnBlock.utils.aria.setState(a, LearnBlock.utils.aria.State.LEVEL, this.getDepth());
        b && LearnBlock.utils.aria.setState(a, LearnBlock.utils.aria.State.LABELLEDBY, b.id);
        if (b = this.getChildrenElement())
            if (LearnBlock.utils.aria.setRole(b, LearnBlock.utils.aria.Role.GROUP), b.hasChildNodes())
                for (LearnBlock.utils.aria.setState(a, LearnBlock.utils.aria.State.EXPANDED, !1), a = this.getChildCount(), b = 1; b <= a; b++) {
                    var c = this.getChildAt(b - 1).getElement();
                    LearnBlock.utils.aria.setState(c, LearnBlock.utils.aria.State.SETSIZE, a);
                    LearnBlock.utils.aria.setState(c, LearnBlock.utils.aria.State.POSINSET, b)
                }
    }
};
//Override methods
LearnBlock.tree.BaseNode.prototype.createDom = function () {
    var a = document.createElement("div");
    a.appendChild(this.toDom());
    this.setElementInternal(a)
};
LearnBlock.tree.BaseNode.prototype.enterDocument = function () {
    LearnBlock.tree.BaseNode.superClass_.enterDocument.call(this);
    LearnBlock.tree.BaseNode.allNodes[this.getId()] = this;
    this.initAccessibility()
};
LearnBlock.tree.BaseNode.prototype.exitDocument = function () {
    LearnBlock.tree.BaseNode.superClass_.exitDocument.call(this);
    delete LearnBlock.tree.BaseNode.allNodes[this.getId()]
};
//The method assumes that the child doesn't have parent node yet
LearnBlock.tree.BaseNode.prototype.addChildAt = function (a, b) {
    var c = this.getChildAt(b - 1),
        d = this.getChildAt(b);
    LearnBlock.tree.BaseNode.superClass_.addChildAt.call(this, a, b);
    a.previousSibling_ = c;
    a.nextSibling_ = d;
    c ? c.nextSibling_ = a : this.firstChild_ = a;
    d ? d.previousSibling_ = a : this.lastChild_ = a;
    var e = this.getTree();
    e && a.setTreeInternal(e);
    a.setDepth_(this.getDepth() + 1);
    if (e = this.getElement())
        if (LearnBlock.utils.aria.setState(e, LearnBlock.utils.aria.State.EXPANDED, this.getExpanded()), this.getExpanded()) {
            e =
                this.getChildrenElement();
            a.getElement() || a.createDom();
            var f = a.getElement(),
                g = d && d.getElement();
            e.insertBefore(f, g);
            this.isInDocument() && a.enterDocument();
            d || (c ? c.updateExpandIcon() : (LearnBlock.utils.style.setElementShown(e, !0), this.setExpanded(this.getExpanded())))
        }
};
//Appends a node as a child to the current node
LearnBlock.tree.BaseNode.prototype.add = function (a) {
    if (a.getParent()) throw Error(LearnBlock.Component.Error.PARENT_UNABLE_TO_BE_SET);
    this.addChildAt(a, this.getChildCount())
};
//Returns the tree
LearnBlock.tree.BaseNode.prototype.getTree = function () {
    return null
};
//Returns the depth of the node in the tree
LearnBlock.tree.BaseNode.prototype.getDepth = function () {
    var a = this.depth_;
    0 > a && (a = this.computeDepth_(), this.setDepth_(a));
    return a
};
//Computes the depth of the node in the tree
LearnBlock.tree.BaseNode.prototype.computeDepth_ = function () {
    var a = this.getParent();
    return a ? a.getDepth() + 1 : 0
};
//Changes the depth of a node
LearnBlock.tree.BaseNode.prototype.setDepth_ = function (a) {
    if (a != this.depth_) {
        this.depth_ = a;
        var b = this.getRowElement();
        if (b) {
            var c = this.getPixelIndent_() + "px";
            this.isRightToLeft() ? b.style.paddingRight = c : b.style.paddingLeft = c
        }
        this.forEachChild(function (b) {
            b.setDepth_(a + 1)
        })
    }
};
//Returns true if the node is a descendant of this node
LearnBlock.tree.BaseNode.prototype.contains = function (a) {
    for (; a;) {
        if (a == this) return !0;
        a = a.getParent()
    }
    return !1
};
//Returns the children of this node
LearnBlock.tree.BaseNode.prototype.getChildren = function () {
    var a = [];
    this.forEachChild(function (b) {
        a.push(b)
    });
    return a
};
//The first child of this node
LearnBlock.tree.BaseNode.prototype.getFirstChild = function () {
    return this.getChildAt(0)
};
//The last child of this node
LearnBlock.tree.BaseNode.prototype.getLastChild = function () {
    return this.getChildAt(this.getChildCount() - 1)
};
//The previous sibling of this node
LearnBlock.tree.BaseNode.prototype.getPreviousSibling = function () {
    return this.previousSibling_
};
//The next sibling of this node
LearnBlock.tree.BaseNode.prototype.getNextSibling = function () {
    return this.nextSibling_
};
//Whether the node is the last sibling
LearnBlock.tree.BaseNode.prototype.isLastSibling = function () {
    return !this.nextSibling_
};
//Whether the node is selected
LearnBlock.tree.BaseNode.prototype.isSelected = function () {
    return this.selected_
};
//Selects the node
LearnBlock.tree.BaseNode.prototype.select = function () {
    var a = this.getTree();
    a && a.setSelectedItem(this)
};
//Selects the first node
LearnBlock.tree.BaseNode.prototype.selectFirst = function () {
    var a = this.getTree();
    a && this.firstChild_ && a.setSelectedItem(this.firstChild_)
};
//Called from the tree to instruct the node change its selection state
LearnBlock.tree.BaseNode.prototype.setSelectedInternal = function (a) {
    if (this.selected_ != a) {
        this.selected_ = a;
        this.updateRow();
        var b = this.getElement();
        b && (LearnBlock.utils.aria.setState(b, LearnBlock.utils.aria.State.SELECTED, a), a && (a = this.getTree().getElement(), LearnBlock.utils.aria.setState(a, LearnBlock.utils.aria.State.ACTIVEDESCENDANT, this.getId())))
    }
};
//Whether the node is expanded
LearnBlock.tree.BaseNode.prototype.getExpanded = function () {
    return this.expanded_
};
//Sets the node to be expanded internally
LearnBlock.tree.BaseNode.prototype.setExpandedInternal = function (a) {
    this.expanded_ = a
};
//Sets the node to be expanded
LearnBlock.tree.BaseNode.prototype.setExpanded = function (a) {
    var b = a != this.expanded_,
        c;
    this.expanded_ = a;
    var d = this.getTree(),
        e = this.getElement();
    if (this.hasChildren()) {
        if (!a && d && this.contains(d.getSelectedItem()) && this.select(), e) {
            if (c = this.getChildrenElement()) LearnBlock.utils.style.setElementShown(c, a), LearnBlock.utils.aria.setState(e, LearnBlock.utils.aria.State.EXPANDED, a), a && this.isInDocument() && !c.hasChildNodes() && (this.forEachChild(function (a) {
                c.appendChild(a.toDom())
            }), this.forEachChild(function (a) {
                a.enterDocument()
            }));
            this.updateExpandIcon()
        }
    } else(c = this.getChildrenElement()) && LearnBlock.utils.style.setElementShown(c, !1);
    e && this.updateIcon_();
    b && (a ? this.doNodeExpanded() : this.doNodeCollapsed())
};
//Used to notify a node of that it has been expanded
LearnBlock.tree.BaseNode.prototype.doNodeExpanded = function () {};
//Used to notify a node that it has been collapsed
LearnBlock.tree.BaseNode.prototype.doNodeCollapsed = function () {};
//Toggles the expanded state of the node
LearnBlock.tree.BaseNode.prototype.toggle = function () {
    this.setExpanded(!this.getExpanded())
};
//Whether the node is collapsible by user actions
LearnBlock.tree.BaseNode.prototype.isUserCollapsible = function () {
    return this.isUserCollapsible_
};
//Creates HTML Element for the node
LearnBlock.tree.BaseNode.prototype.toDom = function () {
    var a = this.getExpanded() && this.hasChildren(),
        b = document.createElement("div");
    b.style.backgroundPosition = this.getBackgroundPosition();
    a || (b.style.display = "none");
    a && this.forEachChild(function (a) {
        b.appendChild(a.toDom())
    });
    a = document.createElement("div");
    a.id = this.getId();
    a.appendChild(this.getRowDom());
    a.appendChild(b);
    return a
};
//The pixel indent of the row
LearnBlock.tree.BaseNode.prototype.getPixelIndent_ = function () {
    return Math.max(0, (this.getDepth() - 1) * this.config_.indentWidth)
};
//The HTML element for the row
LearnBlock.tree.BaseNode.prototype.getRowDom = function () {
    var a = document.createElement("div");
    a.className = this.getRowClassName();
    a.style["padding-" + (this.isRightToLeft() ? "right" : "left")] = this.getPixelIndent_() + "px";
    a.appendChild(this.getLabelDom());
    return a
};
//The class name for the row
LearnBlock.tree.BaseNode.prototype.getRowClassName = function () {
    var a = "";
    this.isSelected() && (a = " " + (this.config_.cssSelectedRow || ""));
    return this.config_.cssTreeRow + a
};
//The HTML element for the label
LearnBlock.tree.BaseNode.prototype.getLabelDom = function () {
    var a = document.createElement("span");
    a.className = this.config_.cssItemLabel || "";
    a.textContent = this.getText();
    return a
};
//The background position style value
LearnBlock.tree.BaseNode.prototype.getBackgroundPosition = function () {
    return (this.isLastSibling() ? "-100" : (this.getDepth() - 1) * this.config_.indentWidth) + "px 0"
};
//The element for the tree node
LearnBlock.tree.BaseNode.prototype.getElement = function () {
    var a = LearnBlock.tree.BaseNode.superClass_.getElement.call(this);
    a || (a = document.getElementById(this.getId()), this.setElementInternal(a));
    return a
};
//The row is the div that is used to draw the node without the children
LearnBlock.tree.BaseNode.prototype.getRowElement = function () {
    var a = this.getElement();
    return a ? a.firstChild : null
};
//The label element
LearnBlock.tree.BaseNode.prototype.getLabelElement = function () {
    var a = this.getRowElement();
    return a && a.lastChild ? a.lastChild.previousSibling : null
};
//The div containing the children
LearnBlock.tree.BaseNode.prototype.getChildrenElement = function () {
    var a = this.getElement();
    return a ? a.lastChild : null
};
//Sets the text of the label
LearnBlock.tree.BaseNode.prototype.setText = function (a) {
    this.content_ = a
};
//Returns the text of the label
LearnBlock.tree.BaseNode.prototype.getText = function () {
    return this.content_
};
//Updates the row styles
LearnBlock.tree.BaseNode.prototype.updateRow = function () {
    var a = this.getRowElement();
    a && (a.className = this.getRowClassName())
};
//Handles mouse down event
LearnBlock.tree.BaseNode.prototype.onMouseDown = function (a) {
    "expand" == a.target.getAttribute("type") && this.hasChildren() ? this.isUserCollapsible_ && this.toggle() : (this.select(), this.updateRow())
};
//Handles a click event
LearnBlock.tree.BaseNode.prototype.onClick_ = function (a) {
    a.preventDefault()
};
//Handles a key down event
LearnBlock.tree.BaseNode.prototype.onKeyDown = function (a) {
    var b = !0;
    switch (a.keyCode) {
        case LearnBlock.utils.KeyCodes.RIGHT:
            if (a.altKey) break;
            b = this.selectChild();
            break;
        case LearnBlock.utils.KeyCodes.LEFT:
            if (a.altKey) break;
            b = this.selectParent();
            break;
        case LearnBlock.utils.KeyCodes.DOWN:
            b = this.selectNext();
            break;
        case LearnBlock.utils.KeyCodes.UP:
            b = this.selectPrevious();
            break;
        default:
            b = !1
    }
    b && a.preventDefault();
    return b
};
//Selects the next node
LearnBlock.tree.BaseNode.prototype.selectNext = function () {
    var a = this.getNextShownNode();
    a && a.select();
    return !0
};
//Selects the previous node
LearnBlock.tree.BaseNode.prototype.selectPrevious = function () {
    var a = this.getPreviousShownNode();
    a && a.select();
    return !0
};
//Selects the parent node
LearnBlock.tree.BaseNode.prototype.selectParent = function () {
    var a = this.getParent(),
        b = this.getTree();
    a && a != b && a.select()
    return !0
};
//Selects the child node
LearnBlock.tree.BaseNode.prototype.selectChild = function () {
    if (this.hasChildren()) {
        this.getFirstChild().select();
        return true;
    }
    return false;
};
//The last shown descendant
LearnBlock.tree.BaseNode.prototype.getLastShownDescendant = function () {
    return this.getExpanded() && this.hasChildren() ? this.getLastChild().getLastShownDescendant() : this
};
//The next node to show
LearnBlock.tree.BaseNode.prototype.getNextShownNode = function () {
    if (this.hasChildren() && this.getExpanded()) return this.getFirstChild();
    for (var a = this, b; a != this.getTree();) {
        b = a.getNextSibling();
        if (null != b) return b;
        a = a.getParent()
    }
    return null
};
//The previous node to show
LearnBlock.tree.BaseNode.prototype.getPreviousShownNode = function () {
    var a = this.getPreviousSibling();
    if (null != a) return a.getLastShownDescendant();
    a = this.getParent();
    var b = this.getTree();
    return a == b || this == b ? null : a
};
//The configuration for the tree
LearnBlock.tree.BaseNode.prototype.getConfig = function () {
    return this.config_
};
//Internal method that is used to set the tree control on the node
LearnBlock.tree.BaseNode.prototype.setTreeInternal = function (a) {
    this.tree != a && (this.tree = a, this.forEachChild(function (b) {
        b.setTreeInternal(a)
    }))
};

//Class for a single node in the tree
LearnBlock.tree.TreeNode = function (a, b, c) {
    this.toolbox_ = a;
    LearnBlock.tree.BaseNode.call(this, b, c)
};
LearnBlock.utils.object.inherits(LearnBlock.tree.TreeNode, LearnBlock.tree.BaseNode);
//Returns the tree
LearnBlock.tree.TreeNode.prototype.getTree = function () {
    if (this.tree) return this.tree;
    var a = this.getParent();
    return a && (a = a.getTree()) ? (this.setTreeInternal(a), a) : null
};
//Expands or collapses the node on mouse click
LearnBlock.tree.TreeNode.prototype.onClick_ = function (a) {
    this.hasChildren() && this.isUserCollapsible() ? (this.toggle(), this.select()) : this.isSelected() ? this.getTree().setSelectedItem(null) : this.select();
    this.updateRow()
};
//Suppresses the inherited mouse down behaviour
LearnBlock.tree.TreeNode.prototype.onMouseDown = function (a) {};
//Arrow keys work properly
LearnBlock.tree.TreeNode.prototype.onKeyDown = function (a) {
    if (this.tree.toolbox_.horizontalLayout_) {
        var b = {},
            c = LearnBlock.utils.KeyCodes.DOWN,
            d = LearnBlock.utils.KeyCodes.UP;
        b[LearnBlock.utils.KeyCodes.RIGHT] = this.isRightToLeft() ? d : c;
        b[LearnBlock.utils.KeyCodes.LEFT] = this.isRightToLeft() ? c : d;
        b[LearnBlock.utils.KeyCodes.UP] = LearnBlock.utils.KeyCodes.LEFT;
        b[LearnBlock.utils.KeyCodes.DOWN] = LearnBlock.utils.KeyCodes.RIGHT;
        Object.defineProperties(a, {
            keyCode: {
                value: b[a.keyCode] || a.keyCode
            }
        })
    }
    return LearnBlock.tree.TreeNode.superClass_.onKeyDown.call(this,
        a)
};
//Sets the handler that's triggered when the size of node has changed
LearnBlock.tree.TreeNode.prototype.onSizeChanged = function (a) {
    this.onSizeChanged_ = a
};
//Triggers a size changed event if a handler exists
LearnBlock.tree.TreeNode.prototype.resizeToolbox_ = function () {
    this.onSizeChanged_ && this.onSizeChanged_.call(this.toolbox_)
};
//Resizes the toolbox when a node is expanded
LearnBlock.tree.TreeNode.prototype.doNodeExpanded = LearnBlock.tree.TreeNode.prototype.resizeToolbox_;
//Resizes the toolbox when a node is collased
LearnBlock.tree.TreeNode.prototype.doNodeCollapsed = LearnBlock.tree.TreeNode.prototype.resizeToolbox_;

//Class for an extension of the TreeControl object that provides a way to view a hierarchical set of data
LearnBlock.tree.TreeControl = function (a, b) {
    this.toolbox_ = a;
    LearnBlock.tree.BaseNode.call(this, "", b);
    this.setExpandedInternal(!0);
    this.setSelectedInternal(!0);
    this.selectedItem_ = this
};
LearnBlock.utils.object.inherits(LearnBlock.tree.TreeControl, LearnBlock.tree.BaseNode);
//Returns the tree
LearnBlock.tree.TreeControl.prototype.getTree = function () {
    return this
};
//Returns the associated toolbox
LearnBlock.tree.TreeControl.prototype.getToolbox = function () {
    return this.toolbox_
};
//Returns node depth
LearnBlock.tree.TreeControl.prototype.getDepth = function () {
    return 0
};
//Handles focus on the tree
LearnBlock.tree.TreeControl.prototype.handleFocus_ = function (a) {
    this.focused_ = !0;
    a = this.getElement();
    LearnBlock.utils.dom.addClass(a, "focused");
    this.selectedItem_ && this.selectedItem_.select()
};
//Handles blur on the tree
LearnBlock.tree.TreeControl.prototype.handleBlur_ = function (a) {
    this.focused_ = !1;
    a = this.getElement();
    LearnBlock.utils.dom.removeClass(a, "focused")
};
//Gets whether this tree has focus or not
LearnBlock.tree.TreeControl.prototype.hasFocus = function () {
    return this.focused_
};
//Override methods
LearnBlock.tree.TreeControl.prototype.getExpanded = function () {
    return !0
};
LearnBlock.tree.TreeControl.prototype.setExpanded = function (a) {
    this.setExpandedInternal(a)
};
LearnBlock.tree.TreeControl.prototype.getIconElement = function () {
    var a = this.getRowElement();
    return a ? a.firstChild : null
};
LearnBlock.tree.TreeControl.prototype.updateExpandIcon = function () {};
LearnBlock.tree.TreeControl.prototype.getRowClassName = function () {
    return LearnBlock.tree.TreeControl.superClass_.getRowClassName.call(this) + " " + this.getConfig().cssHideRoot
};
//Sets the selected item
LearnBlock.tree.TreeControl.prototype.setSelectedItem = function (a) {
    if (a != this.selectedItem_ && (!this.onBeforeSelected_ || this.onBeforeSelected_.call(this.toolbox_, a))) {
        var b = this.getSelectedItem();
        this.selectedItem_ && this.selectedItem_.setSelectedInternal(!1);
        (this.selectedItem_ = a) && a.setSelectedInternal(!0);
        this.onAfterSelected_ && this.onAfterSelected_.call(this.toolbox_, b, a)
    }
};
//Sets the handler that's triggered before a node is selected
LearnBlock.tree.TreeControl.prototype.onBeforeSelected = function (a) {
    this.onBeforeSelected_ = a
};
//Sets the handler that's triggered after a node is selected
LearnBlock.tree.TreeControl.prototype.onAfterSelected = function (a) {
    this.onAfterSelected_ = a
};
//Returns the selected item
LearnBlock.tree.TreeControl.prototype.getSelectedItem = function () {
    return this.selectedItem_
};
//Adds roles and states
LearnBlock.tree.TreeControl.prototype.initAccessibility = function () {
    LearnBlock.tree.TreeControl.superClass_.initAccessibility.call(this);
    var a = this.getElement();
    LearnBlock.utils.aria.setRole(a, LearnBlock.utils.aria.Role.TREE);
    LearnBlock.utils.aria.setState(a, LearnBlock.utils.aria.State.LABELLEDBY, this.getLabelElement().id)
};
//Override methods
LearnBlock.tree.TreeControl.prototype.enterDocument = function () {
    LearnBlock.tree.TreeControl.superClass_.enterDocument.call(this);
    var a = this.getElement();
    a.className = this.getConfig().cssRoot;
    a.setAttribute("hideFocus", "true");
    this.attachEvents_();
    this.initAccessibility()
};
LearnBlock.tree.TreeControl.prototype.exitDocument = function () {
    LearnBlock.tree.TreeControl.superClass_.exitDocument.call(this);
    this.detachEvents_()
};
//Adds the event listeners to the tree
LearnBlock.tree.TreeControl.prototype.attachEvents_ = function () {
    var a = this.getElement();
    a.tabIndex = 0;
    this.onFocusWrapper_ = LearnBlock.bindEvent_(a, "focus", this, this.handleFocus_);
    this.onBlurWrapper_ = LearnBlock.bindEvent_(a, "blur", this, this.handleBlur_);
    this.onClickWrapper_ = LearnBlock.bindEventWithChecks_(a, "click", this, this.handleMouseEvent_);
    this.onKeydownWrapper_ = LearnBlock.bindEvent_(a, "keydown", this, this.handleKeyEvent_)
};
//Removes the event listeners from the tree
LearnBlock.tree.TreeControl.prototype.detachEvents_ = function () {
    LearnBlock.unbindEvent_(this.onFocusWrapper_);
    LearnBlock.unbindEvent_(this.onBlurWrapper_);
    LearnBlock.unbindEvent_(this.onClickWrapper_);
    LearnBlock.unbindEvent_(this.onKeydownWrapper_)
};
//Handles mouse events
LearnBlock.tree.TreeControl.prototype.handleMouseEvent_ = function (a) {
    var b = this.getNodeFromEvent_(a);
    if (b) switch (a.type) {
        case "mousedown":
            b.onMouseDown(a);
            break;
        case "click":
            b.onClick_(a)
    }
};
//Handles key down on the tree
LearnBlock.tree.TreeControl.prototype.handleKeyEvent_ = function (a) {
    var b = !1;
    if (b = this.selectedItem_ && this.selectedItem_.onKeyDown(a) || b) LearnBlock.utils.style.scrollIntoContainerView(this.selectedItem_.getElement(), this.getElement().parentNode), a.preventDefault();
    return b
};
//Finds the containing node given an event
LearnBlock.tree.TreeControl.prototype.getNodeFromEvent_ = function (a) {
    for (var b = a.target; null != b;) {
        if (a = LearnBlock.tree.BaseNode.allNodes[b.id]) return a;
        if (b == this.getElement()) break;
        b = b.parentNode
    }
    return null
};
//Creates a new tree node using the same config as the root
LearnBlock.tree.TreeControl.prototype.createNode = function (a) {
    return new LearnBlock.tree.TreeNode(this.toolbox_, a || "", this.getConfig())
};

//Field for text input
LearnBlock.FieldTextInput = function (a, b, c) {
    this.spellcheck_ = !0;
    null == a && (a = "");
    LearnBlock.FieldTextInput.superClass_.constructor.call(this, a, b, c)
};
LearnBlock.utils.object.inherits(LearnBlock.FieldTextInput, LearnBlock.Field);
//Constructs a FieldTextInput from a JSON arg object
LearnBlock.FieldTextInput.fromJson = function (a) {
    var b = LearnBlock.utils.replaceMessageReferences(a.text);
    return new LearnBlock.FieldTextInput(b, void 0, a)
};
LearnBlock.FieldTextInput.prototype.SERIALIZABLE = !0;
LearnBlock.FieldTextInput.FONTSIZE = 11;
LearnBlock.FieldTextInput.BORDERRADIUS = 4;
LearnBlock.FieldTextInput.prototype.CURSOR = "text";
//Override configuration function
LearnBlock.FieldTextInput.prototype.configure_ = function (a) {
    LearnBlock.FieldTextInput.superClass_.configure_.call(this, a);
    "boolean" == typeof a.spellcheck && (this.spellcheck_ = a.spellcheck)
};
//Ensures that the input value casts to a valid string
LearnBlock.FieldTextInput.prototype.doClassValidation_ = function (a) {
    return null === a || void 0 === a ? null : String(a)
};
//Called by setValue if the text input is not valid
LearnBlock.FieldTextInput.prototype.doValueInvalid_ = function (a) {
    this.isBeingEdited_ && (this.isTextValid_ = !1, a = this.value_, this.value_ = this.htmlInput_.untypedDefaultValue_, this.sourceBlock_ && LearnBlock.Events.isEnabled() && LearnBlock.Events.fire(new LearnBlock.Events.BlockChange(this.sourceBlock_, "field", this.name || null, a, this.value_)))
};
//Called by setValue if the text input is valid
LearnBlock.FieldTextInput.prototype.doValueUpdate_ = function (a) {
    this.isTextValid_ = !0;
    this.value_ = a;
    this.isBeingEdited_ || (this.isDirty_ = !0)
};
//Updates the colour of the htmlInput given the current validity of the field's value
LearnBlock.FieldTextInput.prototype.render_ = function () {
    LearnBlock.FieldTextInput.superClass_.render_.call(this);
    this.isBeingEdited_ && (this.sourceBlock_.RTL ? setTimeout(this.resizeEditor_.bind(this), 0) : this.resizeEditor_(), this.isTextValid_ ? (LearnBlock.utils.dom.removeClass(this.htmlInput_, "blocklyInvalidInput"), LearnBlock.utils.aria.setState(this.htmlInput_, "invalid", !1)) : (LearnBlock.utils.dom.addClass(this.htmlInput_, "blocklyInvalidInput"), LearnBlock.utils.aria.setState(this.htmlInput_, "invalid", !0)))
};
//Sets whether this field is spellchecked by the browser
LearnBlock.FieldTextInput.prototype.setSpellcheck = function (a) {
    a != this.spellcheck_ && (this.spellcheck_ = a, this.htmlInput_ && this.htmlInput_.setAttribute("spellcheck", this.spellcheck_))
};
//Shows the inline free-text editor on top of the text
LearnBlock.FieldTextInput.prototype.showEditor_ = function (a) {
    this.workspace_ = this.sourceBlock_.workspace;
    a = a || !1;
    !a && (LearnBlock.utils.userAgent.MOBILE || LearnBlock.utils.userAgent.ANDROID || LearnBlock.utils.userAgent.IPAD) ? this.showPromptEditor_() : this.showInlineEditor_(a)
};
//Creates and shows a text input editor that is a prompt
LearnBlock.FieldTextInput.prototype.showPromptEditor_ = function () {
    var a = this;
    LearnBlock.prompt(LearnBlock.Msg.CHANGE_VALUE_TITLE, this.getText(), function (b) {
        a.setValue(b)
    })
};
//Creates and shows a text input editor that sits directly over the text input
LearnBlock.FieldTextInput.prototype.showInlineEditor_ = function (a) {
    LearnBlock.WidgetDiv.show(this, this.sourceBlock_.RTL, this.widgetDispose_.bind(this));
    this.htmlInput_ = this.widgetCreate_();
    this.isBeingEdited_ = !0;
    a || (this.htmlInput_.focus(), this.htmlInput_.select())
};
//Creates the text input editor widget
LearnBlock.FieldTextInput.prototype.widgetCreate_ = function () {
    var a = LearnBlock.WidgetDiv.DIV,
        b = document.createElement("input");
    b.className = "blocklyHtmlInput";
    b.setAttribute("spellcheck", this.spellcheck_);
    var c = LearnBlock.FieldTextInput.FONTSIZE * this.workspace_.scale + "pt";
    a.style.fontSize = c;
    b.style.fontSize = c;
    b.style.borderRadius = LearnBlock.FieldTextInput.BORDERRADIUS * this.workspace_.scale + "px";
    a.appendChild(b);
    b.value = b.defaultValue = this.getEditorText_(this.value_);
    b.untypedDefaultValue_ = this.value_;
    b.oldValue_ =
        null;
    LearnBlock.utils.userAgent.GECKO ? setTimeout(this.resizeEditor_.bind(this), 0) : this.resizeEditor_();
    this.bindInputEvents_(b);
    return b
};
//Closes the editor, saves the results, and disposes any events bound to the text input's editor
LearnBlock.FieldTextInput.prototype.widgetDispose_ = function () {
    this.isBeingEdited_ = !1;
    this.isTextValid_ = !0;
    this.forceRerender();
    if (this.onFinishEditing_) this.onFinishEditing_(this.value_);
    this.unbindInputEvents_();
    var a = LearnBlock.WidgetDiv.DIV.style;
    a.width = "auto";
    a.height = "auto";
    a.fontSize = ""
};
//Binds handlers for user input on the text input field's editor
LearnBlock.FieldTextInput.prototype.bindInputEvents_ = function (a) {
    this.onKeyDownWrapper_ = LearnBlock.bindEventWithChecks_(a, "keydown", this, this.onHtmlInputKeyDown_);
    this.onKeyInputWrapper_ = LearnBlock.bindEventWithChecks_(a, "input", this, this.onHtmlInputChange_)
};
//Unbinds handlers for user input and workspace size changes
LearnBlock.FieldTextInput.prototype.unbindInputEvents_ = function () {
    LearnBlock.unbindEvent_(this.onKeyDownWrapper_);
    LearnBlock.unbindEvent_(this.onKeyInputWrapper_)
};
//Handles key down to the editor
LearnBlock.FieldTextInput.prototype.onHtmlInputKeyDown_ = function (a) {
    a.keyCode == LearnBlock.utils.KeyCodes.ENTER ? (LearnBlock.WidgetDiv.hide(), LearnBlock.DropDownDiv.hideWithoutAnimation()) : a.keyCode == LearnBlock.utils.KeyCodes.ESC ? (this.htmlInput_.value = this.htmlInput_.defaultValue, LearnBlock.WidgetDiv.hide(), LearnBlock.DropDownDiv.hideWithoutAnimation()) : a.keyCode == LearnBlock.utils.KeyCodes.TAB && (LearnBlock.WidgetDiv.hide(), LearnBlock.DropDownDiv.hideWithoutAnimation(), this.sourceBlock_.tab(this, !a.shiftKey), a.preventDefault())
};
//Handles a change to the editor
LearnBlock.FieldTextInput.prototype.onHtmlInputChange_ = function (a) {
    a = this.htmlInput_.value;
    a !== this.htmlInput_.oldValue_ && (this.htmlInput_.oldValue_ = a, LearnBlock.Events.setGroup(!0), a = this.getValueFromEditorText_(a), this.setValue(a), this.forceRerender(), LearnBlock.Events.setGroup(!1))
};
//Sets the html input value and the field's internal value
LearnBlock.FieldTextInput.prototype.setEditorValue_ = function (a) {
    this.isDirty_ = !0;
    this.isBeingEdited_ && (this.htmlInput_.value = this.getEditorText_(a));
    this.setValue(a)
};
//Resizes the editor to fit the text
LearnBlock.FieldTextInput.prototype.resizeEditor_ = function () {
    var a = LearnBlock.WidgetDiv.DIV,
        b = this.getScaledBBox_();
    a.style.width = b.right - b.left + "px";
    a.style.height = b.bottom - b.top + "px";
    b = new LearnBlock.utils.Coordinate(this.sourceBlock_.RTL ? b.right - a.offsetWidth : b.left, b.top);
    b.y += 1;
    LearnBlock.utils.userAgent.GECKO && LearnBlock.WidgetDiv.DIV.style.top && (--b.x, --b.y);
    LearnBlock.utils.userAgent.WEBKIT && (b.y -= 3);
    a.style.left = b.x + "px";
    a.style.top = b.y + "px"
};
//Ensures that only a number may be entered
LearnBlock.FieldTextInput.numberValidator = function (a) {
    console.warn("LearnBlock.FieldTextInput.numberValidator is deprecated. Use LearnBlock.FieldNumber instead.");
    if (null === a) return null;
    a = String(a);
    a = a.replace(/O/ig, "0");
    a = a.replace(/,/g, "");
    a = Number(a || 0);
    return isNaN(a) ? null : String(a)
};
//Ensures that only a non-negative integer may be entered
LearnBlock.FieldTextInput.nonnegativeIntegerValidator = function (a) {
    (a = LearnBlock.FieldTextInput.numberValidator(a)) && (a = String(Math.max(0, Math.floor(a))));
    return a
};
//Returns whether or not the field is tab navigable
LearnBlock.FieldTextInput.prototype.isTabNavigable = function () {
    return !0
};
//Overrides the field's text representation
LearnBlock.FieldTextInput.prototype.getText_ = function () {
    return this.isBeingEdited_ && this.htmlInput_ ? this.htmlInput_.value : null
};
//Transforms the provided value into a text to show in the html input
LearnBlock.FieldTextInput.prototype.getEditorText_ = function (a) {
    return String(a)
};
//Transforms the text received from the html input into a value to store in this field
LearnBlock.FieldTextInput.prototype.getValueFromEditorText_ = function (a) {
    return a
};
LearnBlock.fieldRegistry.register("field_input", LearnBlock.FieldTextInput);

//Field for a dropdown
LearnBlock.FieldDropdown = function (a, b, c) {
    "function" != typeof a && LearnBlock.FieldDropdown.validateOptions_(a);
    this.menuGenerator_ = a;
    this.generatedOptions_ = null;
    this.selectedIndex_ = 0;
    this.trimOptions_();
    a = this.getOptions(!1)[0];
    LearnBlock.FieldDropdown.superClass_.constructor.call(this, a[1], b, c);
    this.selectedMenuItem_ = this.imageElement_ = null
};
LearnBlock.utils.object.inherits(LearnBlock.FieldDropdown, LearnBlock.Field);
//Constructs a FieldDropdown from a JSON arg object
LearnBlock.FieldDropdown.fromJson = function (a) {
    return new LearnBlock.FieldDropdown(a.options, void 0, a)
};
LearnBlock.FieldDropdown.prototype.SERIALIZABLE = !0;
LearnBlock.FieldDropdown.CHECKMARK_OVERHANG = 25;
LearnBlock.FieldDropdown.MAX_MENU_HEIGHT_VH = .45;
LearnBlock.FieldDropdown.IMAGE_Y_OFFSET = 5;
LearnBlock.FieldDropdown.IMAGE_Y_PADDING = 2 * LearnBlock.FieldDropdown.IMAGE_Y_OFFSET;
LearnBlock.FieldDropdown.ARROW_CHAR = "\u25be";
LearnBlock.FieldDropdown.prototype.CURSOR = "default";
//Creates the block UI for this dropdown
LearnBlock.FieldDropdown.prototype.initView = function () {
    LearnBlock.FieldDropdown.superClass_.initView.call(this);
    this.imageElement_ = LearnBlock.utils.dom.createSvgElement("image", {
        y: LearnBlock.FieldDropdown.IMAGE_Y_OFFSET
    }, this.fieldGroup_);
    this.arrow_ = LearnBlock.utils.dom.createSvgElement("tspan", {}, this.textElement_);
    this.arrow_.appendChild(document.createTextNode(this.sourceBlock_.RTL ? LearnBlock.FieldDropdown.ARROW_CHAR + " " : " " + LearnBlock.FieldDropdown.ARROW_CHAR));
    this.sourceBlock_.RTL ? this.textElement_.insertBefore(this.arrow_,
        this.textContent_) : this.textElement_.appendChild(this.arrow_)
};
//Creates a dropdown menu under the text
LearnBlock.FieldDropdown.prototype.showEditor_ = function () {
    this.menu_ = this.dropdownCreate_();
    this.menu_.render(LearnBlock.DropDownDiv.getContentDiv());
    LearnBlock.utils.dom.addClass(this.menu_.getElement(), "blocklyDropdownMenu");
    LearnBlock.DropDownDiv.showPositionedByField(this, this.dropdownDispose_.bind(this));
    this.menu_.focus();
    this.selectedMenuItem_ && LearnBlock.utils.style.scrollIntoContainerView(this.selectedMenuItem_.getElement(), this.menu_.getElement())
};
//Creates the dropdown editor
LearnBlock.FieldDropdown.prototype.dropdownCreate_ = function () {
    var a = new LearnBlock.Menu;
    a.setRightToLeft(this.sourceBlock_.RTL);
    a.setRole("listbox");
    var b = this.getOptions(!1);
    this.selectedMenuItem_ = null;
    for (var c = 0; c < b.length; c++) {
        var d = b[c][0],
            e = b[c][1];
        if ("object" == typeof d) {
            var f = new Image(d.width, d.height);
            f.src = d.src;
            f.alt = d.alt || "";
            d = f
        }
        d = new LearnBlock.MenuItem(d);
        d.setRole("option");
        d.setRightToLeft(this.sourceBlock_.RTL);
        d.setValue(e);
        d.setCheckable(!0);
        a.addChild(d, !0);
        d.setChecked(e == this.value_);
        e == this.value_ && (this.selectedMenuItem_ = d);
        d.onAction(this.handleMenuActionEvent_, this)
    }
    LearnBlock.utils.aria.setState(a.getElement(), LearnBlock.utils.aria.State.ACTIVEDESCENDANT, this.selectedMenuItem_ ? this.selectedMenuItem_.getId() : "");
    return a
};
//Dispose of events belonging to the dropdown editor
LearnBlock.FieldDropdown.prototype.dropdownDispose_ = function () {
    this.menu_.dispose();
    this.menu_ = null
};
//Handles an action in the dropdown menu
LearnBlock.FieldDropdown.prototype.handleMenuActionEvent_ = function (a) {
    LearnBlock.DropDownDiv.hideIfOwner(this, !0);
    this.onItemSelected(this.menu_, a)
};
//Handles the selection of an item in the dropdown menu
LearnBlock.FieldDropdown.prototype.onItemSelected = function (a, b) {
    this.setValue(b.getValue())
};
//Factors out common words in statically defined options
LearnBlock.FieldDropdown.prototype.trimOptions_ = function () {
    this.suffixField = this.prefixField = null;
    var a = this.menuGenerator_;
    if (Array.isArray(a)) {
        for (var b = !1, c = 0; c < a.length; c++) {
            var d = a[c][0];
            "string" == typeof d ? a[c][0] = LearnBlock.utils.replaceMessageReferences(d) : (null != d.alt && (a[c][0].alt = LearnBlock.utils.replaceMessageReferences(d.alt)), b = !0)
        }
        if (!(b || 2 > a.length)) {
            b = [];
            for (c = 0; c < a.length; c++) b.push(a[c][0]);
            c = LearnBlock.utils.string.shortestStringLength(b);
            d = LearnBlock.utils.string.commonWordPrefix(b, c);
            var e =
                LearnBlock.utils.string.commonWordSuffix(b, c);
            !d && !e || c <= d + e || (d && (this.prefixField = b[0].substring(0, d - 1)), e && (this.suffixField = b[0].substr(1 - e)), this.menuGenerator_ = LearnBlock.FieldDropdown.applyTrim_(a, d, e))
        }
    }
};
//Uses the calculated prefix and suffix lengths to trim all of the options in the given array
LearnBlock.FieldDropdown.applyTrim_ = function (a, b, c) {
    for (var d = [], e = 0; e < a.length; e++) {
        var f = a[e][0],
            g = a[e][1];
        f = f.substring(b, f.length - c);
        d[e] = [f, g]
    }
    return d
};
//True if the option list is generated by a function
LearnBlock.FieldDropdown.prototype.isOptionListDynamic = function () {
    return "function" == typeof this.menuGenerator_
};
//Returns a list of the options for this dropdown
LearnBlock.FieldDropdown.prototype.getOptions = function (a) {
    return this.isOptionListDynamic() ? (this.generatedOptions_ && a || (this.generatedOptions_ = this.menuGenerator_.call(this), LearnBlock.FieldDropdown.validateOptions_(this.generatedOptions_)), this.generatedOptions_) : this.menuGenerator_
};
//Ensures that the input value is a valid language-neutral option
LearnBlock.FieldDropdown.prototype.doClassValidation_ = function (a) {
    for (var b = !1, c = this.getOptions(!0), d = 0, e; e = c[d]; d++)
        if (e[1] == a) {
            b = !0;
            break
        } return b ? a : (this.sourceBlock_ && console.warn("Cannot set the dropdown's value to an unavailable option. Block type: " + this.sourceBlock_.type + ", Field name: " + this.name + ", Value: " + a), null)
};
//Updates the value of the dropdown field
LearnBlock.FieldDropdown.prototype.doValueUpdate_ = function (a) {
    LearnBlock.FieldDropdown.superClass_.doValueUpdate_.call(this, a);
    a = this.getOptions(!0);
    for (var b = 0, c; c = a[b]; b++) c[1] == this.value_ && (this.selectedIndex_ = b)
};
//Updates the dropdown arrow to match the colour/style of the block
LearnBlock.FieldDropdown.prototype.updateColour = function () {
    this.sourceBlock_ && this.arrow_ && (this.arrow_.style.fill = this.sourceBlock_.getColour())
};
//Draws the border with the correct width
LearnBlock.FieldDropdown.prototype.render_ = function () {
    this.textContent_.nodeValue = "";
    this.imageElement_.style.display = "none";
    var a = this.getOptions(!0);
    (a = 0 <= this.selectedIndex_ && a[this.selectedIndex_][0]) && "object" == typeof a ? this.renderSelectedImage_(a) : this.renderSelectedText_();
    this.borderRect_.setAttribute("height", this.size_.height);
    this.borderRect_.setAttribute("width", this.size_.width)
};
//Renders the selected option, which must be text
LearnBlock.FieldDropdown.prototype.renderSelectedText_ = function () {
    this.textContent_.nodeValue = this.getDisplayText_();
    this.textElement_.setAttribute("text-anchor", "start");
    this.textElement_.setAttribute("x", LearnBlock.Field.DEFAULT_TEXT_OFFSET);
    this.size_.height = LearnBlock.Field.BORDER_RECT_DEFAULT_HEIGHT;
    this.size_.width = LearnBlock.utils.dom.getTextWidth(this.textElement_) + LearnBlock.Field.X_PADDING
};
//Overrides the field's text representation
LearnBlock.FieldDropdown.prototype.getText_ = function () {
    if (0 > this.selectedIndex_) return null;
    var a = this.getOptions(!0)[this.selectedIndex_][0];
    return "object" == typeof a ? a.alt : a
};
//Validates the data structure to be processed as an options list
LearnBlock.FieldDropdown.validateOptions_ = function (a) {
    if (!Array.isArray(a)) throw TypeError("FieldDropdown options must be an array.");
    if (!a.length) throw TypeError("FieldDropdown options must not be an empty array.");
    for (var b = !1, c = 0; c < a.length; ++c) {
        var d = a[c];
        Array.isArray(d) ? "string" != typeof d[1] ? (b = !0, console.error("Invalid option[" + c + "]: Each FieldDropdown option id must be a string. Found " + d[1] + " in: ", d)) : d[0] && "string" != typeof d[0] && "string" != typeof d[0].src && (b = !0, console.error("Invalid option[" +
            c + "]: Each FieldDropdown option must have a string label or image description. Found" + d[0] + " in: ", d)) : (b = !0, console.error("Invalid option[" + c + "]: Each FieldDropdown option must be an array. Found: ", d))
    }
    if (b) throw TypeError("Found invalid FieldDropdown options.");
};
//Handles the given action
LearnBlock.FieldDropdown.prototype.onBlocklyAction = function (a) {
    if (this.menu_) {
        if (a === LearnBlock.navigation.ACTION_PREVIOUS) return this.menu_.highlightPrevious(), !0;
        if (a === LearnBlock.navigation.ACTION_NEXT) return this.menu_.highlightNext(), !0
    }
    return LearnBlock.FieldDropdown.superClass_.onBlocklyAction.call(this, a)
};
LearnBlock.fieldRegistry.register("field_dropdown", LearnBlock.FieldDropdown);

//Field for a number
LearnBlock.FieldNumber = function (a, b, c, d, e, f) {
    this.min_ = -Infinity;
    this.max_ = Infinity;
    this.precision_ = 0;
    this.decimalPlaces_ = null;
    LearnBlock.FieldNumber.superClass_.constructor.call(this, a || 0, e, f);
    f || this.setConstraints(b, c, d)
};
LearnBlock.utils.object.inherits(LearnBlock.FieldNumber, LearnBlock.FieldTextInput);
//Constructs a FieldNumber from a JSON arg object
LearnBlock.FieldNumber.fromJson = function (a) {
    return new LearnBlock.FieldNumber(a.value, void 0, void 0, void 0, void 0, a)
};
LearnBlock.FieldNumber.prototype.SERIALIZABLE = !0;
//Configures the field based on the given map of options
LearnBlock.FieldNumber.prototype.configure_ = function (a) {
    LearnBlock.FieldNumber.superClass_.configure_.call(this, a);
    this.setMinInternal_(a.min);
    this.setMaxInternal_(a.max);
    this.setPrecisionInternal_(a.precision)
};
//Sets the maximum, minimum and precision constraints on the field
LearnBlock.FieldNumber.prototype.setConstraints = function (a, b, c) {
    this.setMinInternal_(a);
    this.setMaxInternal_(b);
    this.setPrecisionInternal_(c);
    this.setValue(this.getValue())
};
//Sets the minimum value the field can contain
LearnBlock.FieldNumber.prototype.setMin = function (a) {
    this.setMinInternal_(a);
    this.setValue(this.getValue())
};
//Sets the minimum value the field can contain. Called internally
LearnBlock.FieldNumber.prototype.setMinInternal_ = function (a) {
    null == a ? this.min_ = -Infinity : (a = Number(a), isNaN(a) || (this.min_ = a))
};
//Returns the current minimum value the field can contain
LearnBlock.FieldNumber.prototype.getMin = function () {
    return this.min_
};
//Sets the maximum value the field can contain
LearnBlock.FieldNumber.prototype.setMax = function (a) {
    this.setMaxInternal_(a);
    this.setValue(this.getValue())
};
//Sets the maximum value the field can contain. Called internally
LearnBlock.FieldNumber.prototype.setMaxInternal_ = function (a) {
    null == a ? this.max_ = Infinity : (a = Number(a), isNaN(a) || (this.max_ = a))
};
//Returns the current maximum value the field can contain
LearnBlock.FieldNumber.prototype.getMax = function () {
    return this.max_
};
//Sets the precision of the field's value
LearnBlock.FieldNumber.prototype.setPrecision = function (a) {
    this.setPrecisionInternal_(a);
    this.setValue(this.getValue())
};
//Sets the precision of the field's value. Called internally
LearnBlock.FieldNumber.prototype.setPrecisionInternal_ = function (a) {
    null == a ? this.precision_ = 0 : (a = Number(a), isNaN(a) || (this.precision_ = a));
    var b = this.precision_.toString(),
        c = b.indexOf(".");
    this.decimalPlaces_ = -1 == c ? a ? 0 : null : b.length - c - 1
};
//Returns the current precision of the field
LearnBlock.FieldNumber.prototype.getPrecision = function () {
    return this.precision_
};
//Ensures that the input value is a valid number
LearnBlock.FieldNumber.prototype.doClassValidation_ = function (a) {
    if (null === a) return null;
    a = String(a);
    a = a.replace(/O/ig, "0");
    a = a.replace(/,/g, "");
    a = Number(a || 0);
    if (isNaN(a)) return null;
    a = Math.min(Math.max(a, this.min_), this.max_);
    this.precision_ && isFinite(a) && (a = Math.round(a / this.precision_) * this.precision_);
    null != this.decimalPlaces_ && (a = Number(a.toFixed(this.decimalPlaces_)));
    return a
};
//Creates the number input editor widget
LearnBlock.FieldNumber.prototype.widgetCreate_ = function () {
    var a = LearnBlock.FieldNumber.superClass_.widgetCreate_.call(this); - Infinity < this.min_ && LearnBlock.utils.aria.setState(a, LearnBlock.utils.aria.State.VALUEMIN, this.min_);
    Infinity > this.max_ && LearnBlock.utils.aria.setState(a, LearnBlock.utils.aria.State.VALUEMAX, this.max_);
    return a
};
LearnBlock.fieldRegistry.register("field_number", LearnBlock.FieldNumber);

//Field for a variable
LearnBlock.FieldVariable = function (a, b, c, d, e) {
    this.menuGenerator_ = LearnBlock.FieldVariable.dropdownCreate;
    this.defaultVariableName = a || "";
    this.size_ = new LearnBlock.utils.Size(0, LearnBlock.BlockSvg.MIN_BLOCK_Y);
    e && this.configure_(e);
    b && this.setValidator(b);
    e || this.setTypes_(c, d)
};
LearnBlock.utils.object.inherits(LearnBlock.FieldVariable, LearnBlock.FieldDropdown);
//Constructs a FieldVariable from a JSON arg object
LearnBlock.FieldVariable.fromJson = function (a) {
    var b = LearnBlock.utils.replaceMessageReferences(a.variable);
    return new LearnBlock.FieldVariable(b, void 0, void 0, void 0, a)
};
LearnBlock.FieldVariable.prototype.workspace_ = null;
LearnBlock.FieldVariable.prototype.SERIALIZABLE = !0;
//Configures the field based on the given map of options
LearnBlock.FieldVariable.prototype.configure_ = function (a) {
    LearnBlock.FieldVariable.superClass_.configure_.call(this, a);
    this.setTypes_(a.variableTypes, a.defaultType)
};
//Initializes the model for the field
LearnBlock.FieldVariable.prototype.initModel = function () {
    if (!this.variable_) {
        var a = LearnBlock.Variables.getOrCreateVariablePackage(this.sourceBlock_.workspace, null, this.defaultVariableName, this.defaultType_);
        LearnBlock.Events.disable();
        this.setValue(a.getId());
        LearnBlock.Events.enable()
    }
};
//Initializes the field based on the given XML
LearnBlock.FieldVariable.prototype.fromXml = function (a) {
    var b = a.getAttribute("id"),
        c = a.textContent,
        d = a.getAttribute("variabletype") || a.getAttribute("variableType") || "";
    b = LearnBlock.Variables.getOrCreateVariablePackage(this.sourceBlock_.workspace, b, c, d);
    if (null != d && d !== b.type) throw Error("Serialized variable type with id '" + b.getId() + "' had type " + b.type + ", and does not match variable field that references it: " + LearnBlock.Xml.domToText(a) + ".");
    this.setValue(b.getId())
};
//Serializes the field to XML
LearnBlock.FieldVariable.prototype.toXml = function (a) {
    this.initModel();
    a.id = this.variable_.getId();
    a.textContent = this.variable_.name;
    this.variable_.type && a.setAttribute("variabletype", this.variable_.type);
    return a
};
//Attaches the field to a block
LearnBlock.FieldVariable.prototype.setSourceBlock = function (a) {
    LearnBlock.FieldVariable.superClass_.setSourceBlock.call(this, a)
};
//Gets the variable's ID
LearnBlock.FieldVariable.prototype.getValue = function () {
    return this.variable_ ? this.variable_.getId() : null
};
//Gets the text from the field
LearnBlock.FieldVariable.prototype.getText = function () {
    return this.variable_ ? this.variable_.name : ""
};
//Gets the variable model for the selected variable
LearnBlock.FieldVariable.prototype.getVariable = function () {
    return this.variable_
};
//Gets the validation function for the field
LearnBlock.FieldVariable.prototype.getValidator = function () {
    return this.variable_ ? this.validator_ : null
};
//Ensures that the id belongs to a valid variable of an allowed type
LearnBlock.FieldVariable.prototype.doClassValidation_ = function (a) {
    if (null === a) return null;
    var b = LearnBlock.Variables.getVariable(this.sourceBlock_.workspace, a);
    if (!b) return console.warn("Variable id doesn't point to a real variable! ID was " + a), null;
    b = b.type;
    return this.typeIsAllowed_(b) ? a : (console.warn("Variable type doesn't match this field!  Type was " + b), null)
};
//Updates the value of the variable field, as well as its variable and text
LearnBlock.FieldVariable.prototype.doValueUpdate_ = function (a) {
    this.variable_ = LearnBlock.Variables.getVariable(this.sourceBlock_.workspace, a);
    LearnBlock.FieldVariable.superClass_.doValueUpdate_.call(this, a)
};
//Checks whether the given variable type is allowed on the field
LearnBlock.FieldVariable.prototype.typeIsAllowed_ = function (a) {
    var b = this.getVariableTypes_();
    if (!b) return !0;
    for (var c = 0; c < b.length; c++)
        if (a == b[c]) return !0;
    return !1
};
//Returns a list of variable types to include in the dropdown
LearnBlock.FieldVariable.prototype.getVariableTypes_ = function () {
    var a = this.variableTypes;
    if (null === a && this.sourceBlock_ && this.sourceBlock_.workspace) return this.sourceBlock_.workspace.getVariableTypes();
    a = a || [""];
    if (0 == a.length) throw a = this.getText(), Error("'variableTypes' of field variable " + a + " was an empty list");
    return a
};
//Parses the optional arguments representing the allowed variable types and the default variable type
LearnBlock.FieldVariable.prototype.setTypes_ = function (a, b) {
    var c = b || "";
    if (null == a || void 0 == a) var d = null;
    else if (Array.isArray(a)) {
        d = a;
        for (var e = !1, f = 0; f < d.length; f++) d[f] == c && (e = !0);
        if (!e) throw Error("Invalid default type '" + c + "' in the definition of a FieldVariable");
    } else throw Error("'variableTypes' was not an array in the definition of a FieldVariable");
    this.defaultType_ = c;
    this.variableTypes = d
};
//Refreshes the name of the variable by grabbing the name of the model
LearnBlock.FieldVariable.prototype.refreshVariableName = function () {
    this.forceRerender()
};
//Returns a sorted list of variable names for variable dropdown menus
LearnBlock.FieldVariable.dropdownCreate = function () {
    if (!this.variable_) throw Error("Tried to call dropdownCreate on a variable field with no variable selected.");
    var a = this.getText(),
        b = [];
    if (this.sourceBlock_ && this.sourceBlock_.workspace)
        for (var c = this.getVariableTypes_(), d = 0; d < c.length; d++) {
            var e = this.sourceBlock_.workspace.getVariablesOfType(c[d]);
            b = b.concat(e)
        }
    b.sort(LearnBlock.VariableModel.compareByName);
    c = [];
    for (d = 0; d < b.length; d++) c[d] = [b[d].name, b[d].getId()];
    c.push([LearnBlock.Msg.RENAME_VARIABLE, LearnBlock.RENAME_VARIABLE_ID]);
    LearnBlock.Msg.DELETE_VARIABLE && c.push([LearnBlock.Msg.DELETE_VARIABLE.replace("%1", a), LearnBlock.DELETE_VARIABLE_ID]);
    return c
};
//Handles the selection of an item in the variable dropdown menu
LearnBlock.FieldVariable.prototype.onItemSelected = function (a, b) {
    var c = b.getValue();
    if (this.sourceBlock_ && this.sourceBlock_.workspace) {
        if (c == LearnBlock.RENAME_VARIABLE_ID) {
            LearnBlock.Variables.renameVariable(this.sourceBlock_.workspace, this.variable_);
            return
        }
        if (c == LearnBlock.DELETE_VARIABLE_ID) {
            this.sourceBlock_.workspace.deleteVariableById(this.variable_.getId());
            return
        }
    }
    this.setValue(c)
};
//Indicates the field refers to a variable
LearnBlock.FieldVariable.prototype.referencesVariables = function () {
    return !0
};
LearnBlock.fieldRegistry.register("field_variable", LearnBlock.FieldVariable);

//Class for a flyout cursor
LearnBlock.FlyoutCursor = function () {
    LearnBlock.FlyoutCursor.superClass_.constructor.call(this)
};
LearnBlock.utils.object.inherits(LearnBlock.FlyoutCursor, LearnBlock.Cursor);
//Finds the next connection, field, or block
LearnBlock.FlyoutCursor.prototype.next = function () {
    var a = this.getCurNode();
    if (!a) return null;
    (a = a.next()) && this.setCurNode(a);
    return a
};
LearnBlock.FlyoutCursor.prototype["in"] = function () {
    return null
};
//Finds the previous connection, field, or block
LearnBlock.FlyoutCursor.prototype.prev = function () {
    var a = this.getCurNode();
    if (!a) return null;
    (a = a.prev()) && this.setCurNode(a);
    return a
};
LearnBlock.FlyoutCursor.prototype.out = function () {
    return null
};

//Functions flyout
LearnBlock.Flyout = function (a) {
    a.getMetrics = this.getMetrics_.bind(this);
    a.setMetrics = this.setMetrics_.bind(this);
    this.workspace_ = new LearnBlock.WorkspaceSvg(a);
    this.workspace_.isFlyout = !0;
    this.workspace_.setCursor(new LearnBlock.FlyoutCursor);
    this.workspace_.setMarker(new LearnBlock.MarkerCursor);
    this.RTL = !!a.RTL;
    this.toolboxPosition_ = a.toolboxPosition;
    this.eventWrappers_ = [];
    this.mats_ = [];
    this.buttons_ = [];
    this.listeners_ = [];
    this.permanentlyDisabled_ = [];
    this.tabWidth_ = this.workspace_.getRenderer().getConstants().TAB_WIDTH
};
LearnBlock.Flyout.prototype.autoClose = true;
LearnBlock.Flyout.prototype.isVisible_ = false;
LearnBlock.Flyout.prototype.containerVisible_ = true;
LearnBlock.Flyout.prototype.CORNER_RADIUS = 8;
LearnBlock.Flyout.prototype.MARGIN = LearnBlock.Flyout.prototype.CORNER_RADIUS;
LearnBlock.Flyout.prototype.GAP_X = 3 * LearnBlock.Flyout.prototype.MARGIN;
LearnBlock.Flyout.prototype.GAP_Y = 3 * LearnBlock.Flyout.prototype.MARGIN;
LearnBlock.Flyout.prototype.SCROLLBAR_PADDING = 2;
LearnBlock.Flyout.prototype.width_ = 0;
LearnBlock.Flyout.prototype.height_ = 0;
LearnBlock.Flyout.prototype.dragAngleRange_ = 70;
//Creates the flyout's DOM
LearnBlock.Flyout.prototype.createDom = function (a) {
    this.svgGroup_ = LearnBlock.utils.dom.createSvgElement(a, {
        "class": "blocklyFlyout",
        style: "display: none"
    }, null);
    this.svgBackground_ = LearnBlock.utils.dom.createSvgElement("path", {
        "class": "blocklyFlyoutBackground"
    }, this.svgGroup_);
    this.svgGroup_.appendChild(this.workspace_.createDom());
    this.workspace_.getThemeManager().subscribe(this.svgBackground_, "flyout", "fill");
    this.workspace_.getThemeManager().subscribe(this.svgBackground_, "flyoutOpacity", "fill-opacity");
    return this.svgGroup_
};
//Initializes the flyout
LearnBlock.Flyout.prototype.init = function (a) {
    this.targetWorkspace_ = a;
    this.workspace_.targetWorkspace = a;
    this.scrollbar_ = new LearnBlock.Scrollbar(this.workspace_, this.horizontalLayout_, !1, "blocklyFlyoutScrollbar");
    this.hide();
    Array.prototype.push.apply(this.eventWrappers_, LearnBlock.bindEventWithChecks_(this.svgGroup_, "wheel", this, this.wheel_));
    this.autoClose || (this.filterWrapper_ = this.filterForCapacity_.bind(this), this.targetWorkspace_.addChangeListener(this.filterWrapper_));
    Array.prototype.push.apply(this.eventWrappers_,
        LearnBlock.bindEventWithChecks_(this.svgBackground_, "mousedown", this, this.onMouseDown_));
    this.workspace_.getGesture = this.targetWorkspace_.getGesture.bind(this.targetWorkspace_);
    this.workspace_.variableMap_ = this.targetWorkspace_.getVariableMap();
    this.workspace_.createPotentialVariableMap()
};
//Dispose of this flyout
LearnBlock.Flyout.prototype.dispose = function () {
    this.hide();
    LearnBlock.unbindEvent_(this.eventWrappers_);
    this.filterWrapper_ && (this.targetWorkspace_.removeChangeListener(this.filterWrapper_), this.filterWrapper_ = null);
    this.scrollbar_ && (this.scrollbar_.dispose(), this.scrollbar_ = null);
    this.workspace_ && (this.workspace_.getThemeManager().unsubscribe(this.svgBackground_), this.workspace_.targetWorkspace = null, this.workspace_.dispose(), this.workspace_ = null);
    this.svgGroup_ && (LearnBlock.utils.dom.removeNode(this.svgGroup_),
        this.svgGroup_ = null);
    this.targetWorkspace_ = this.svgBackground_ = null
};
//Gets the width of the flyout
LearnBlock.Flyout.prototype.getWidth = function () {
    return this.width_
};
//Gets the height of the flyout
LearnBlock.Flyout.prototype.getHeight = function () {
    return this.height_
};
//Gets the workspace inside the flyout
LearnBlock.Flyout.prototype.getWorkspace = function () {
    return this.workspace_
};
//Is the flyout visible?
LearnBlock.Flyout.prototype.isVisible = function () {
    return this.isVisible_
};
//Sets whether the flyout is visible
LearnBlock.Flyout.prototype.setVisible = function (a) {
    var b = a != this.isVisible();
    this.isVisible_ = a;
    b && this.updateDisplay_()
};
//Sets whether this flyout's container is visible
LearnBlock.Flyout.prototype.setContainerVisible = function (a) {
    var b = a != this.containerVisible_;
    this.containerVisible_ = a;
    b && this.updateDisplay_()
};
//Updates the display property of the flyout based whether it thinks it should be visible and whether its containing workspace is visible
LearnBlock.Flyout.prototype.updateDisplay_ = function () {
    var a = this.containerVisible_ ? this.isVisible() : !1;
    this.svgGroup_.style.display = a ? "block" : "none";
    this.scrollbar_.setContainerVisible(a)
};
//Updates the view based on coordinates calculated
LearnBlock.Flyout.prototype.positionAt_ = function (a, b, c, d) {
    this.svgGroup_.setAttribute("width", a);
    this.svgGroup_.setAttribute("height", b);
    "svg" == this.svgGroup_.tagName ? LearnBlock.utils.dom.setCssTransform(this.svgGroup_, "translate(" + c + "px," + d + "px)") : this.svgGroup_.setAttribute("transform", "translate(" + c + "," + d + ")");
    this.scrollbar_ && (this.scrollbar_.setOrigin(c, d), this.scrollbar_.resize(), this.scrollbar_.setPosition_(this.scrollbar_.position_.x, this.scrollbar_.position_.y))
};
//Hides and empties the flyout
LearnBlock.Flyout.prototype.hide = function () {
    if (this.isVisible()) {
        this.setVisible(!1);
        for (var a = 0, b; b = this.listeners_[a]; a++) LearnBlock.unbindEvent_(b);
        this.listeners_.length = 0;
        this.reflowWrapper_ && (this.workspace_.removeChangeListener(this.reflowWrapper_), this.reflowWrapper_ = null)
    }
};
//Shows and populates the flyout
LearnBlock.Flyout.prototype.show = function (a) {
    this.workspace_.setResizesEnabled(!1);
    this.hide();
    this.clearOldBlocks_();
    if ("string" == typeof a) {
        a = this.workspace_.targetWorkspace.getToolboxCategoryCallback(a);
        if ("function" != typeof a) throw TypeError("Couldn't find a callback function when opening a toolbox category.");
        a = a(this.workspace_.targetWorkspace);
        if (!Array.isArray(a)) throw TypeError("Result of toolbox category callback must be an array.");
    }
    this.setVisible(!0);
    var b = [],
        c = [];
    this.permanentlyDisabled_.length = 0;
    for (var d = this.horizontalLayout_ ? this.GAP_X : this.GAP_Y, e = 0, f; f = a[e]; e++)
        if (f.tagName) switch (f.tagName.toUpperCase()) {
            case "BLOCK":
                var g = LearnBlock.Xml.domToBlock(f, this.workspace_);
                this.permanentlyDisabled_.push(g);
                b.push({
                    type: "block",
                    block: g
                });
                f = parseInt(f.getAttribute("gap"), 10);
                c.push(isNaN(f) ? d : f);
                break;
            case "SEP":
                f = parseInt(f.getAttribute("gap"), 10);
                !isNaN(f) && 0 < c.length ? c[c.length - 1] = f : c.push(d);
                break;
            case "LABEL":
            case "BUTTON":
                g = "LABEL" == f.tagName.toUpperCase();
                if (!LearnBlock.FlyoutButton) throw Error("Missing require for LearnBlock.FlyoutButton");
                f = new LearnBlock.FlyoutButton(this.workspace_, this.targetWorkspace_, f, g);
                b.push({
                    type: "button",
                    button: f
                });
                c.push(d)
        }
    this.layout_(b, c);
    this.listeners_.push(LearnBlock.bindEventWithChecks_(this.svgBackground_, "mouseover", this, function () {
        for (var a = this.workspace_.getTopBlocks(!1), b = 0, c; c = a[b]; b++) c.removeSelect()
    }));
    this.horizontalLayout_ ? this.height_ = 0 : this.width_ = 0;
    this.workspace_.setResizesEnabled(!0);
    this.reflow();
    this.filterForCapacity_();
    this.position();
    this.reflowWrapper_ = this.reflow.bind(this);
    this.workspace_.addChangeListener(this.reflowWrapper_)
};
//Deletes blocks, mats and buttons from a previous showing of the flyout
LearnBlock.Flyout.prototype.clearOldBlocks_ = function () {
    for (var a = this.workspace_.getTopBlocks(!1), b = 0, c; c = a[b]; b++) c.workspace == this.workspace_ && c.dispose(!1, !1);
    for (b = 0; b < this.mats_.length; b++)(a = this.mats_[b]) && LearnBlock.utils.dom.removeNode(a);
    for (b = this.mats_.length = 0; a = this.buttons_[b]; b++) a.dispose();
    this.buttons_.length = 0;
    this.workspace_.getPotentialVariableMap().clear()
};
//Adds listeners to a block that has been added to the flyout
LearnBlock.Flyout.prototype.addBlockListeners_ = function (a, b, c) {
    this.listeners_.push(LearnBlock.bindEventWithChecks_(a, "mousedown", null, this.blockMouseDown_(b)));
    this.listeners_.push(LearnBlock.bindEventWithChecks_(c, "mousedown", null, this.blockMouseDown_(b)));
    this.listeners_.push(LearnBlock.bindEvent_(a, "mouseover", b, b.addSelect));
    this.listeners_.push(LearnBlock.bindEvent_(a, "mouseout", b, b.removeSelect));
    this.listeners_.push(LearnBlock.bindEvent_(c, "mouseover", b, b.addSelect));
    this.listeners_.push(LearnBlock.bindEvent_(c,
        "mouseout", b, b.removeSelect))
};
//Handles a mouse-down on an SVG block in a non-closing flyout
LearnBlock.Flyout.prototype.blockMouseDown_ = function (a) {
    var b = this;
    return function (c) {
        var d = b.targetWorkspace_.getGesture(c);
        d && (d.setStartBlock(a), d.handleFlyoutStart(c, b))
    }
};
//Mouse down on the flyout background
LearnBlock.Flyout.prototype.onMouseDown_ = function (a) {
    var b = this.targetWorkspace_.getGesture(a);
    b && b.handleFlyoutStart(a, this)
};
//Used for deciding if a block can be "dragged out of" the flyout
LearnBlock.Flyout.prototype.isBlockCreatable_ = function (a) {
    return true
};
//Creates a copy of the block on the workspace
LearnBlock.Flyout.prototype.createBlock = function (a) {
    var b = null;
    LearnBlock.Events.disable();
    var c = this.targetWorkspace_.getAllVariables();
    this.targetWorkspace_.setResizesEnabled(!1);
    try {
        b = this.placeNewBlock_(a), LearnBlock.hideChaff()
    } finally {
        LearnBlock.Events.enable()
    }
    a = LearnBlock.Variables.getAddedVariables(this.targetWorkspace_, c);
    if (LearnBlock.Events.isEnabled())
        for (LearnBlock.Events.setGroup(!0), LearnBlock.Events.fire(new LearnBlock.Events.Create(b)), c = 0; c < a.length; c++) LearnBlock.Events.fire(new LearnBlock.Events.VarCreate(a[c]));
    this.autoClose ? this.hide() : this.filterForCapacity_();
    return b
};
//Initializes the given button
LearnBlock.Flyout.prototype.initFlyoutButton_ = function (a, b, c) {
    var d = a.createDom();
    a.moveTo(b, c);
    a.show();
    this.listeners_.push(LearnBlock.bindEventWithChecks_(d, "mousedown", this, this.onMouseDown_));
    this.buttons_.push(a)
};
//Creates and places a rectangle corresponding to the given block
LearnBlock.Flyout.prototype.createRect_ = function (a, b, c, d, e) {
    b = LearnBlock.utils.dom.createSvgElement("rect", {
        "fill-opacity": 0,
        x: b,
        y: c,
        height: d.height,
        width: d.width
    }, null);
    b.tooltip = a;
    this.workspace_.getCanvas().insertBefore(b, a.getSvgRoot());
    a.flyoutRect_ = b;
    return this.mats_[e] = b
};
//Moves a rectangle to sit exactly behind a block
LearnBlock.Flyout.prototype.moveRectToBlock_ = function (a, b) {
    var c = b.getHeightWidth();
    a.setAttribute("width", c.width);
    a.setAttribute("height", c.height);
    var d = b.getRelativeToSurfaceXY();
    a.setAttribute("y", d.y);
    a.setAttribute("x", this.RTL ? d.x - c.width : d.x)
};
//Filters the blocks on the flyout to disable the ones that are above the capacity limit
LearnBlock.Flyout.prototype.filterForCapacity_ = function () {
    for (var a = this.workspace_.getTopBlocks(!1), b = 0, c; c = a[b]; b++)
        if (-1 == this.permanentlyDisabled_.indexOf(c))
            for (var d = this.targetWorkspace_.isCapacityAvailable(LearnBlock.utils.getBlockTypeCounts(c)); c;) c = c.getNextBlock()
};
//Reflows blocks and their mats
LearnBlock.Flyout.prototype.reflow = function () {
    this.reflowWrapper_ && this.workspace_.removeChangeListener(this.reflowWrapper_);
    this.reflowInternal_();
    this.reflowWrapper_ && this.workspace_.addChangeListener(this.reflowWrapper_)
};
//True if the flyout may be scrolled with a scrollbar
LearnBlock.Flyout.prototype.isScrollable = function () {
    return this.scrollbar_ ? this.scrollbar_.isVisible() : !1
};
//Copies a block from the flyout to the workspace and positions it correctly
LearnBlock.Flyout.prototype.placeNewBlock_ = function (a) {
    var b = this.targetWorkspace_;
    if (!a.getSvgRoot()) throw Error("oldBlock is not rendered.");
    var c = LearnBlock.Xml.blockToDom(a, !0);
    b.setResizesEnabled(!1);
    c = LearnBlock.Xml.domToBlock(c, b);
    if (!c.getSvgRoot()) throw Error("block is not rendered.");
    var d = b.getOriginOffsetInPixels(),
        e = this.workspace_.getOriginOffsetInPixels();
    a = a.getRelativeToSurfaceXY();
    a.scale(this.workspace_.scale);
    a = LearnBlock.utils.Coordinate.sum(e, a);
    d = LearnBlock.utils.Coordinate.difference(a, d);
    d.scale(1 / b.scale);
    c.moveBy(d.x, d.y);
    return c
};

//Class for a button in the flyout
LearnBlock.FlyoutButton = function (a, b, c, d) {
    this.workspace_ = a;
    this.targetWorkspace_ = b;
    this.text_ = c.getAttribute("text");
    this.position_ = new LearnBlock.utils.Coordinate(0, 0);
    this.isLabel_ = d;
    this.callbackKey_ = c.getAttribute("callbackKey") || c.getAttribute("callbackkey");
    this.cssClass_ = c.getAttribute("web-class") || null
};
LearnBlock.FlyoutButton.MARGIN = 5;
LearnBlock.FlyoutButton.prototype.width = 0;
LearnBlock.FlyoutButton.prototype.height = 0;
LearnBlock.FlyoutButton.prototype.onMouseUpWrapper_ = null;
//Creates the button elements
LearnBlock.FlyoutButton.prototype.createDom = function () {
    var a = this.isLabel_ ? "blocklyFlyoutLabel" : "blocklyFlyoutButton";
    this.cssClass_ && (a += " " + this.cssClass_);
    this.svgGroup_ = LearnBlock.utils.dom.createSvgElement("g", {
        "class": a
    }, this.workspace_.getCanvas());
    if (!this.isLabel_) var b = LearnBlock.utils.dom.createSvgElement("rect", {
        "class": "blocklyFlyoutButtonShadow",
        rx: 4,
        ry: 4,
        x: 1,
        y: 1
    }, this.svgGroup_);
    a = LearnBlock.utils.dom.createSvgElement("rect", {
        "class": this.isLabel_ ? "blocklyFlyoutLabelBackground" : "blocklyFlyoutButtonBackground",
        rx: 4,
        ry: 4
    }, this.svgGroup_);
    var c = LearnBlock.utils.dom.createSvgElement("text", {
        "class": this.isLabel_ ? "blocklyFlyoutLabelText" : "blocklyText",
        x: 0,
        y: 0,
        "text-anchor": "middle"
    }, this.svgGroup_);
    c.textContent = LearnBlock.utils.replaceMessageReferences(this.text_);
    this.isLabel_ && (this.svgText_ = c, this.workspace_.getThemeManager().subscribe(this.svgText_, "flyoutText", "fill"));
    this.width = LearnBlock.utils.dom.getTextWidth(c);
    this.height = 20;
    this.isLabel_ || (this.width += 2 * LearnBlock.FlyoutButton.MARGIN, b.setAttribute("width",
        this.width), b.setAttribute("height", this.height));
    a.setAttribute("width", this.width);
    a.setAttribute("height", this.height);
    c.setAttribute("x", this.width / 2);
    c.setAttribute("y", this.height - LearnBlock.FlyoutButton.MARGIN);
    this.updateTransform_();
    this.onMouseUpWrapper_ = LearnBlock.bindEventWithChecks_(this.svgGroup_, "mouseup", this, this.onMouseUp_);
    return this.svgGroup_
};
//Correctly positions the flyout button and make it visible
LearnBlock.FlyoutButton.prototype.show = function () {
    this.updateTransform_();
    this.svgGroup_.setAttribute("display", "block")
};
//Updates SVG attributes to match internal state
LearnBlock.FlyoutButton.prototype.updateTransform_ = function () {
    this.svgGroup_.setAttribute("transform", "translate(" + this.position_.x + "," + this.position_.y + ")")
};
//Moves the button to the given x, y coordinates
LearnBlock.FlyoutButton.prototype.moveTo = function (a, b) {
    this.position_.x = a;
    this.position_.y = b;
    this.updateTransform_()
};
//Location of the button
LearnBlock.FlyoutButton.prototype.getPosition = function () {
    return this.position_
};
//Gets the button's target workspace
LearnBlock.FlyoutButton.prototype.getTargetWorkspace = function () {
    return this.targetWorkspace_
};
//Dispose of the button
LearnBlock.FlyoutButton.prototype.dispose = function () {
    this.onMouseUpWrapper_ && LearnBlock.unbindEvent_(this.onMouseUpWrapper_);
    this.svgGroup_ && LearnBlock.utils.dom.removeNode(this.svgGroup_);
    this.svgText_ && this.workspace_.getThemeManager().unsubscribe(this.svgText_)
};
//Does something when the button is clicked
LearnBlock.FlyoutButton.prototype.onMouseUp_ = function (a) {
    (a = this.targetWorkspace_.getGesture(a)) && a.cancel();
    this.isLabel_ && this.callbackKey_ ? console.warn("Labels should not have callbacks. Label text: " + this.text_) : this.isLabel_ || this.callbackKey_ && this.targetWorkspace_.getButtonCallback(this.callbackKey_) ? this.isLabel_ || this.targetWorkspace_.getButtonCallback(this.callbackKey_)(this) : console.warn("Buttons should have callbacks. Button text: " + this.text_)
};

//Class for a flyout
LearnBlock.VerticalFlyout = function (a) {
    a.getMetrics = this.getMetrics_.bind(this);
    a.setMetrics = this.setMetrics_.bind(this);
    LearnBlock.VerticalFlyout.superClass_.constructor.call(this, a);
    this.horizontalLayout_ = !1
};
LearnBlock.utils.object.inherits(LearnBlock.VerticalFlyout, LearnBlock.Flyout);
//Return an object with all the metrics required to size scrollbars for the flyout
LearnBlock.VerticalFlyout.prototype.getMetrics_ = function () {
    if (!this.isVisible()) return null;
    try {
        var a = this.workspace_.getCanvas().getBBox()
    } catch (e) {
        a = {
            height: 0,
            y: 0,
            width: 0,
            x: 0
        }
    }
    var b = this.SCROLLBAR_PADDING,
        c = this.height_ - 2 * this.SCROLLBAR_PADDING,
        d = this.width_;
    this.RTL || (d -= this.SCROLLBAR_PADDING);
    return {
        viewHeight: c,
        viewWidth: d,
        contentHeight: a.height * this.workspace_.scale + 2 * this.MARGIN,
        contentWidth: a.width * this.workspace_.scale + 2 * this.MARGIN,
        viewTop: -this.workspace_.scrollY + a.y,
        viewLeft: -this.workspace_.scrollX,
        contentTop: a.y,
        contentLeft: a.x,
        absoluteTop: b,
        absoluteLeft: 0
    }
};
//Sets the translation of the flyout to match the scrollbars
LearnBlock.VerticalFlyout.prototype.setMetrics_ = function (a) {
    var b = this.getMetrics_();
    b && ("number" == typeof a.y && (this.workspace_.scrollY = -b.contentHeight * a.y), this.workspace_.translate(this.workspace_.scrollX + b.absoluteLeft, this.workspace_.scrollY + b.absoluteTop))
};
//Moves the flyout to the edge of the workspace
LearnBlock.VerticalFlyout.prototype.position = function () {
    if (this.isVisible()) {
        var a = this.targetWorkspace_.getMetrics();
        a && (this.height_ = a.viewHeight, this.setBackgroundPath_(this.width_ - this.CORNER_RADIUS, a.viewHeight - 2 * this.CORNER_RADIUS), this.positionAt_(this.width_, this.height_, this.targetWorkspace_.toolboxPosition == this.toolboxPosition_ ? a.toolboxWidth ? this.toolboxPosition_ == LearnBlock.TOOLBOX_AT_LEFT ? a.toolboxWidth : a.viewWidth - this.width_ : this.toolboxPosition_ == LearnBlock.TOOLBOX_AT_LEFT ? 0 : a.viewWidth : this.toolboxPosition_ ==
            LearnBlock.TOOLBOX_AT_LEFT ? 0 : a.viewWidth + a.absoluteLeft - this.width_, 0))
    }
};
//Creates and sets the path for the visible boundaries of the flyout
LearnBlock.VerticalFlyout.prototype.setBackgroundPath_ = function (a, b) {
    var c = this.toolboxPosition_ == LearnBlock.TOOLBOX_AT_RIGHT,
        d = a + this.CORNER_RADIUS;
    d = ["M " + (c ? d : 0) + ",0"];
    d.push("h", c ? -a : a);
    d.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, c ? 0 : 1, c ? -this.CORNER_RADIUS : this.CORNER_RADIUS, this.CORNER_RADIUS);
    d.push("v", Math.max(0, b));
    d.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, c ? 0 : 1, c ? this.CORNER_RADIUS : -this.CORNER_RADIUS, this.CORNER_RADIUS);
    d.push("h", c ? a : -a);
    d.push("z");
    this.svgBackground_.setAttribute("d",
        d.join(" "))
};
//Scrolls the flyout to the top
LearnBlock.VerticalFlyout.prototype.scrollToStart = function () {
    this.scrollbar_.set(0)
};
//Scrolls the flyout
LearnBlock.VerticalFlyout.prototype.wheel_ = function (a) {
    var b = LearnBlock.utils.getScrollDeltaPixels(a);
    if (b.y) {
        var c = this.getMetrics_();
        b = c.viewTop - c.contentTop + b.y;
        b = Math.min(b, c.contentHeight - c.viewHeight);
        b = Math.max(b, 0);
        this.scrollbar_.set(b);
        LearnBlock.WidgetDiv.hide()
    }
    a.preventDefault();
    a.stopPropagation()
};
//Lays out the blocks in the flyout
LearnBlock.VerticalFlyout.prototype.layout_ = function (a, b) {
    this.workspace_.scale = this.targetWorkspace_.scale;
    for (var c = this.MARGIN, d = this.RTL ? c : c + this.tabWidth_, e = 0, f; f = a[e]; e++)
        if ("block" == f.type) {
            f = f.block;
            for (var g = f.getDescendants(!1), h = 0, k; k = g[h]; h++) k.isInFlyout = !0;
            f.render();
            g = f.getSvgRoot();
            h = f.getHeightWidth();
            k = f.outputConnection ? d - this.tabWidth_ : d;
            f.moveBy(k, c);
            k = this.createRect_(f, this.RTL ? k - h.width : k, c, h, e);
            this.addBlockListeners_(g, f, k);
            c += h.height + b[e]
        } else "button" == f.type && (this.initFlyoutButton_(f.button,
            d, c), c += f.button.height + b[e])
};
//Used to determine if a new block should be created or if the flyout should scroll
LearnBlock.VerticalFlyout.prototype.isDragTowardWorkspace = function (a) {
    a = Math.atan2(a.y, a.x) / Math.PI * 180;
    var b = this.dragAngleRange_;
    return a < b && a > -b || a < -180 + b || a > 180 - b ? !0 : !1
};
//Returns the deletion rectangle for this flyout in viewport coordinates
LearnBlock.VerticalFlyout.prototype.getClientRect = function () {
    if (!this.svgGroup_) return null;
    var a = this.svgGroup_.getBoundingClientRect(),
        b = a.left;
    if (this.toolboxPosition_ == LearnBlock.TOOLBOX_AT_LEFT) return new LearnBlock.utils.Rect(-1E9, 1E9, -1E9, b + a.width);
    LearnBlock.utils.userAgent.GECKO && this.targetWorkspace_ && this.targetWorkspace_.isMutator && (a = this.targetWorkspace_.svgGroup_.getBoundingClientRect().x, 10 > Math.abs(a - b) && (b += this.leftEdge_ * this.targetWorkspace_.options.parentWorkspace.scale));
    return new LearnBlock.utils.Rect(-1E9,
        1E9, b, 1E9)
};
//Computes width of flyout
LearnBlock.VerticalFlyout.prototype.reflowInternal_ = function () {
    this.workspace_.scale = this.targetWorkspace_.scale;
    for (var a = 0, b = this.workspace_.getTopBlocks(!1), c = 0, d; d = b[c]; c++) {
        var e = d.getHeightWidth().width;
        d.outputConnection && (e -= this.tabWidth_);
        a = Math.max(a, e)
    }
    for (c = 0; d = this.buttons_[c]; c++) a = Math.max(a, d.width);
    a += 1.5 * this.MARGIN + this.tabWidth_;
    a *= this.workspace_.scale;
    a += LearnBlock.Scrollbar.scrollbarThickness;
    if (this.width_ != a) {
        for (c = 0; d = b[c]; c++) {
            if (this.RTL) {
                e = d.getRelativeToSurfaceXY().x;
                var f =
                    a / this.workspace_.scale - this.MARGIN;
                d.outputConnection || (f -= this.tabWidth_);
                d.moveBy(f - e, 0)
            }
            d.flyoutRect_ && this.moveRectToBlock_(d.flyoutRect_, d)
        }
        if (this.RTL)
            for (c = 0; d = this.buttons_[c]; c++) b = d.getPosition().y, d.moveTo(a / this.workspace_.scale - d.width - this.MARGIN - this.tabWidth_, b);
        this.width_ = a;
        this.position()
    }
};

//Class for a cursor
LearnBlock.CursorSvg = function (a, b) {
    this.workspace_ = a;
    this.isMarker_ = b;
    this.parent_ = null;
    this.constants_ = a.getRenderer().getConstants()
};
LearnBlock.CursorSvg.CURSOR_HEIGHT = 5;
LearnBlock.CursorSvg.CURSOR_WIDTH = 100;
LearnBlock.CursorSvg.NOTCH_START_LENGTH = 24;
LearnBlock.CursorSvg.VERTICAL_PADDING = 5;
LearnBlock.CursorSvg.STACK_PADDING = 10;
LearnBlock.CursorSvg.BLOCK_PADDING = 2;
LearnBlock.CursorSvg.HEIGHT_MULTIPLIER = .75;
LearnBlock.CursorSvg.CURSOR_COLOR = "#cc0a0a";
LearnBlock.CursorSvg.MARKER_COLOR = "#4286f4";
LearnBlock.CursorSvg.CURSOR_CLASS = "blocklyCursor";
LearnBlock.CursorSvg.MARKER_CLASS = "blocklyMarker";
LearnBlock.CursorSvg.prototype.currentCursorSvg = null;
//Returns the root node of the SVG or null if none exists
LearnBlock.CursorSvg.prototype.getSvgRoot = function () {
    return this.svgGroup_
};
//Creates the DOM element for the cursor
LearnBlock.CursorSvg.prototype.createDom = function () {
    this.svgGroup_ = LearnBlock.utils.dom.createSvgElement("g", {
        "class": this.isMarker_ ? LearnBlock.CursorSvg.MARKER_CLASS : LearnBlock.CursorSvg.CURSOR_CLASS
    }, null);
    this.createCursorSvg_();
    return this.svgGroup_
};
//Attaches the SVG root of the cursor to the SVG group of the parent
LearnBlock.CursorSvg.prototype.setParent_ = function (a) {
    this.isMarker_ ? (this.parent_ && this.parent_.setMarkerSvg(null), a.setMarkerSvg(this.getSvgRoot())) : (this.parent_ && this.parent_.setCursorSvg(null), a.setCursorSvg(this.getSvgRoot()));
    this.parent_ = a
};
//Shows the cursor as a combination of the previous connection and block, the output connection and block, or just the block
LearnBlock.CursorSvg.prototype.showWithBlockPrevOutput_ = function (a) {
    if (a) {
        var b = a.width,
            c = a.height,
            d = c * LearnBlock.CursorSvg.HEIGHT_MULTIPLIER,
            e = LearnBlock.CursorSvg.BLOCK_PADDING;
        a.previousConnection ? this.positionPrevious_(b, e, d) : a.outputConnection ? this.positionOutput_(b, c) : this.positionBlock_(b, e, d);
        this.setParent_(a);
        this.showCurrent_()
    }
};
//Shows the visual representation of a workspace coordinate
LearnBlock.CursorSvg.prototype.showWithCoordinates_ = function (a) {
    var b = a.getWsCoordinate();
    a = b.x;
    b = b.y;
    this.workspace_.RTL && (a -= LearnBlock.CursorSvg.CURSOR_WIDTH);
    this.positionLine_(a, b, LearnBlock.CursorSvg.CURSOR_WIDTH);
    this.setParent_(this.workspace_);
    this.showCurrent_()
};
//Shows the visual representation of a field
LearnBlock.CursorSvg.prototype.showWithField_ = function (a) {
    a = a.getLocation();
    var b = a.getSize().width,
        c = a.getSize().height;
    this.positionRect_(0, 0, b, c);
    this.setParent_(a);
    this.showCurrent_()
};
//Shows the visual representation of an input
LearnBlock.CursorSvg.prototype.showWithInput_ = function (a) {
    a = a.getLocation();
    var b = a.getSourceBlock();
    this.positionInput_(a);
    this.setParent_(b);
    this.showCurrent_()
};
//Shows the visual representation of a next connection
LearnBlock.CursorSvg.prototype.showWithNext_ = function (a) {
    var b = a.getLocation();
    a = b.getSourceBlock();
    var c = 0;
    b = b.getOffsetInBlock().y;
    var d = a.getHeightWidth().width;
    this.workspace_.RTL && (c = -d);
    this.positionLine_(c, b, d);
    this.setParent_(a);
    this.showCurrent_()
};
//Shows the visual representation of a stack
LearnBlock.CursorSvg.prototype.showWithStack_ = function (a) {
    a = a.getLocation();
    var b = a.getHeightWidth(),
        c = b.width + LearnBlock.CursorSvg.STACK_PADDING;
    b = b.height + LearnBlock.CursorSvg.STACK_PADDING;
    var d = -1 * LearnBlock.CursorSvg.STACK_PADDING / 2,
        e = -1 * LearnBlock.CursorSvg.STACK_PADDING / 2,
        f = d;
    this.workspace_.RTL && (f = -(c + d));
    this.positionRect_(f, e, c, b);
    this.setParent_(a);
    this.showCurrent_()
};
//Shows the current cursor
LearnBlock.CursorSvg.prototype.showCurrent_ = function () {
    this.hide();
    this.currentCursorSvg.style.display = ""
};
//Positions the cursor for a block
LearnBlock.CursorSvg.prototype.positionBlock_ = function (a, b, c) {
    a = LearnBlock.utils.svgPaths.moveBy(-1 * b, c) + LearnBlock.utils.svgPaths.lineOnAxis("V", -1 * b) + LearnBlock.utils.svgPaths.lineOnAxis("H", a + 2 * b) + LearnBlock.utils.svgPaths.lineOnAxis("V", c);
    this.cursorBlock_.setAttribute("d", a);
    this.workspace_.RTL && this.flipRtl_(this.cursorBlock_);
    this.currentCursorSvg = this.cursorBlock_
};
//Positions the cursor for an input connection
LearnBlock.CursorSvg.prototype.positionInput_ = function (a) {
    var b = a.getOffsetInBlock().x;
    a = a.getOffsetInBlock().y;
    var c = LearnBlock.utils.svgPaths.moveTo(0, 0) + this.constants_.PUZZLE_TAB.pathDown;
    this.cursorInput_.setAttribute("d", c);
    this.cursorInput_.setAttribute("transform", "translate(" + b + "," + a + ")" + (this.workspace_.RTL ? " scale(-1 1)" : ""));
    this.currentCursorSvg = this.cursorInput_
};
//Moves and shows the cursor at the specified coordinate in workspace units
LearnBlock.CursorSvg.prototype.positionLine_ = function (a, b, c) {
    this.cursorSvgLine_.setAttribute("x", a);
    this.cursorSvgLine_.setAttribute("y", b);
    this.cursorSvgLine_.setAttribute("width", c);
    this.currentCursorSvg = this.cursorSvgLine_
};
//Positions the cursor for an output connection
LearnBlock.CursorSvg.prototype.positionOutput_ = function (a, b) {
    var c = LearnBlock.utils.svgPaths.moveBy(a, 0) + LearnBlock.utils.svgPaths.lineOnAxis("h", -1 * (a - this.constants_.PUZZLE_TAB.width)) + LearnBlock.utils.svgPaths.lineOnAxis("v", this.constants_.TAB_OFFSET_FROM_TOP) + this.constants_.PUZZLE_TAB.pathDown + LearnBlock.utils.svgPaths.lineOnAxis("V", b) + LearnBlock.utils.svgPaths.lineOnAxis("H", a);
    this.cursorBlock_.setAttribute("d", c);
    this.workspace_.RTL && this.flipRtl_(this.cursorBlock_);
    this.currentCursorSvg = this.cursorBlock_
};
//Positions the cursor for a previous connection
LearnBlock.CursorSvg.prototype.positionPrevious_ = function (a, b, c) {
    a = LearnBlock.utils.svgPaths.moveBy(-1 * b, c) + LearnBlock.utils.svgPaths.lineOnAxis("V", -1 * b) + LearnBlock.utils.svgPaths.lineOnAxis("H", this.constants_.NOTCH_OFFSET_LEFT) + this.constants_.NOTCH.pathLeft + LearnBlock.utils.svgPaths.lineOnAxis("H", a + 2 * b) + LearnBlock.utils.svgPaths.lineOnAxis("V", c);
    this.cursorBlock_.setAttribute("d", a);
    this.workspace_.RTL && this.flipRtl_(this.cursorBlock_);
    this.currentCursorSvg = this.cursorBlock_
};
//Moves and shows the cursor at the specified coordinate in workspace units
LearnBlock.CursorSvg.prototype.positionRect_ = function (a, b, c, d) {
    this.cursorSvgRect_.setAttribute("x", a);
    this.cursorSvgRect_.setAttribute("y", b);
    this.cursorSvgRect_.setAttribute("width", c);
    this.cursorSvgRect_.setAttribute("height", d);
    this.currentCursorSvg = this.cursorSvgRect_
};
//Flips the SVG paths in RTL
LearnBlock.CursorSvg.prototype.flipRtl_ = function (a) {
    a.setAttribute("transform", "scale(-1 1)")
};
//Hides the cursor
LearnBlock.CursorSvg.prototype.hide = function () {
    this.cursorSvgLine_.style.display = "none";
    this.cursorSvgRect_.style.display = "none";
    this.cursorInput_.style.display = "none";
    this.cursorBlock_.style.display = "none"
};
//Updates the cursor
LearnBlock.CursorSvg.prototype.draw = function (a) {
    a ? a.getType() === LearnBlock.ASTNode.types.BLOCK ? (a = a.getLocation(), this.showWithBlockPrevOutput_(a)) : a.getType() === LearnBlock.ASTNode.types.OUTPUT ? (a = a.getLocation().getSourceBlock(), this.showWithBlockPrevOutput_(a)) : a.getLocation().type === LearnBlock.INPUT_VALUE ? this.showWithInput_(a) : a.getLocation().type === LearnBlock.NEXT_STATEMENT ? this.showWithNext_(a) : a.getType() === LearnBlock.ASTNode.types.PREVIOUS ? (a = a.getLocation().getSourceBlock(), this.showWithBlockPrevOutput_(a)) :
        a.getType() === LearnBlock.ASTNode.types.FIELD ? this.showWithField_(a) : a.getType() === LearnBlock.ASTNode.types.WORKSPACE ? this.showWithCoordinates_(a) : a.getType() === LearnBlock.ASTNode.types.STACK && this.showWithStack_(a) : this.hide()
};
//Creates the cursor SVG
LearnBlock.CursorSvg.prototype.createCursorSvg_ = function () {
    var a = this.isMarker_ ? LearnBlock.CursorSvg.MARKER_COLOR : LearnBlock.CursorSvg.CURSOR_COLOR;
    this.cursorSvg_ = LearnBlock.utils.dom.createSvgElement("g", {
        width: LearnBlock.CursorSvg.CURSOR_WIDTH,
        height: LearnBlock.CursorSvg.CURSOR_HEIGHT
    }, this.svgGroup_);
    this.cursorSvgLine_ = LearnBlock.utils.dom.createSvgElement("rect", {
        x: "0",
        y: "0",
        fill: a,
        width: LearnBlock.CursorSvg.CURSOR_WIDTH,
        height: LearnBlock.CursorSvg.CURSOR_HEIGHT,
        style: "display: none;"
    }, this.cursorSvg_);
    this.cursorSvgRect_ =
        LearnBlock.utils.dom.createSvgElement("rect", {
            "class": "blocklyVerticalCursor",
            x: "0",
            y: "0",
            rx: "10",
            ry: "10",
            style: "display: none;",
            stroke: a
        }, this.cursorSvg_);
    this.cursorInput_ = LearnBlock.utils.dom.createSvgElement("path", {
        width: LearnBlock.CursorSvg.CURSOR_WIDTH,
        height: LearnBlock.CursorSvg.CURSOR_HEIGHT,
        transform: "",
        style: "display: none;",
        fill: a
    }, this.cursorSvg_);
    this.cursorBlock_ = LearnBlock.utils.dom.createSvgElement("path", {
        width: LearnBlock.CursorSvg.CURSOR_WIDTH,
        height: LearnBlock.CursorSvg.CURSOR_HEIGHT,
        transform: "",
        style: "display: none;",
        fill: "none",
        stroke: a,
        "stroke-width": "4"
    }, this.cursorSvg_);
    this.isMarker_ || (LearnBlock.utils.dom.createSvgElement("animate", {
            attributeType: "XML",
            attributeName: "fill",
            dur: "1s",
            values: LearnBlock.CursorSvg.CURSOR_COLOR + ";transparent;transparent;",
            repeatCount: "indefinite"
        }, this.cursorSvgLine_), LearnBlock.utils.dom.createSvgElement("animate", {
            attributeType: "XML",
            attributeName: "fill",
            dur: "1s",
            values: LearnBlock.CursorSvg.CURSOR_COLOR + ";transparent;transparent;",
            repeatCount: "indefinite"
        }, this.cursorInput_),
        LearnBlock.utils.dom.createSvgElement("animate", {
            attributeType: "XML",
            attributeName: "stroke",
            dur: "1s",
            values: LearnBlock.CursorSvg.CURSOR_COLOR + ";transparent;transparent;",
            repeatCount: "indefinite"
        }, this.cursorBlock_));
    return this.cursorSvg_
};
//Dispose of the cursor
LearnBlock.CursorSvg.prototype.dispose = function () {
    this.svgGroup_ && LearnBlock.utils.dom.removeNode(this.svgGroup_)
};

//Utils svgPaths
LearnBlock.utils.svgPaths = {};
//Creates a string representing the given x, y pair
LearnBlock.utils.svgPaths.point = function (a, b) {
    return " " + a + "," + b + " "
};
//Draws a curbic or quadratic curve
LearnBlock.utils.svgPaths.curve = function (a, b) {
    return " " + a + b.join("")
};
//Moves the cursor to the given position without drawing a line
LearnBlock.utils.svgPaths.moveTo = function (a, b) {
    return " M " + a + "," + b + " "
};
//Moves the cursor to the given position without drawing a line
LearnBlock.utils.svgPaths.moveBy = function (a, b) {
    return " m " + a + "," + b + " "
};
//Draws a line from the current point to the end point
LearnBlock.utils.svgPaths.lineTo = function (a, b) {
    return " l " + a + "," + b + " "
};
//Draws multiple lines connecting all of the given points in order
LearnBlock.utils.svgPaths.line = function (a) {
    return " l" + a.join("")
};
//Draws a horizontal or vertical line
LearnBlock.utils.svgPaths.lineOnAxis = function (a, b) {
    return " " + a + " " + b + " "
};
//Draws an elliptical arc curve
LearnBlock.utils.svgPaths.arc = function (a, b, c, d) {
    return a + " " + c + " " + c + " " + b + d
};

//An object that provides constants for rendering blocks
LearnBlock.blockRendering.ConstantProvider = function () {
    this.NO_PADDING = 0;
    this.SMALL_PADDING = 3;
    this.MEDIUM_PADDING = 5;
    this.MEDIUM_LARGE_PADDING = 8;
    this.LARGE_PADDING = 10;
    this.TALL_INPUT_FIELD_OFFSET_Y = this.MEDIUM_PADDING;
    this.TAB_HEIGHT = 15;
    this.TAB_OFFSET_FROM_TOP = 5;
    this.TAB_VERTICAL_OVERLAP = 2.5;
    this.TAB_WIDTH = 8;
    this.NOTCH_WIDTH = 15;
    this.NOTCH_HEIGHT = 4;
    this.MIN_BLOCK_WIDTH = 12;
    this.EMPTY_BLOCK_SPACER_HEIGHT = 16;
    this.DUMMY_INPUT_MIN_HEIGHT = this.TAB_HEIGHT;
    this.CORNER_RADIUS = 8;
    this.NOTCH_OFFSET_LEFT = 15;
    this.STATEMENT_BOTTOM_SPACER =
        0;
    this.STATEMENT_INPUT_PADDING_LEFT = 20;
    this.BETWEEN_STATEMENT_PADDING_Y = 4;
    this.MAX_BOTTOM_WIDTH = 66.5;
    this.START_HAT_HEIGHT = 15;
    this.START_HAT_WIDTH = 100;
    this.SPACER_DEFAULT_HEIGHT = 15;
    this.MIN_BLOCK_HEIGHT = 24;
    this.EMPTY_INLINE_INPUT_PADDING = 14.5;
    this.EMPTY_INLINE_INPUT_HEIGHT = this.TAB_HEIGHT + 11;
    this.EXTERNAL_VALUE_INPUT_PADDING = 2;
    this.EMPTY_STATEMENT_INPUT_HEIGHT = this.MIN_BLOCK_HEIGHT;
    this.START_POINT = LearnBlock.utils.svgPaths.moveBy(0, 0);
    this.JAGGED_TEETH_HEIGHT = 12;
    this.JAGGED_TEETH_WIDTH = 6
};
//Initializes shape objects based on the constants set in the constructor
LearnBlock.blockRendering.ConstantProvider.prototype.init = function () {
    this.NOTCH = this.makeNotch();
    this.START_HAT = this.makeStartHat();
    this.PUZZLE_TAB = this.makePuzzleTab();
    this.INSIDE_CORNERS = this.makeInsideCorners();
    this.OUTSIDE_CORNERS = this.makeOutsideCorners()
};
//An object containing sizing and path information about start hats
LearnBlock.blockRendering.ConstantProvider.prototype.makeStartHat = function () {
    var a = this.START_HAT_HEIGHT,
        b = this.START_HAT_WIDTH,
        c = LearnBlock.utils.svgPaths.curve("c", [LearnBlock.utils.svgPaths.point(30, -a), LearnBlock.utils.svgPaths.point(70, -a), LearnBlock.utils.svgPaths.point(b, 0)]);
    return {
        height: a,
        width: b,
        path: c
    }
};
//An object containing sizing and path information about puzzle tabs
LearnBlock.blockRendering.ConstantProvider.prototype.makePuzzleTab = function () {
    function a(a) {
        a = a ? -1 : 1;
        var d = -a,
            e = c / 2,
            f = e + 2.5,
            l = e + .5,
            m = LearnBlock.utils.svgPaths.point(-b, a * e);
        e = LearnBlock.utils.svgPaths.point(b, a * e);
        return LearnBlock.utils.svgPaths.curve("c", [LearnBlock.utils.svgPaths.point(0, a * f), LearnBlock.utils.svgPaths.point(-b, d * l), m]) + LearnBlock.utils.svgPaths.curve("s", [LearnBlock.utils.svgPaths.point(b, 2.5 * d), e])
    }
    var b = this.TAB_WIDTH,
        c = this.TAB_HEIGHT,
        d = a(!0),
        e = a(!1);
    return {
        width: b,
        height: c,
        pathDown: e,
        pathUp: d
    }
};
//An object containing sizing and path information about notches
LearnBlock.blockRendering.ConstantProvider.prototype.makeNotch = function () {
    function a(a) {
        return LearnBlock.utils.svgPaths.line([LearnBlock.utils.svgPaths.point(a * d, c), LearnBlock.utils.svgPaths.point(3 * a, 0), LearnBlock.utils.svgPaths.point(a * d, -c)])
    }
    var b = this.NOTCH_WIDTH,
        c = this.NOTCH_HEIGHT,
        d = (b - 3) / 2,
        e = a(1),
        f = a(-1);
    return {
        width: b,
        height: c,
        pathLeft: e,
        pathRight: f
    }
};
//An object containing sizing and path information about inside corners
LearnBlock.blockRendering.ConstantProvider.prototype.makeInsideCorners = function () {
    var a = this.CORNER_RADIUS,
        b = LearnBlock.utils.svgPaths.arc("a", "0 0,0", a, LearnBlock.utils.svgPaths.point(-a, a)),
        c = LearnBlock.utils.svgPaths.arc("a", "0 0,0", a, LearnBlock.utils.svgPaths.point(a, a));
    return {
        width: a,
        height: a,
        pathTop: b,
        pathBottom: c
    }
};
//An object containing sizing and path information about outside corners
LearnBlock.blockRendering.ConstantProvider.prototype.makeOutsideCorners = function () {
    var a = this.CORNER_RADIUS,
        b = LearnBlock.utils.svgPaths.moveBy(0, a) + LearnBlock.utils.svgPaths.arc("a", "0 0,1", a, LearnBlock.utils.svgPaths.point(a, -a));
    a = LearnBlock.utils.svgPaths.arc("a", "0 0,1", a, LearnBlock.utils.svgPaths.point(-a, -a));
    return {
        topLeft: b,
        bottomLeft: a
    }
};
//Gets an object with connection shape and sizing information based on the type of the connection
LearnBlock.blockRendering.ConstantProvider.prototype.shapeFor = function (a) {
    switch (a.type) {
        case LearnBlock.INPUT_VALUE:
        case LearnBlock.OUTPUT_VALUE:
            return this.PUZZLE_TAB;
        case LearnBlock.PREVIOUS_STATEMENT:
        case LearnBlock.NEXT_STATEMENT:
            return this.NOTCH;
        default:
            throw Error("Unknown connection type");
    }
};
//Types of rendering elements
LearnBlock.blockRendering.Types = {
    NONE: 0,
    FIELD: 1,
    HAT: 2,
    ICON: 4,
    SPACER: 8,
    BETWEEN_ROW_SPACER: 16,
    IN_ROW_SPACER: 32,
    EXTERNAL_VALUE_INPUT: 64,
    INPUT: 128,
    INLINE_INPUT: 256,
    STATEMENT_INPUT: 512,
    CONNECTION: 1024,
    PREVIOUS_CONNECTION: 2048,
    NEXT_CONNECTION: 4096,
    OUTPUT_CONNECTION: 8192,
    CORNER: 16384,
    LEFT_SQUARE_CORNER: 32768,
    LEFT_ROUND_CORNER: 65536,
    RIGHT_SQUARE_CORNER: 131072,
    RIGHT_ROUND_CORNER: 262144,
    JAGGED_EDGE: 524288,
    ROW: 1048576,
    TOP_ROW: 2097152,
    BOTTOM_ROW: 4194304,
    INPUT_ROW: 8388608
};
//A Left Corner Union Type
LearnBlock.blockRendering.Types.LEFT_CORNER = LearnBlock.blockRendering.Types.LEFT_SQUARE_CORNER | LearnBlock.blockRendering.Types.LEFT_ROUND_CORNER;
//A Right Corner Union Type
LearnBlock.blockRendering.Types.RIGHT_CORNER = LearnBlock.blockRendering.Types.RIGHT_SQUARE_CORNER | LearnBlock.blockRendering.Types.RIGHT_ROUND_CORNER;
//Next flag value to use for custom rendering element types
LearnBlock.blockRendering.Types.nextTypeValue_ = 16777216;
//Gets the enum flag value of an existing type or register a new type
LearnBlock.blockRendering.Types.getType = function (a) {
    LearnBlock.blockRendering.Types.hasOwnProperty(a) || (LearnBlock.blockRendering.Types[a] = LearnBlock.blockRendering.Types.nextTypeValue_, LearnBlock.blockRendering.Types.nextTypeValue_ <<= 1);
    return LearnBlock.blockRendering.Types[a]
};
//Whether a measurable stores information about a field
LearnBlock.blockRendering.Types.isField = function (a) {
    return a.type & LearnBlock.blockRendering.Types.FIELD
};
//Whether a measurable stores information about a hat
LearnBlock.blockRendering.Types.isHat = function (a) {
    return a.type & LearnBlock.blockRendering.Types.HAT
};
//Whether a measurable stores information about an icon
LearnBlock.blockRendering.Types.isIcon = function (a) {
    return a.type & LearnBlock.blockRendering.Types.ICON
};
//Whether a measurable stores information about a spacer
LearnBlock.blockRendering.Types.isSpacer = function (a) {
    return a.type & LearnBlock.blockRendering.Types.SPACER
};
//Whether a measurable stores information about an in-row spacer
LearnBlock.blockRendering.Types.isInRowSpacer = function (a) {
    return a.type & LearnBlock.blockRendering.Types.IN_ROW_SPACER
};
//Whether a measurable stores information about an input
LearnBlock.blockRendering.Types.isInput = function (a) {
    return a.type & LearnBlock.blockRendering.Types.INPUT
};
//Whether a measurable stores information about an external input
LearnBlock.blockRendering.Types.isExternalInput = function (a) {
    return a.type & LearnBlock.blockRendering.Types.EXTERNAL_VALUE_INPUT
};
//Whether a measurable stores information about an inline input
LearnBlock.blockRendering.Types.isInlineInput = function (a) {
    return a.type & LearnBlock.blockRendering.Types.INLINE_INPUT
};
//Whether a measurable stores information about a statement input
LearnBlock.blockRendering.Types.isStatementInput = function (a) {
    return a.type & LearnBlock.blockRendering.Types.STATEMENT_INPUT
};
//Whether a measurable stores information about a previous connection
LearnBlock.blockRendering.Types.isPreviousConnection = function (a) {
    return a.type & LearnBlock.blockRendering.Types.PREVIOUS_CONNECTION
};
//Whether a measurable stores information about a next connection
LearnBlock.blockRendering.Types.isNextConnection = function (a) {
    return a.type & LearnBlock.blockRendering.Types.NEXT_CONNECTION
};
//Whether a measurable stores information about a previous or next connection
LearnBlock.blockRendering.Types.isPreviousOrNextConnection = function (a) {
    return a.type & (LearnBlock.blockRendering.Types.PREVIOUS_CONNECTION | LearnBlock.blockRendering.Types.NEXT_CONNECTION)
};
//Whether a measurable stores information about a left round corner
LearnBlock.blockRendering.Types.isLeftRoundedCorner = function (a) {
    return a.type & LearnBlock.blockRendering.Types.LEFT_ROUND_CORNER
};
//Whether a measurable stores information about a right round corner
LearnBlock.blockRendering.Types.isRightRoundedCorner = function (a) {
    return a.type & LearnBlock.blockRendering.Types.RIGHT_ROUND_CORNER
};
//Whether a measurable stores information about a left square corner
LearnBlock.blockRendering.Types.isLeftSquareCorner = function (a) {
    return a.type & LearnBlock.blockRendering.Types.LEFT_SQUARE_CORNER
};
//Whether a measurable stores information about a right square corner
LearnBlock.blockRendering.Types.isRightSquareCorner = function (a) {
    return a.type & LearnBlock.blockRendering.Types.RIGHT_SQUARE_CORNER
};
//Whether a measurable stores information about a corner
LearnBlock.blockRendering.Types.isCorner = function (a) {
    return a.type & LearnBlock.blockRendering.Types.CORNER
};
//Whether a measurable stores information about a jagged edge
LearnBlock.blockRendering.Types.isJaggedEdge = function (a) {
    return a.type & LearnBlock.blockRendering.Types.JAGGED_EDGE
};
//Whether a measurable stores information about a row
LearnBlock.blockRendering.Types.isRow = function (a) {
    return a.type & LearnBlock.blockRendering.Types.ROW
};
//Whether a measurable stores information about a between-row spacer
LearnBlock.blockRendering.Types.isBetweenRowSpacer = function (a) {
    return a.type & LearnBlock.blockRendering.Types.BETWEEN_ROW_SPACER
};
//Whether a measurable stores information about a top row
LearnBlock.blockRendering.Types.isTopRow = function (a) {
    return a.type & LearnBlock.blockRendering.Types.TOP_ROW
};
//Whether a measurable stores information about a bottom row
LearnBlock.blockRendering.Types.isBottomRow = function (a) {
    return a.type & LearnBlock.blockRendering.Types.BOTTOM_ROW
};
//Whether a measurable stores information about a top or bottom row
LearnBlock.blockRendering.Types.isTopOrBottomRow = function (a) {
    return a.type & (LearnBlock.blockRendering.Types.TOP_ROW | LearnBlock.blockRendering.Types.BOTTOM_ROW)
};
//Whether a measurable stores information about an input row
LearnBlock.blockRendering.Types.isInputRow = function (a) {
    return a.type & LearnBlock.blockRendering.Types.INPUT_ROW
};
//The base class to represent a part of a block that takes up space during rendering
LearnBlock.blockRendering.Measurable = function (a) {
    this.height = this.width = 0;
    this.type = LearnBlock.blockRendering.Types.NONE;
    this.centerline = this.xPos = 0;
    this.constants_ = a;
    this.notchOffset = this.constants_.NOTCH_OFFSET_LEFT
};
//The base class to represent a connection and the space that it takes up on the block
LearnBlock.blockRendering.Connection = function (a, b) {
    LearnBlock.blockRendering.Connection.superClass_.constructor.call(this, a);
    this.connectionModel = b;
    this.shape = this.constants_.shapeFor(b);
    this.type |= LearnBlock.blockRendering.Types.CONNECTION
};
LearnBlock.utils.object.inherits(LearnBlock.blockRendering.Connection, LearnBlock.blockRendering.Measurable);
//An object containing information about the space an output connection takes up during rendering
LearnBlock.blockRendering.OutputConnection = function (a, b) {
    LearnBlock.blockRendering.OutputConnection.superClass_.constructor.call(this, a, b);
    this.type |= LearnBlock.blockRendering.Types.OUTPUT_CONNECTION;
    this.height = this.shape.height;
    this.width = this.shape.width;
    this.connectionOffsetY = this.constants_.TAB_OFFSET_FROM_TOP;
    this.startX = this.width
};
LearnBlock.utils.object.inherits(LearnBlock.blockRendering.OutputConnection, LearnBlock.blockRendering.Connection);
//Whether or not the connection shape is dynamic
LearnBlock.blockRendering.OutputConnection.prototype.isDynamic = function () {
    return this.shape.isDynamic
};
//An object containing information about the space a previous connection takes up during rendering
LearnBlock.blockRendering.PreviousConnection = function (a, b) {
    LearnBlock.blockRendering.PreviousConnection.superClass_.constructor.call(this, a, b);
    this.type |= LearnBlock.blockRendering.Types.PREVIOUS_CONNECTION;
    this.height = this.shape.height;
    this.width = this.shape.width
};
LearnBlock.utils.object.inherits(LearnBlock.blockRendering.PreviousConnection, LearnBlock.blockRendering.Connection);
//An object containing information about the space a next connection takes up during rendering
LearnBlock.blockRendering.NextConnection = function (a, b) {
    LearnBlock.blockRendering.NextConnection.superClass_.constructor.call(this, a, b);
    this.type |= LearnBlock.blockRendering.Types.NEXT_CONNECTION;
    this.height = this.shape.height;
    this.width = this.shape.width
};
LearnBlock.utils.object.inherits(LearnBlock.blockRendering.NextConnection, LearnBlock.blockRendering.Connection);
//The base class to represent an input that takes up space on a block during rendering
LearnBlock.blockRendering.InputConnection = function (a, b) {
    LearnBlock.blockRendering.InputConnection.superClass_.constructor.call(this, a, b.connection);
    this.type |= LearnBlock.blockRendering.Types.INPUT;
    this.input = b;
    this.align = b.align;
    if (this.connectedBlock = b.connection && b.connection.targetBlock() ? b.connection.targetBlock() : null) {
        var c = this.connectedBlock.getHeightWidth();
        this.connectedBlockWidth = c.width;
        this.connectedBlockHeight = c.height
    } else this.connectedBlockHeight = this.connectedBlockWidth = 0;
    this.connection =
        b.connection;
    this.connectionOffsetY = this.connectionOffsetX = 0
};
LearnBlock.utils.object.inherits(LearnBlock.blockRendering.InputConnection, LearnBlock.blockRendering.Connection);
//An object containing information about the space an inline input takes up during rendering
LearnBlock.blockRendering.InlineInput = function (a, b) {
    LearnBlock.blockRendering.InlineInput.superClass_.constructor.call(this, a, b);
    this.type |= LearnBlock.blockRendering.Types.INLINE_INPUT;
    this.connectedBlock ? (this.width = this.connectedBlockWidth, this.height = this.connectedBlockHeight) : (this.height = this.constants_.EMPTY_INLINE_INPUT_HEIGHT, this.width = this.shape.width + this.constants_.EMPTY_INLINE_INPUT_PADDING);
    this.connectionOffsetY = this.constants_.TAB_OFFSET_FROM_TOP;
    this.connectionHeight = this.shape.height;
    this.connectionWidth =
        this.shape.width
};
LearnBlock.utils.object.inherits(LearnBlock.blockRendering.InlineInput, LearnBlock.blockRendering.InputConnection);
//An object containing information about the space a statement input takes up during rendering
LearnBlock.blockRendering.StatementInput = function (a, b) {
    LearnBlock.blockRendering.StatementInput.superClass_.constructor.call(this, a, b);
    this.type |= LearnBlock.blockRendering.Types.STATEMENT_INPUT;
    this.height = this.connectedBlock ? this.connectedBlockHeight + this.constants_.STATEMENT_BOTTOM_SPACER : this.constants_.EMPTY_STATEMENT_INPUT_HEIGHT;
    this.width = this.constants_.NOTCH_OFFSET_LEFT + this.shape.width
};
LearnBlock.utils.object.inherits(LearnBlock.blockRendering.StatementInput, LearnBlock.blockRendering.InputConnection);
//An object containing information about the space an external value input takes up during rendering
LearnBlock.blockRendering.ExternalValueInput = function (a, b) {
    LearnBlock.blockRendering.ExternalValueInput.superClass_.constructor.call(this, a, b);
    this.type |= LearnBlock.blockRendering.Types.EXTERNAL_VALUE_INPUT;
    this.height = this.connectedBlock ? this.connectedBlockHeight - 2 * this.constants_.TAB_OFFSET_FROM_TOP : this.shape.height;
    this.width = this.shape.width + this.constants_.EXTERNAL_VALUE_INPUT_PADDING;
    this.connectionOffsetY = this.constants_.TAB_OFFSET_FROM_TOP;
    this.connectionHeight = this.shape.height;
    this.connectionWidth =
        this.shape.width
};
LearnBlock.utils.object.inherits(LearnBlock.blockRendering.ExternalValueInput, LearnBlock.blockRendering.InputConnection);
//An object containing information about the jagged edge of a collapsed block takes up during rendering
LearnBlock.blockRendering.JaggedEdge = function (a) {
    LearnBlock.blockRendering.JaggedEdge.superClass_.constructor.call(this, a);
    this.type |= LearnBlock.blockRendering.Types.JAGGED_EDGE;
    this.height = this.constants_.JAGGED_TEETH.height;
    this.width = this.constants_.JAGGED_TEETH.width
};
LearnBlock.utils.object.inherits(LearnBlock.blockRendering.JaggedEdge, LearnBlock.blockRendering.Measurable);
//An object containing information about the space a field takes up during rendering
LearnBlock.blockRendering.Field = function (a, b, c) {
    LearnBlock.blockRendering.Field.superClass_.constructor.call(this, a);
    this.field = b;
    this.isEditable = b.isCurrentlyEditable();
    this.flipRtl = b.getFlipRtl();
    this.type |= LearnBlock.blockRendering.Types.FIELD;
    a = this.field.getSize();
    this.height = a.height;
    this.width = a.width;
    this.parentInput = c
};
LearnBlock.utils.object.inherits(LearnBlock.blockRendering.Field, LearnBlock.blockRendering.Measurable);
//An object containing information about the space a hat takes up during rendering
LearnBlock.blockRendering.Hat = function (a) {
    LearnBlock.blockRendering.Hat.superClass_.constructor.call(this, a);
    this.type |= LearnBlock.blockRendering.Types.HAT;
    this.height = this.constants_.START_HAT.height;
    this.width = this.constants_.START_HAT.width;
    this.ascenderHeight = this.height
};
LearnBlock.utils.object.inherits(LearnBlock.blockRendering.Hat, LearnBlock.blockRendering.Measurable);
//An object containing information about the space a square corner takes up during rendering
LearnBlock.blockRendering.SquareCorner = function (a, b) {
    LearnBlock.blockRendering.SquareCorner.superClass_.constructor.call(this, a);
    this.type = (b && "left" != b ? LearnBlock.blockRendering.Types.RIGHT_SQUARE_CORNER : LearnBlock.blockRendering.Types.LEFT_SQUARE_CORNER) | LearnBlock.blockRendering.Types.CORNER;
    this.width = this.height = this.constants_.NO_PADDING
};
LearnBlock.utils.object.inherits(LearnBlock.blockRendering.SquareCorner, LearnBlock.blockRendering.Measurable);
//An object containing information about the space a rounded corner takes up during rendering
LearnBlock.blockRendering.RoundCorner = function (a, b) {
    LearnBlock.blockRendering.RoundCorner.superClass_.constructor.call(this, a);
    this.type = (b && "left" != b ? LearnBlock.blockRendering.Types.RIGHT_ROUND_CORNER : LearnBlock.blockRendering.Types.LEFT_ROUND_CORNER) | LearnBlock.blockRendering.Types.CORNER;
    this.width = this.constants_.CORNER_RADIUS;
    this.height = this.constants_.CORNER_RADIUS / 2
};
LearnBlock.utils.object.inherits(LearnBlock.blockRendering.RoundCorner, LearnBlock.blockRendering.Measurable);
//An object containing information about a spacer between two elements on a row
LearnBlock.blockRendering.InRowSpacer = function (a, b) {
    LearnBlock.blockRendering.InRowSpacer.superClass_.constructor.call(this, a);
    this.type = this.type | LearnBlock.blockRendering.Types.SPACER | LearnBlock.blockRendering.Types.IN_ROW_SPACER;
    this.width = b;
    this.height = this.constants_.SPACER_DEFAULT_HEIGHT
};
LearnBlock.utils.object.inherits(LearnBlock.blockRendering.InRowSpacer, LearnBlock.blockRendering.Measurable);

//An object representing a single row on a rendered block and all of its subcomponents
LearnBlock.blockRendering.Row = function (a) {
    this.type = LearnBlock.blockRendering.Types.ROW;
    this.elements = [];
    this.xPos = this.yPos = this.widthWithConnectedBlocks = this.minWidth = this.minHeight = this.width = this.height = 0;
    this.hasJaggedEdge = this.hasDummyInput = this.hasInlineInput = this.hasStatement = this.hasExternalInput = !1;
    this.constants_ = a;
    this.notchOffset = this.constants_.NOTCH_OFFSET_LEFT
};
//Inspects all subcomponents and populate all size properties on the row
LearnBlock.blockRendering.Row.prototype.measure = function () {
    throw Error("Unexpected attempt to measure a base Row.");
};
//Get the last input on this row, if it has one
LearnBlock.blockRendering.Row.prototype.getLastInput = function () {
    for (var a = this.elements.length - 1, b; b = this.elements[a]; a--)
        if (LearnBlock.blockRendering.Types.isInput(b)) return b;
    return null
};
//Determines whether this row should start with an element spacer
LearnBlock.blockRendering.Row.prototype.startsWithElemSpacer = function () {
    return !0
};
//Determines whether this row should end with an element spacer
LearnBlock.blockRendering.Row.prototype.endsWithElemSpacer = function () {
    return !0
};
//Convenience method to get the first spacer element on this row
LearnBlock.blockRendering.Row.prototype.getFirstSpacer = function () {
    for (var a = 0, b; b = this.elements[a]; a++)
        if (LearnBlock.blockRendering.Types.isSpacer(b)) return b;
    return null
};
//Convenience method to get the last spacer element on this row
LearnBlock.blockRendering.Row.prototype.getLastSpacer = function () {
    for (var a = this.elements.length - 1, b; b = this.elements[a]; a--)
        if (LearnBlock.blockRendering.Types.isSpacer(b)) return b;
    return null
};
//An object containing information about what elements are in the top row of a block as well as sizing information for the top row
LearnBlock.blockRendering.TopRow = function (a) {
    LearnBlock.blockRendering.TopRow.superClass_.constructor.call(this, a);
    this.type |= LearnBlock.blockRendering.Types.TOP_ROW;
    this.ascenderHeight = this.capline = 0;
    this.hasPreviousConnection = !1;
    this.connection = null
};
LearnBlock.utils.object.inherits(LearnBlock.blockRendering.TopRow, LearnBlock.blockRendering.Row);
//Returns whether or not the top row has a left square corner
LearnBlock.blockRendering.TopRow.prototype.hasLeftSquareCorner = function (a) {
    var b = (a.hat ? "cap" === a.hat : LearnBlock.BlockSvg.START_HAT) && !a.outputConnection && !a.previousConnection,
        c = a.getPreviousBlock();
    return !!a.outputConnection || b || (c ? c.getNextBlock() == a : !1)
};
//Override methods
LearnBlock.blockRendering.TopRow.prototype.measure = function () {
    for (var a = 0, b = 0, c = 0, d = 0, e; e = this.elements[d]; d++) b += e.width, LearnBlock.blockRendering.Types.isSpacer(e) || (LearnBlock.blockRendering.Types.isHat(e) ? c = Math.max(c, e.ascenderHeight) : a = Math.max(a, e.height));
    this.width = Math.max(this.minWidth, b);
    this.height = Math.max(this.minHeight, a) + c;
    this.capline = this.ascenderHeight = c;
    this.widthWithConnectedBlocks = this.width
};
LearnBlock.blockRendering.TopRow.prototype.startsWithElemSpacer = function () {
    return !1
};
//An object containing information about what elements are in the bottom row of a block as well as spacing information for the top row
LearnBlock.blockRendering.BottomRow = function (a) {
    LearnBlock.blockRendering.BottomRow.superClass_.constructor.call(this, a);
    this.type |= LearnBlock.blockRendering.Types.BOTTOM_ROW;
    this.hasNextConnection = !1;
    this.connection = null;
    this.baseline = this.descenderHeight = 0
};
LearnBlock.utils.object.inherits(LearnBlock.blockRendering.BottomRow, LearnBlock.blockRendering.Row);
//Returns whether or not the bottom row has a left square corner
LearnBlock.blockRendering.BottomRow.prototype.hasLeftSquareCorner = function (a) {
    return !!a.outputConnection || !!a.getNextBlock()
};
//Override methods
LearnBlock.blockRendering.BottomRow.prototype.measure = function () {
    for (var a = 0, b = 0, c = 0, d = 0, e; e = this.elements[d]; d++) b += e.width, LearnBlock.blockRendering.Types.isSpacer(e) || (LearnBlock.blockRendering.Types.isNextConnection(e) ? c = Math.max(c, e.height) : a = Math.max(a, e.height));
    this.width = Math.max(this.minWidth, b);
    this.height = Math.max(this.minHeight, a) + c;
    this.descenderHeight = c;
    this.widthWithConnectedBlocks = this.width
};
LearnBlock.blockRendering.BottomRow.prototype.startsWithElemSpacer = function () {
    return !1
};
//An object containing information about a spacer between two rows
LearnBlock.blockRendering.SpacerRow = function (a, b, c) {
    LearnBlock.blockRendering.SpacerRow.superClass_.constructor.call(this, a);
    this.type = this.type | LearnBlock.blockRendering.Types.SPACER | LearnBlock.blockRendering.Types.BETWEEN_ROW_SPACER;
    this.width = c;
    this.height = b;
    this.followsStatement = !1;
    this.widthWithConnectedBlocks = 0;
    this.elements = [new LearnBlock.blockRendering.InRowSpacer(this.constants_, c)]
};
LearnBlock.utils.object.inherits(LearnBlock.blockRendering.SpacerRow, LearnBlock.blockRendering.Row);
//Override method
LearnBlock.blockRendering.SpacerRow.prototype.measure = function () {};
//An object containing information about a row that holds one or more inputs
LearnBlock.blockRendering.InputRow = function (a) {
    LearnBlock.blockRendering.InputRow.superClass_.constructor.call(this, a);
    this.type |= LearnBlock.blockRendering.Types.INPUT_ROW;
    this.connectedBlockWidths = 0
};
LearnBlock.utils.object.inherits(LearnBlock.blockRendering.InputRow, LearnBlock.blockRendering.Row);
//Inspects all subcomponents and populate all size properties on the row
LearnBlock.blockRendering.InputRow.prototype.measure = function () {
    this.width = this.minWidth;
    this.height = this.minHeight;
    for (var a = 0, b = 0, c; c = this.elements[b]; b++) this.width += c.width, LearnBlock.blockRendering.Types.isInput(c) && (LearnBlock.blockRendering.Types.isStatementInput(c) ? a += c.connectedBlockWidth : LearnBlock.blockRendering.Types.isExternalInput(c) && 0 != c.connectedBlockWidth && (a += c.connectedBlockWidth - c.connectionWidth)), LearnBlock.blockRendering.Types.isSpacer(c) || (this.height = Math.max(this.height, c.height));
    this.connectedBlockWidths =
        a;
    this.widthWithConnectedBlocks = this.width + a
};
//Override method
LearnBlock.blockRendering.InputRow.prototype.endsWithElemSpacer = function () {
    return !this.hasExternalInput && !this.hasStatement
};
//An object containing all sizing information needed to draw this block
LearnBlock.blockRendering.RenderInfo = function (a, b) {
    this.block_ = b;
    this.renderer_ = a;
    this.constants_ = this.renderer_.getConstants();
    this.outputConnection = b.outputConnection ? new LearnBlock.blockRendering.OutputConnection(this.constants_, b.outputConnection) : null;
    this.isInline = b.getInputsInline() && !b.isCollapsed();
    this.isInsertionMarker = b.isInsertionMarker();
    this.RTL = b.RTL;
    this.statementEdge = this.width = this.widthWithChildren = this.height = 0;
    this.rows = [];
    this.hiddenIcons = [];
    this.topRow =
        new LearnBlock.blockRendering.TopRow(this.constants_);
    this.bottomRow = new LearnBlock.blockRendering.BottomRow(this.constants_);
    this.startY = this.startX = 0
};
//Gets the block renderer in use
LearnBlock.blockRendering.RenderInfo.prototype.getRenderer = function () {
    return this.renderer_
};
//Populates and returns an object containing all sizing information needed to draw this block
LearnBlock.blockRendering.RenderInfo.prototype.measure = function () {
    this.createRows_();
    this.addElemSpacing_();
    this.computeBounds_();
    this.alignRowElements_();
    this.addRowSpacing_();
    this.finalize_()
};
//Creates rows of Measurable objects representing all renderable parts of the block
LearnBlock.blockRendering.RenderInfo.prototype.createRows_ = function () {
    this.populateTopRow_();
    this.rows.push(this.topRow);
    var a = new LearnBlock.blockRendering.InputRow(this.constants_);
    var b, c, d, e;
    for (c = 0; b = this.block_.inputList[c]; c++)
        if (b.isVisible()) {
            this.shouldStartNewRow_(b, d) && (this.rows.push(a), a = new LearnBlock.blockRendering.InputRow(this.constants_));
            for (d = 0; e = b.fieldRow[d]; d++) a.elements.push(new LearnBlock.blockRendering.Field(this.constants_, e, b));
            this.addInput_(b, a);
            d = b
        } this.isCollapsed && (a.hasJaggedEdge = !0, a.elements.push(new LearnBlock.blockRendering.JaggedEdge(this.constants_)));
    (a.elements.length || a.hasDummyInput) && this.rows.push(a);
    this.populateBottomRow_();
    this.rows.push(this.bottomRow)
};
//Creates all non-spacer elements that belong on the top row
LearnBlock.blockRendering.RenderInfo.prototype.populateTopRow_ = function () {
    var a = !!this.block_.previousConnection,
        b = (this.block_.hat ? "cap" === this.block_.hat : LearnBlock.BlockSvg.START_HAT) && !this.outputConnection && !a;
    this.topRow.hasLeftSquareCorner(this.block_) ? this.topRow.elements.push(new LearnBlock.blockRendering.SquareCorner(this.constants_)) : this.topRow.elements.push(new LearnBlock.blockRendering.RoundCorner(this.constants_));
    b ? (a = new LearnBlock.blockRendering.Hat(this.constants_), this.topRow.elements.push(a),
        this.topRow.capline = a.ascenderHeight) : a && (this.topRow.hasPreviousConnection = !0, this.topRow.connection = new LearnBlock.blockRendering.PreviousConnection(this.constants_, this.block_.previousConnection), this.topRow.elements.push(this.topRow.connection));
    this.block_.inputList.length && this.block_.inputList[0].type == LearnBlock.NEXT_STATEMENT && !this.block_.isCollapsed() ? this.topRow.minHeight = this.constants_.LARGE_PADDING : this.topRow.minHeight = this.constants_.MEDIUM_PADDING
};
//Creates all non-spacer elements that belong on the bottom row
LearnBlock.blockRendering.RenderInfo.prototype.populateBottomRow_ = function () {
    this.bottomRow.hasNextConnection = !!this.block_.nextConnection;
    this.bottomRow.minHeight = this.block_.inputList.length && this.block_.inputList[this.block_.inputList.length - 1].type == LearnBlock.NEXT_STATEMENT ? this.constants_.LARGE_PADDING : this.constants_.MEDIUM_PADDING - 1;
    this.bottomRow.hasLeftSquareCorner(this.block_) ? this.bottomRow.elements.push(new LearnBlock.blockRendering.SquareCorner(this.constants_)) : this.bottomRow.elements.push(new LearnBlock.blockRendering.RoundCorner(this.constants_));
    this.bottomRow.hasNextConnection && (this.bottomRow.connection = new LearnBlock.blockRendering.NextConnection(this.constants_, this.block_.nextConnection), this.bottomRow.elements.push(this.bottomRow.connection))
};
//Adds an input element to the active row, if needed, and records the type of the input on the row
LearnBlock.blockRendering.RenderInfo.prototype.addInput_ = function (a, b) {
    this.isInline && a.type == LearnBlock.INPUT_VALUE ? (b.elements.push(new LearnBlock.blockRendering.InlineInput(this.constants_, a)), b.hasInlineInput = !0) : a.type == LearnBlock.NEXT_STATEMENT ? (b.elements.push(new LearnBlock.blockRendering.StatementInput(this.constants_, a)), b.hasStatement = !0) : a.type == LearnBlock.INPUT_VALUE ? (b.elements.push(new LearnBlock.blockRendering.ExternalValueInput(this.constants_, a)), b.hasExternalInput = !0) : a.type == LearnBlock.DUMMY_INPUT && (b.minHeight =
        Math.max(b.minHeight, this.constants_.DUMMY_INPUT_MIN_HEIGHT), b.hasDummyInput = !0);
    b.align = a.align
};
//Decides whether to start a new row between the two inputs
LearnBlock.blockRendering.RenderInfo.prototype.shouldStartNewRow_ = function (a, b) {
    return b ? a.type == LearnBlock.NEXT_STATEMENT || b.type == LearnBlock.NEXT_STATEMENT ? !0 : a.type == LearnBlock.INPUT_VALUE || a.type == LearnBlock.DUMMY_INPUT ? !this.isInline : !1 : !1
};
//Adds horizontal spacing between and around elements within each row
LearnBlock.blockRendering.RenderInfo.prototype.addElemSpacing_ = function () {
    for (var a = 0, b; b = this.rows[a]; a++) {
        var c = b.elements;
        b.elements = [];
        b.startsWithElemSpacer() && b.elements.push(new LearnBlock.blockRendering.InRowSpacer(this.constants_, this.getInRowSpacing_(null, c[0])));
        for (var d = 0; d < c.length - 1; d++) {
            b.elements.push(c[d]);
            var e = this.getInRowSpacing_(c[d], c[d + 1]);
            b.elements.push(new LearnBlock.blockRendering.InRowSpacer(this.constants_, e))
        }
        b.elements.push(c[c.length - 1]);
        b.endsWithElemSpacer() && b.elements.push(new LearnBlock.blockRendering.InRowSpacer(this.constants_,
            this.getInRowSpacing_(c[c.length - 1], null)))
    }
};
//Calculates the width of a spacer element in a row based on the previous and next elements in that row
LearnBlock.blockRendering.RenderInfo.prototype.getInRowSpacing_ = function (a, b) {
    if (a && LearnBlock.blockRendering.Types.isInput(a) && !b) {
        if (LearnBlock.blockRendering.Types.isExternalInput(a)) return this.constants_.NO_PADDING;
        if (LearnBlock.blockRendering.Types.isInlineInput(a)) return this.constants_.LARGE_PADDING;
        if (LearnBlock.blockRendering.Types.isStatementInput(a)) return this.constants_.NO_PADDING
    }
    return a && LearnBlock.blockRendering.Types.isLeftSquareCorner(a) && b && (LearnBlock.blockRendering.Types.isPreviousConnection(b) || LearnBlock.blockRendering.Types.isNextConnection(b)) ?
        b.notchOffset : a && LearnBlock.blockRendering.Types.isLeftRoundedCorner(a) && b && (LearnBlock.blockRendering.Types.isPreviousConnection(b) || LearnBlock.blockRendering.Types.isNextConnection(b)) ? b.notchOffset - this.constants_.CORNER_RADIUS : this.constants_.MEDIUM_PADDING
};
//Figures out where the right edge of the block and right edge of statement inputs should be placed
LearnBlock.blockRendering.RenderInfo.prototype.computeBounds_ = function () {
    for (var a = 0, b = 0, c = 0, d = 0, e; e = this.rows[d]; d++) {
        e.measure();
        b = Math.max(b, e.width);
        if (e.hasStatement) {
            var f = e.getLastInput();
            a = Math.max(a, e.width - f.width)
        }
        c = Math.max(c, e.widthWithConnectedBlocks)
    }
    this.statementEdge = a;
    this.width = b;
    for (d = 0; e = this.rows[d]; d++) e.hasStatement && (e.statementEdge = this.statementEdge);
    this.widthWithChildren = Math.max(b, c);
    this.outputConnection && (this.startX = this.outputConnection.width, this.width += this.outputConnection.width,
        this.widthWithChildren += this.outputConnection.width)
};
//Extra spacing may be necessary to make sure that the right sides of all rows line up
LearnBlock.blockRendering.RenderInfo.prototype.alignRowElements_ = function () {
    for (var a = 0, b; b = this.rows[a]; a++)
        if (b.hasStatement) this.alignStatementRow_(b);
        else {
            var c = this.width - this.startX - b.width;
            c && this.addAlignmentPadding_(b, c)
        }
};
//Modifies the given row to add the given amount of padding around its fields
LearnBlock.blockRendering.RenderInfo.prototype.addAlignmentPadding_ = function (a, b) {
    var c = a.getLastSpacer();
    c && (c.width += b, a.width += b)
};
//Aligns the elements of a statement row based on computed bounds
LearnBlock.blockRendering.RenderInfo.prototype.alignStatementRow_ = function (a) {
    var b = a.getLastInput(),
        c = a.width - b.width,
        d = this.statementEdge;
    (c = d - c) && this.addAlignmentPadding_(a, c);
    c = a.width;
    d = this.width - this.startX - (this.constants_.INSIDE_CORNERS.rightWidth || 0);
    b.width += d - c;
    a.width += d - c;
    a.widthWithConnectedBlocks = Math.max(a.width, this.statementEdge + a.connectedBlockWidths)
};
//Adds spacers between rows and set their sizes
LearnBlock.blockRendering.RenderInfo.prototype.addRowSpacing_ = function () {
    var a = this.rows;
    this.rows = [];
    for (var b = 0; b < a.length; b++) this.rows.push(a[b]), b != a.length - 1 && this.rows.push(this.makeSpacerRow_(a[b], a[b + 1]))
};
//Creates a spacer row to go between prev and next, and sets its size
LearnBlock.blockRendering.RenderInfo.prototype.makeSpacerRow_ = function (a, b) {
    var c = this.getSpacerRowHeight_(a, b),
        d = this.getSpacerRowWidth_(a, b);
    c = new LearnBlock.blockRendering.SpacerRow(this.constants_, c, d);
    a.hasStatement && (c.followsStatement = !0);
    return c
};
//Calculates the width of a spacer row
LearnBlock.blockRendering.RenderInfo.prototype.getSpacerRowWidth_ = function (a, b) {
    return this.width - this.startX
};
//Calculates the height of a spacer row
LearnBlock.blockRendering.RenderInfo.prototype.getSpacerRowHeight_ = function (a, b) {
    return this.constants_.MEDIUM_PADDING
};
//Calculates the centerline of an element in a rendered row
LearnBlock.blockRendering.RenderInfo.prototype.getElemCenterline_ = function (a, b) {
    if (LearnBlock.blockRendering.Types.isSpacer(b)) return a.yPos + b.height / 2;
    if (LearnBlock.blockRendering.Types.isBottomRow(a)) {
        var c = a.yPos + a.height - a.descenderHeight;
        return LearnBlock.blockRendering.Types.isNextConnection(b) ? c + b.height / 2 : c - b.height / 2
    }
    return LearnBlock.blockRendering.Types.isTopRow(a) ? LearnBlock.blockRendering.Types.isHat(b) ? a.capline - b.height / 2 : a.capline + b.height / 2 : a.yPos + a.height / 2
};
//Records final position information on elements on the given row, for use in drawing
LearnBlock.blockRendering.RenderInfo.prototype.recordElemPositions_ = function (a) {
    for (var b = a.xPos, c = 0, d; d = a.elements[c]; c++) LearnBlock.blockRendering.Types.isSpacer(d) && (d.height = a.height), d.xPos = b, d.centerline = this.getElemCenterline_(a, d), b += d.width
};
//Makes any final changes to the rendering information object
LearnBlock.blockRendering.RenderInfo.prototype.finalize_ = function () {
    for (var a = 0, b = 0, c = 0, d; d = this.rows[c]; c++) d.yPos = b, d.xPos = this.startX, b += d.height, a = Math.max(a, d.widthWithConnectedBlocks), this.recordElemPositions_(d);
    this.widthWithChildren = a + this.startX;
    this.height = b;
    this.startY = this.topRow.capline;
    this.bottomRow.baseline = b - this.bottomRow.descenderHeight
};
//An object that draws a block based on the given rendering information
LearnBlock.blockRendering.Drawer = function (a, b) {
    this.block_ = a;
    this.info_ = b;
    this.topLeft_ = a.getRelativeToSurfaceXY();
    this.inlinePath_ = this.outlinePath_ = "";
    this.constants_ = b.getRenderer().getConstants()
};
//Draws the block to the workspace
LearnBlock.blockRendering.Drawer.prototype.draw = function () {
    this.drawOutline_();
    this.drawInternals_();
    this.block_.pathObject.setPaths(this.outlinePath_ + "\n" + this.inlinePath_);
    this.info_.RTL && this.block_.pathObject.flipRTL();
    LearnBlock.blockRendering.useDebugger && this.block_.renderingDebugger.drawDebug(this.block_, this.info_);
    this.recordSizeOnBlock_()
};
//Saves sizing information back to the block
LearnBlock.blockRendering.Drawer.prototype.recordSizeOnBlock_ = function () {
    this.block_.height = this.info_.height;
    this.block_.width = this.info_.widthWithChildren
};
//Creates the outline of the block
LearnBlock.blockRendering.Drawer.prototype.drawOutline_ = function () {
    this.drawTop_();
    for (var a = 1; a < this.info_.rows.length - 1; a++) {
        var b = this.info_.rows[a];
        b.hasJaggedEdge ? this.drawJaggedEdge_(b) : b.hasStatement ? this.drawStatementInput_(b) : b.hasExternalInput ? this.drawValueInput_(b) : this.drawRightSideRow_(b)
    }
    this.drawBottom_();
    this.drawLeft_()
};
//Adds steps for the top corner of the block
LearnBlock.blockRendering.Drawer.prototype.drawTop_ = function () {
    var a = this.info_.topRow,
        b = a.elements;
    this.positionPreviousConnection_();
    this.outlinePath_ += LearnBlock.utils.svgPaths.moveBy(a.xPos, this.info_.startY);
    for (var c = 0, d; d = b[c]; c++) LearnBlock.blockRendering.Types.isLeftRoundedCorner(d) ? this.outlinePath_ += this.constants_.OUTSIDE_CORNERS.topLeft : LearnBlock.blockRendering.Types.isPreviousConnection(d) ? this.outlinePath_ += d.shape.pathLeft : LearnBlock.blockRendering.Types.isHat(d) ? this.outlinePath_ += this.constants_.START_HAT.path :
        LearnBlock.blockRendering.Types.isSpacer(d) && (this.outlinePath_ += LearnBlock.utils.svgPaths.lineOnAxis("h", d.width));
    this.outlinePath_ += LearnBlock.utils.svgPaths.lineOnAxis("v", a.height)
};
//Adds steps for an external value input
LearnBlock.blockRendering.Drawer.prototype.drawValueInput_ = function (a) {
    var b = a.getLastInput();
    this.positionExternalValueConnection_(a);
    var c = "function" == typeof b.shape.pathDown ? b.shape.pathDown(b.height) : b.shape.pathDown;
    this.outlinePath_ += LearnBlock.utils.svgPaths.lineOnAxis("H", b.xPos + b.width) + c + LearnBlock.utils.svgPaths.lineOnAxis("v", a.height - b.connectionHeight)
};
//Adds steps for a statement input
LearnBlock.blockRendering.Drawer.prototype.drawStatementInput_ = function (a) {
    var b = a.getLastInput(),
        c = b.xPos + b.notchOffset + b.shape.width;
    b = b.shape.pathRight + LearnBlock.utils.svgPaths.lineOnAxis("h", -(b.notchOffset - this.constants_.INSIDE_CORNERS.width)) + this.constants_.INSIDE_CORNERS.pathTop;
    var d = a.height - 2 * this.constants_.INSIDE_CORNERS.height;
    this.outlinePath_ += LearnBlock.utils.svgPaths.lineOnAxis("H", c) + b + LearnBlock.utils.svgPaths.lineOnAxis("v", d) + this.constants_.INSIDE_CORNERS.pathBottom + LearnBlock.utils.svgPaths.lineOnAxis("H",
        a.xPos + a.width);
    this.positionStatementInputConnection_(a)
};
//Adds steps for the right side of a row that does not have value or statement input connections
LearnBlock.blockRendering.Drawer.prototype.drawRightSideRow_ = function (a) {
    this.outlinePath_ += LearnBlock.utils.svgPaths.lineOnAxis("V", a.yPos + a.height)
};
//Adds steps for the bottom edge of a block
LearnBlock.blockRendering.Drawer.prototype.drawBottom_ = function () {
    var a = this.info_.bottomRow,
        b = a.elements;
    this.positionNextConnection_();
    this.outlinePath_ += LearnBlock.utils.svgPaths.lineOnAxis("V", a.baseline);
    for (var c = b.length - 1, d; d = b[c]; c--) LearnBlock.blockRendering.Types.isNextConnection(d) ? this.outlinePath_ += d.shape.pathRight : LearnBlock.blockRendering.Types.isLeftSquareCorner(d) ? this.outlinePath_ += LearnBlock.utils.svgPaths.lineOnAxis("H", a.xPos) : LearnBlock.blockRendering.Types.isLeftRoundedCorner(d) ? this.outlinePath_ +=
        this.constants_.OUTSIDE_CORNERS.bottomLeft : LearnBlock.blockRendering.Types.isSpacer(d) && (this.outlinePath_ += LearnBlock.utils.svgPaths.lineOnAxis("h", -1 * d.width))
};
//Adds steps for the left side of the block
LearnBlock.blockRendering.Drawer.prototype.drawLeft_ = function () {
    var a = this.info_.outputConnection;
    this.positionOutputConnection_();
    if (a) {
        var b = a.connectionOffsetY + a.height;
        a = "function" == typeof a.shape.pathUp ? a.shape.pathUp(a.height) : a.shape.pathUp;
        this.outlinePath_ += LearnBlock.utils.svgPaths.lineOnAxis("V", b) + a
    }
    this.outlinePath_ += "z"
};
//Draws the internals of the block: inline inputs, fields
LearnBlock.blockRendering.Drawer.prototype.drawInternals_ = function () {
    for (var a = 0, b; b = this.info_.rows[a]; a++)
        for (var c = 0, d; d = b.elements[c]; c++) LearnBlock.blockRendering.Types.isInlineInput(d) ? this.drawInlineInput_(d) : LearnBlock.blockRendering.Types.isField(d) && this.layoutField_(d)
};
//Pushes a field's new position to its SVG root
LearnBlock.blockRendering.Drawer.prototype.layoutField_ = function (a) {
    if (LearnBlock.blockRendering.Types.isField(a)) var b = a.field.getSvgRoot();
    else LearnBlock.blockRendering.Types.isIcon(a) && (b = a.icon.iconGroup_);
    var c = a.centerline - a.height / 2,
        d = a.xPos,
        e = "";
    this.info_.RTL && (d = -(d + a.width), a.flipRtl && (d += a.width, e = "scale(-1 1)"));
    b.setAttribute("transform", "translate(" + d + "," + c + ")" + e);
    this.info_.isInsertionMarker && b.setAttribute("display", "none")
};
//Adds steps for an inline input
LearnBlock.blockRendering.Drawer.prototype.drawInlineInput_ = function (a) {
    var b = a.width,
        c = a.height,
        d = a.connectionOffsetY,
        e = a.connectionHeight + d;
    this.inlinePath_ += LearnBlock.utils.svgPaths.moveTo(a.xPos + a.connectionWidth, a.centerline - c / 2) + LearnBlock.utils.svgPaths.lineOnAxis("v", d) + a.shape.pathDown + LearnBlock.utils.svgPaths.lineOnAxis("v", c - e) + LearnBlock.utils.svgPaths.lineOnAxis("h", b - a.connectionWidth) + LearnBlock.utils.svgPaths.lineOnAxis("v", -c) + "z";
    this.positionInlineInputConnection_(a)
};
//Positions the connection on an inline value input
LearnBlock.blockRendering.Drawer.prototype.positionInlineInputConnection_ = function (a) {
    var b = a.centerline - a.height / 2;
    if (a.connection) {
        var c = a.xPos + a.connectionWidth;
        this.info_.RTL && (c *= -1);
        a.connection.setOffsetInBlock(c, b + a.connectionOffsetY)
    }
};
//Positions the connection on a statement input
LearnBlock.blockRendering.Drawer.prototype.positionStatementInputConnection_ = function (a) {
    var b = a.getLastInput();
    if (b.connection) {
        var c = a.xPos + a.statementEdge + b.notchOffset;
        this.info_.RTL && (c *= -1);
        b.connection.setOffsetInBlock(c, a.yPos)
    }
};
//Positions the connection on an external value input
LearnBlock.blockRendering.Drawer.prototype.positionExternalValueConnection_ = function (a) {
    var b = a.getLastInput();
    if (b.connection) {
        var c = a.xPos + a.width;
        this.info_.RTL && (c *= -1);
        b.connection.setOffsetInBlock(c, a.yPos)
    }
};
//Positions the previous connection on a block
LearnBlock.blockRendering.Drawer.prototype.positionPreviousConnection_ = function () {
    var a = this.info_.topRow;
    if (a.connection) {
        var b = a.xPos + a.notchOffset;
        a.connection.connectionModel.setOffsetInBlock(this.info_.RTL ? -b : b, 0)
    }
};
//Positions the next connection on a block
LearnBlock.blockRendering.Drawer.prototype.positionNextConnection_ = function () {
    var a = this.info_.bottomRow;
    if (a.connection) {
        a = a.connection;
        var b = a.xPos;
        a.connectionModel.setOffsetInBlock(this.info_.RTL ? -b : b, a.centerline - a.height / 2)
    }
};
//Positions the output connection on a block
LearnBlock.blockRendering.Drawer.prototype.positionOutputConnection_ = function () {
    if (this.info_.outputConnection) {
        var a = this.info_.startX;
        this.block_.outputConnection.setOffsetInBlock(this.info_.RTL ? -a : a, this.info_.outputConnection.connectionOffsetY)
    }
};
//The base class for a block renderer
LearnBlock.blockRendering.Renderer = function () {
    this.constants_ = null
};
//Initializes the renderer
LearnBlock.blockRendering.Renderer.prototype.init = function () {
    this.constants_ = this.makeConstants_();
    this.constants_.init()
};
//Creates a new instance of the renderer's constant provider
LearnBlock.blockRendering.Renderer.prototype.makeConstants_ = function () {
    return new LearnBlock.blockRendering.ConstantProvider
};
//Creates a new instance of the renderer's render info object
LearnBlock.blockRendering.Renderer.prototype.makeRenderInfo_ = function (a) {
    return new LearnBlock.blockRendering.RenderInfo(this, a)
};
//Creates a new instance of the renderer's drawer
LearnBlock.blockRendering.Renderer.prototype.makeDrawer_ = function (a, b) {
    return new LearnBlock.blockRendering.Drawer(a, b)
};
//Creates a new instance of the renderer's debugger
LearnBlock.blockRendering.Renderer.prototype.makeDebugger_ = function () {
    if (!LearnBlock.blockRendering.Debug) throw Error("Missing require for LearnBlock.blockRendering.Debug");
    return new LearnBlock.blockRendering.Debug
};
//Creates a new instance of the renderer's cursor drawer
LearnBlock.blockRendering.Renderer.prototype.makeCursorDrawer = function (a, b) {
    return new LearnBlock.CursorSvg(a, b)
};
//Creates a new instance of a renderer path object
LearnBlock.blockRendering.Renderer.prototype.makePathObject = function (a) {
    return new LearnBlock.blockRendering.PathObject(a)
};
//Gets the current renderer's constant provider
LearnBlock.blockRendering.Renderer.prototype.getConstants = function () {
    return this.constants_
};
//Renders the block
LearnBlock.blockRendering.Renderer.prototype.render = function (a) {
    LearnBlock.blockRendering.useDebugger && !a.renderingDebugger && (a.renderingDebugger = this.makeDebugger_());
    var b = this.makeRenderInfo_(a);
    b.measure();
    this.makeDrawer_(a, b).draw()
};

//Class geras
LearnBlock.geras = {};
//An object that provides constants for rendering blocks in Geras mode
LearnBlock.geras.ConstantProvider = function () {
    LearnBlock.geras.ConstantProvider.superClass_.constructor.call(this);
    this.DARK_PATH_OFFSET = 1
};
LearnBlock.utils.object.inherits(LearnBlock.geras.ConstantProvider, LearnBlock.blockRendering.ConstantProvider);
//An object that adds highlights to a block based on the given rendering information
LearnBlock.geras.Highlighter = function (a) {
    this.info_ = a;
    this.inlineSteps_ = this.steps_ = "";
    this.RTL_ = this.info_.RTL;
    a = a.getRenderer();
    this.constants_ = a.getConstants();
    this.highlightConstants_ = a.getHighlightConstants();
    this.highlightOffset_ = this.highlightConstants_.OFFSET;
    this.outsideCornerPaths_ = this.highlightConstants_.OUTSIDE_CORNER;
    this.insideCornerPaths_ = this.highlightConstants_.INSIDE_CORNER;
    this.puzzleTabPaths_ = this.highlightConstants_.PUZZLE_TAB;
    this.notchPaths_ = this.highlightConstants_.NOTCH;
    this.startPaths_ =
        this.highlightConstants_.START_HAT;
    this.jaggedTeethPaths_ = this.highlightConstants_.JAGGED_TEETH
};
//Gets the steps for the highlight path
LearnBlock.geras.Highlighter.prototype.getPath = function () {
    return this.steps_ + "\n" + this.inlineSteps_
};
LearnBlock.geras.Highlighter.prototype.drawTopCorner = function (a) {
    this.steps_ += LearnBlock.utils.svgPaths.moveBy(a.xPos, this.info_.startY);
    for (var b = 0, c; c = a.elements[b]; b++) LearnBlock.blockRendering.Types.isLeftSquareCorner(c) ? this.steps_ += this.highlightConstants_.START_POINT : LearnBlock.blockRendering.Types.isLeftRoundedCorner(c) ? this.steps_ += this.outsideCornerPaths_.topLeft(this.RTL_) : LearnBlock.blockRendering.Types.isPreviousConnection(c) ? this.steps_ += this.notchPaths_.pathLeft : LearnBlock.blockRendering.Types.isHat(c) ?
        this.steps_ += this.startPaths_.path(this.RTL_) : LearnBlock.blockRendering.Types.isSpacer(c) && 0 != c.width && (this.steps_ += LearnBlock.utils.svgPaths.lineOnAxis("H", c.xPos + c.width - this.highlightOffset_));
    this.steps_ += LearnBlock.utils.svgPaths.lineOnAxis("H", a.xPos + a.width - this.highlightOffset_)
};
LearnBlock.geras.Highlighter.prototype.drawJaggedEdge_ = function (a) {
    this.info_.RTL && (this.steps_ += LearnBlock.utils.svgPaths.lineOnAxis("H", a.width - this.highlightOffset_), this.steps_ += this.jaggedTeethPaths_.pathLeft, this.steps_ += LearnBlock.utils.svgPaths.lineOnAxis("v", a.height - this.jaggedTeethPaths_.height - this.highlightOffset_))
};
LearnBlock.geras.Highlighter.prototype.drawValueInput = function (a) {
    var b = a.getLastInput();
    if (this.RTL_) {
        var c = a.height - b.connectionHeight;
        this.steps_ += LearnBlock.utils.svgPaths.moveTo(b.xPos + b.width - this.highlightOffset_, a.yPos) + this.puzzleTabPaths_.pathDown(this.RTL_) + LearnBlock.utils.svgPaths.lineOnAxis("v", c)
    } else this.steps_ += LearnBlock.utils.svgPaths.moveTo(b.xPos + b.width, a.yPos) + this.puzzleTabPaths_.pathDown(this.RTL_)
};
LearnBlock.geras.Highlighter.prototype.drawStatementInput = function (a) {
    var b = a.getLastInput();
    if (this.RTL_) {
        var c = a.height - 2 * this.insideCornerPaths_.height;
        this.steps_ += LearnBlock.utils.svgPaths.moveTo(b.xPos, a.yPos) + this.insideCornerPaths_.pathTop(this.RTL_) + LearnBlock.utils.svgPaths.lineOnAxis("v", c) + this.insideCornerPaths_.pathBottom(this.RTL_) + LearnBlock.utils.svgPaths.lineTo(a.width - b.xPos - this.insideCornerPaths_.width, 0)
    } else this.steps_ += LearnBlock.utils.svgPaths.moveTo(b.xPos, a.yPos + a.height) + this.insideCornerPaths_.pathBottom(this.RTL_) +
        LearnBlock.utils.svgPaths.lineTo(a.width - b.xPos - this.insideCornerPaths_.width, 0)
};
LearnBlock.geras.Highlighter.prototype.drawRightSideRow = function (a) {
    var b = a.xPos + a.width - this.highlightOffset_;
    a.followsStatement && (this.steps_ += LearnBlock.utils.svgPaths.lineOnAxis("H", b));
    this.RTL_ && (this.steps_ += LearnBlock.utils.svgPaths.lineOnAxis("H", b), a.height > this.highlightOffset_ && (this.steps_ += LearnBlock.utils.svgPaths.lineOnAxis("V", a.yPos + a.height - this.highlightOffset_)))
};
LearnBlock.geras.Highlighter.prototype.drawBottomRow = function (a) {
    if (this.RTL_) this.steps_ += LearnBlock.utils.svgPaths.lineOnAxis("V", a.baseline - this.highlightOffset_);
    else {
        var b = this.info_.bottomRow.elements[0];
        LearnBlock.blockRendering.Types.isLeftSquareCorner(b) ? this.steps_ += LearnBlock.utils.svgPaths.moveTo(a.xPos + this.highlightOffset_, a.baseline - this.highlightOffset_) : LearnBlock.blockRendering.Types.isLeftRoundedCorner(b) && (this.steps_ += LearnBlock.utils.svgPaths.moveTo(a.xPos, a.baseline), this.steps_ += this.outsideCornerPaths_.bottomLeft())
    }
};
LearnBlock.geras.Highlighter.prototype.drawLeft = function () {
    var a = this.info_.outputConnection;
    a && (a = a.connectionOffsetY + a.height, this.RTL_ ? this.steps_ += LearnBlock.utils.svgPaths.moveTo(this.info_.startX, a) : (this.steps_ += LearnBlock.utils.svgPaths.moveTo(this.info_.startX + this.highlightOffset_, this.info_.bottomRow.baseline - this.highlightOffset_), this.steps_ += LearnBlock.utils.svgPaths.lineOnAxis("V", a)), this.steps_ += this.puzzleTabPaths_.pathUp(this.RTL_));
    this.RTL_ || (a = this.info_.topRow, LearnBlock.blockRendering.Types.isLeftRoundedCorner(a.elements[0]) ?
        this.steps_ += LearnBlock.utils.svgPaths.lineOnAxis("V", this.outsideCornerPaths_.height) : this.steps_ += LearnBlock.utils.svgPaths.lineOnAxis("V", a.capline + this.highlightOffset_))
};
LearnBlock.geras.Highlighter.prototype.drawInlineInput = function (a) {
    var b = this.highlightOffset_,
        c = a.xPos + a.connectionWidth,
        d = a.centerline - a.height / 2,
        e = a.width - a.connectionWidth,
        f = d + b;
    this.RTL_ ? (d = a.connectionOffsetY - b, a = a.height - (a.connectionOffsetY + a.connectionHeight) + b, this.inlineSteps_ += LearnBlock.utils.svgPaths.moveTo(c - b, f) + LearnBlock.utils.svgPaths.lineOnAxis("v", d) + this.puzzleTabPaths_.pathDown(this.RTL_) + LearnBlock.utils.svgPaths.lineOnAxis("v", a) + LearnBlock.utils.svgPaths.lineOnAxis("h", e)) : this.inlineSteps_ +=
        LearnBlock.utils.svgPaths.moveTo(a.xPos + a.width + b, f) + LearnBlock.utils.svgPaths.lineOnAxis("v", a.height) + LearnBlock.utils.svgPaths.lineOnAxis("h", -e) + LearnBlock.utils.svgPaths.moveTo(c, d + a.connectionOffsetY) + this.puzzleTabPaths_.pathDown(this.RTL_)
};
//An object that handles creating and setting each of the SVG elements used by the renderer
LearnBlock.geras.PathObject = function (a) {
    this.svgRoot = a;
    this.svgPathDark = LearnBlock.utils.dom.createSvgElement("path", {
        "class": "blocklyPathDark",
        transform: "translate(1,1)"
    }, this.svgRoot);
    this.svgPath = LearnBlock.utils.dom.createSvgElement("path", {
        "class": "blocklyPath"
    }, this.svgRoot);
    this.svgPathLight = LearnBlock.utils.dom.createSvgElement("path", {
        "class": "blocklyPathLight"
    }, this.svgRoot)
};
//Sets each of the paths generated by the renderer onto the respective SVG element
LearnBlock.geras.PathObject.prototype.setPaths = function (a, b) {
    this.svgPath.setAttribute("d", a);
    this.svgPathDark.setAttribute("d", a);
    this.svgPathLight.setAttribute("d", b)
};
//Flips the SVG paths in RTL
LearnBlock.geras.PathObject.prototype.flipRTL = function () {
    this.svgPath.setAttribute("transform", "scale(-1 1)");
    this.svgPathLight.setAttribute("transform", "scale(-1 1)");
    this.svgPathDark.setAttribute("transform", "translate(1,1) scale(-1 1)")
};
//An object containing information about the space an inline input takes up during rendering
LearnBlock.geras.InlineInput = function (a, b) {
    LearnBlock.geras.InlineInput.superClass_.constructor.call(this, a, b);
    this.connectedBlock && (this.width += this.constants_.DARK_PATH_OFFSET, this.height += this.constants_.DARK_PATH_OFFSET)
};
LearnBlock.utils.object.inherits(LearnBlock.geras.InlineInput, LearnBlock.blockRendering.InlineInput);
//An object containing information about the space a statement input takes up during rendering
LearnBlock.geras.StatementInput = function (a, b) {
    LearnBlock.geras.StatementInput.superClass_.constructor.call(this, a, b);
    this.connectedBlock && (this.height += this.constants_.DARK_PATH_OFFSET)
};
LearnBlock.utils.object.inherits(LearnBlock.geras.StatementInput, LearnBlock.blockRendering.StatementInput);
//An object containing all sizing information needed to draw this block
LearnBlock.geras.RenderInfo = function (a, b) {
    LearnBlock.geras.RenderInfo.superClass_.constructor.call(this, a, b)
};
LearnBlock.utils.object.inherits(LearnBlock.geras.RenderInfo, LearnBlock.blockRendering.RenderInfo);
//Gets the block renderer in use
LearnBlock.geras.RenderInfo.prototype.getRenderer = function () {
    return this.renderer_
};
//Override methods
LearnBlock.geras.RenderInfo.prototype.addInput_ = function (a, b) {
    this.isInline && a.type == LearnBlock.INPUT_VALUE ? (b.elements.push(new LearnBlock.geras.InlineInput(this.constants_, a)), b.hasInlineInput = !0) : a.type == LearnBlock.NEXT_STATEMENT ? (b.elements.push(new LearnBlock.geras.StatementInput(this.constants_, a)), b.hasStatement = !0) : a.type == LearnBlock.INPUT_VALUE ? (b.elements.push(new LearnBlock.blockRendering.ExternalValueInput(this.constants_, a)), b.hasExternalInput = !0) : a.type == LearnBlock.DUMMY_INPUT && (b.minHeight = Math.max(b.minHeight,
        this.constants_.DUMMY_INPUT_MIN_HEIGHT), b.hasDummyInput = !0);
    b.align = a.align
};
LearnBlock.geras.RenderInfo.prototype.addElemSpacing_ = function () {
    for (var a = !1, b = 0, c; c = this.rows[b]; b++) c.hasExternalInput && (a = !0);
    for (b = 0; c = this.rows[b]; b++) {
        var d = c.elements;
        c.elements = [];
        c.startsWithElemSpacer() && c.elements.push(new LearnBlock.blockRendering.InRowSpacer(this.constants_, this.getInRowSpacing_(null, d[0])));
        for (var e = 0; e < d.length - 1; e++) {
            c.elements.push(d[e]);
            var f = this.getInRowSpacing_(d[e], d[e + 1]);
            c.elements.push(new LearnBlock.blockRendering.InRowSpacer(this.constants_, f))
        }
        c.elements.push(d[d.length -
            1]);
        c.endsWithElemSpacer() && (f = this.getInRowSpacing_(d[d.length - 1], null), a && c.hasDummyInput && (f += this.constants_.TAB_WIDTH), c.elements.push(new LearnBlock.blockRendering.InRowSpacer(this.constants_, f)))
    }
};
LearnBlock.geras.RenderInfo.prototype.getInRowSpacing_ = function (a, b) {
    if (!a) return b && LearnBlock.blockRendering.Types.isField(b) && b.isEditable ? this.constants_.MEDIUM_PADDING : b && LearnBlock.blockRendering.Types.isInlineInput(b) ? this.constants_.MEDIUM_LARGE_PADDING : b && LearnBlock.blockRendering.Types.isStatementInput(b) ? this.constants_.STATEMENT_INPUT_PADDING_LEFT : this.constants_.LARGE_PADDING;
    if (!LearnBlock.blockRendering.Types.isInput(a) && !b) return LearnBlock.blockRendering.Types.isField(a) && a.isEditable ? this.constants_.MEDIUM_PADDING :
        LearnBlock.blockRendering.Types.isIcon(a) ? 2 * this.constants_.LARGE_PADDING + 1 : LearnBlock.blockRendering.Types.isHat(a) ? this.constants_.NO_PADDING : LearnBlock.blockRendering.Types.isPreviousOrNextConnection(a) ? this.constants_.LARGE_PADDING : LearnBlock.blockRendering.Types.isLeftRoundedCorner(a) ? this.constants_.MIN_BLOCK_WIDTH : LearnBlock.blockRendering.Types.isJaggedEdge(a) ? this.constants_.NO_PADDING : this.constants_.LARGE_PADDING;
    if (LearnBlock.blockRendering.Types.isInput(a) && !b) {
        if (LearnBlock.blockRendering.Types.isExternalInput(a)) return this.constants_.NO_PADDING;
        if (LearnBlock.blockRendering.Types.isInlineInput(a)) return this.constants_.LARGE_PADDING;
        if (LearnBlock.blockRendering.Types.isStatementInput(a)) return this.constants_.NO_PADDING
    }
    if (!LearnBlock.blockRendering.Types.isInput(a) && b && LearnBlock.blockRendering.Types.isInput(b)) {
        if (a.isEditable) {
            if (LearnBlock.blockRendering.Types.isInlineInput(b) || LearnBlock.blockRendering.Types.isExternalInput(b)) return this.constants_.SMALL_PADDING
        } else {
            if (LearnBlock.blockRendering.Types.isInlineInput(b) || LearnBlock.blockRendering.Types.isExternalInput(b)) return this.constants_.MEDIUM_LARGE_PADDING;
            if (LearnBlock.blockRendering.Types.isStatementInput(b)) return this.constants_.LARGE_PADDING
        }
        return this.constants_.LARGE_PADDING - 1
    }
    if (LearnBlock.blockRendering.Types.isIcon(a) && b && !LearnBlock.blockRendering.Types.isInput(b)) return this.constants_.LARGE_PADDING;
    if (LearnBlock.blockRendering.Types.isInlineInput(a) && b && !LearnBlock.blockRendering.Types.isInput(b)) return b.isEditable ? this.constants_.MEDIUM_PADDING : this.constants_.LARGE_PADDING;
    if (LearnBlock.blockRendering.Types.isLeftSquareCorner(a) && b) {
        if (LearnBlock.blockRendering.Types.isHat(b)) return this.constants_.NO_PADDING;
        if (LearnBlock.blockRendering.Types.isPreviousConnection(b)) return b.notchOffset;
        if (LearnBlock.blockRendering.Types.isNextConnection(b)) {
            var c = (this.RTL ? 1 : -1) * this.constants_.DARK_PATH_OFFSET / 2;
            return b.notchOffset + c
        }
    }
    if (LearnBlock.blockRendering.Types.isLeftRoundedCorner(a) && b) {
        if (LearnBlock.blockRendering.Types.isPreviousConnection(b)) return b.notchOffset - this.constants_.CORNER_RADIUS;
        if (LearnBlock.blockRendering.Types.isNextConnection(b)) return c = (this.RTL ? 1 : -1) * this.constants_.DARK_PATH_OFFSET / 2, b.notchOffset -
            this.constants_.CORNER_RADIUS + c
    }
    return !LearnBlock.blockRendering.Types.isInput(a) && b && !LearnBlock.blockRendering.Types.isInput(b) && a.isEditable == b.isEditable || b && LearnBlock.blockRendering.Types.isJaggedEdge(b) ? this.constants_.LARGE_PADDING : this.constants_.MEDIUM_PADDING
};
LearnBlock.geras.RenderInfo.prototype.addAlignmentPadding_ = function (a, b) {
    var c = a.getFirstSpacer(),
        d = a.getLastSpacer();
    if (a.hasExternalInput || a.hasStatement) a.widthWithConnectedBlocks += b;
    a.align == LearnBlock.ALIGN_LEFT ? d.width += b : a.align == LearnBlock.ALIGN_CENTRE ? (c.width += b / 2, d.width += b / 2) : a.align == LearnBlock.ALIGN_RIGHT ? c.width += b : d.width += b;
    a.width += b
};
LearnBlock.geras.RenderInfo.prototype.getSpacerRowHeight_ = function (a, b) {
    return LearnBlock.blockRendering.Types.isTopRow(a) && LearnBlock.blockRendering.Types.isBottomRow(b) ? this.constants_.EMPTY_BLOCK_SPACER_HEIGHT : LearnBlock.blockRendering.Types.isTopRow(a) || LearnBlock.blockRendering.Types.isBottomRow(b) ? this.constants_.NO_PADDING : a.hasExternalInput && b.hasExternalInput ? this.constants_.LARGE_PADDING : !a.hasStatement && b.hasStatement ? this.constants_.BETWEEN_STATEMENT_PADDING_Y : a.hasStatement && b.hasStatement || !a.hasStatement &&
        b.hasDummyInput || a.hasDummyInput ? this.constants_.LARGE_PADDING : this.constants_.MEDIUM_PADDING
};
LearnBlock.geras.RenderInfo.prototype.getElemCenterline_ = function (a, b) {
    if (LearnBlock.blockRendering.Types.isSpacer(b)) return a.yPos + b.height / 2;
    if (LearnBlock.blockRendering.Types.isBottomRow(a)) {
        var c = a.yPos + a.height - a.descenderHeight;
        return LearnBlock.blockRendering.Types.isNextConnection(b) ? c + b.height / 2 : c - b.height / 2
    }
    if (LearnBlock.blockRendering.Types.isTopRow(a)) return LearnBlock.blockRendering.Types.isHat(b) ? a.capline - b.height / 2 : a.capline + b.height / 2;
    c = a.yPos;
    LearnBlock.blockRendering.Types.isField(b) || LearnBlock.blockRendering.Types.isIcon(b) ?
        (c += b.height / 2, (a.hasInlineInput || a.hasStatement) && b.height + this.constants_.TALL_INPUT_FIELD_OFFSET_Y <= a.height && (c += this.constants_.TALL_INPUT_FIELD_OFFSET_Y)) : c = LearnBlock.blockRendering.Types.isInlineInput(b) ? c + b.height / 2 : c + a.height / 2;
    return c
};
LearnBlock.geras.RenderInfo.prototype.finalize_ = function () {
    for (var a = 0, b = 0, c = 0, d; d = this.rows[c]; c++) {
        d.yPos = b;
        d.xPos = this.startX;
        b += d.height;
        a = Math.max(a, d.widthWithConnectedBlocks);
        var e = b - this.topRow.ascenderHeight;
        d == this.bottomRow && e < this.constants_.MIN_BLOCK_HEIGHT && (e = this.constants_.MIN_BLOCK_HEIGHT - e, this.bottomRow.height += e, b += e);
        this.recordElemPositions_(d)
    }
    this.bottomRow.baseline = b - this.bottomRow.descenderHeight;
    this.widthWithChildren = a + this.startX + this.constants_.DARK_PATH_OFFSET;
    this.width +=
        this.constants_.DARK_PATH_OFFSET;
    this.height = b + this.constants_.DARK_PATH_OFFSET;
    this.startY = this.topRow.capline
};
//An object that draws a block based on the given rendering information
LearnBlock.geras.Drawer = function (a, b) {
    LearnBlock.geras.Drawer.superClass_.constructor.call(this, a, b);
    this.highlighter_ = new LearnBlock.geras.Highlighter(b)
};
LearnBlock.utils.object.inherits(LearnBlock.geras.Drawer, LearnBlock.blockRendering.Drawer);
//Override methods
LearnBlock.geras.Drawer.prototype.draw = function () {
    this.drawOutline_();
    this.drawInternals_();
    this.block_.pathObject.setPaths(this.outlinePath_ + "\n" + this.inlinePath_, this.highlighter_.getPath());
    this.info_.RTL && this.block_.pathObject.flipRTL();
    LearnBlock.blockRendering.useDebugger && this.block_.renderingDebugger.drawDebug(this.block_, this.info_);
    this.recordSizeOnBlock_()
};
LearnBlock.geras.Drawer.prototype.drawTop_ = function () {
    this.highlighter_.drawTopCorner(this.info_.topRow);
    this.highlighter_.drawRightSideRow(this.info_.topRow);
    LearnBlock.geras.Drawer.superClass_.drawTop_.call(this)
};
LearnBlock.geras.Drawer.prototype.drawJaggedEdge_ = function (a) {
    this.highlighter_.drawJaggedEdge_(a);
    LearnBlock.geras.Drawer.superClass_.drawJaggedEdge_.call(this, a)
};
LearnBlock.geras.Drawer.prototype.drawValueInput_ = function (a) {
    this.highlighter_.drawValueInput(a);
    LearnBlock.geras.Drawer.superClass_.drawValueInput_.call(this, a)
};
LearnBlock.geras.Drawer.prototype.drawStatementInput_ = function (a) {
    this.highlighter_.drawStatementInput(a);
    LearnBlock.geras.Drawer.superClass_.drawStatementInput_.call(this, a)
};
LearnBlock.geras.Drawer.prototype.drawRightSideRow_ = function (a) {
    this.highlighter_.drawRightSideRow(a);
    LearnBlock.geras.Drawer.superClass_.drawRightSideRow_.call(this, a)
};
LearnBlock.geras.Drawer.prototype.drawBottom_ = function () {
    this.highlighter_.drawBottomRow(this.info_.bottomRow);
    LearnBlock.geras.Drawer.superClass_.drawBottom_.call(this)
};
//Adds steps for the left side of the block, which may include an output connection
LearnBlock.geras.Drawer.prototype.drawLeft_ = function () {
    this.highlighter_.drawLeft();
    LearnBlock.geras.Drawer.superClass_.drawLeft_.call(this)
};
//Override methods
LearnBlock.geras.Drawer.prototype.drawInlineInput_ = function (a) {
    this.highlighter_.drawInlineInput(a);
    LearnBlock.geras.Drawer.superClass_.drawInlineInput_.call(this, a)
};
LearnBlock.geras.Drawer.prototype.positionInlineInputConnection_ = function (a) {
    var b = a.centerline - a.height / 2;
    if (a.connection) {
        var c = a.xPos + a.connectionWidth + this.constants_.DARK_PATH_OFFSET;
        this.info_.RTL && (c *= -1);
        a.connection.setOffsetInBlock(c, b + a.connectionOffsetY + this.constants_.DARK_PATH_OFFSET)
    }
};
LearnBlock.geras.Drawer.prototype.positionStatementInputConnection_ = function (a) {
    var b = a.getLastInput();
    if (b.connection) {
        var c = a.xPos + a.statementEdge + b.notchOffset;
        c = this.info_.RTL ? -1 * c : c + this.constants_.DARK_PATH_OFFSET;
        b.connection.setOffsetInBlock(c, a.yPos + this.constants_.DARK_PATH_OFFSET)
    }
};
LearnBlock.geras.Drawer.prototype.positionExternalValueConnection_ = function (a) {
    var b = a.getLastInput();
    if (b.connection) {
        var c = a.xPos + a.width + this.constants_.DARK_PATH_OFFSET;
        this.info_.RTL && (c *= -1);
        b.connection.setOffsetInBlock(c, a.yPos)
    }
};
LearnBlock.geras.Drawer.prototype.positionNextConnection_ = function () {
    var a = this.info_.bottomRow;
    if (a.connection) {
        a = a.connection;
        var b = a.xPos;
        a.connectionModel.setOffsetInBlock((this.info_.RTL ? -b : b) + this.constants_.DARK_PATH_OFFSET / 2, a.centerline - a.height / 2 + this.constants_.DARK_PATH_OFFSET)
    }
};
//An object that provides constants for rendering highlights on blocks
LearnBlock.geras.HighlightConstantProvider = function (a) {
    this.constantProvider = a;
    this.OFFSET = .5;
    this.START_POINT = LearnBlock.utils.svgPaths.moveBy(this.OFFSET, this.OFFSET);
    this.INSIDE_CORNER = this.makeInsideCorner();
    this.OUTSIDE_CORNER = this.makeOutsideCorner();
    this.PUZZLE_TAB = this.makePuzzleTab();
    this.NOTCH = this.makeNotch();
    this.START_HAT = this.makeStartHat()
};
//An object containing sizing and path information about inside corner highlights
LearnBlock.geras.HighlightConstantProvider.prototype.makeInsideCorner = function () {
    var a = this.constantProvider.CORNER_RADIUS,
        b = this.OFFSET,
        c = (1 - Math.SQRT1_2) * (a + b) - b,
        d = LearnBlock.utils.svgPaths.moveBy(c, c) + LearnBlock.utils.svgPaths.arc("a", "0 0,0", a, LearnBlock.utils.svgPaths.point(-c - b, a - c)),
        e = LearnBlock.utils.svgPaths.arc("a", "0 0,0", a + b, LearnBlock.utils.svgPaths.point(a + b, a + b)),
        f = LearnBlock.utils.svgPaths.moveBy(c, -c) + LearnBlock.utils.svgPaths.arc("a", "0 0,0", a + b, LearnBlock.utils.svgPaths.point(a - c, c + b));
    return {
        width: a + b,
        height: a,
        pathTop: function (a) {
            return a ? d : ""
        },
        pathBottom: function (a) {
            return a ? e : f
        }
    }
};
//An object containing sizing and path information about outside corner highlights
LearnBlock.geras.HighlightConstantProvider.prototype.makeOutsideCorner = function () {
    var a = this.constantProvider.CORNER_RADIUS,
        b = this.OFFSET,
        c = (1 - Math.SQRT1_2) * (a - b) + b,
        d = LearnBlock.utils.svgPaths.moveBy(c, c) + LearnBlock.utils.svgPaths.arc("a", "0 0,1", a - b, LearnBlock.utils.svgPaths.point(a - c, -c + b)),
        e = LearnBlock.utils.svgPaths.moveBy(b, a) + LearnBlock.utils.svgPaths.arc("a", "0 0,1", a - b, LearnBlock.utils.svgPaths.point(a, -a + b)),
        f = -c,
        g = LearnBlock.utils.svgPaths.moveBy(c, f) + LearnBlock.utils.svgPaths.arc("a", "0 0,1", a - b, LearnBlock.utils.svgPaths.point(-c +
            b, -f - a));
    return {
        height: a,
        topLeft: function (a) {
            return a ? d : e
        },
        bottomLeft: function () {
            return g
        }
    }
};
//An object containing sizing and path information about puzzle tab highlights
LearnBlock.geras.HighlightConstantProvider.prototype.makePuzzleTab = function () {
    var a = this.constantProvider.TAB_WIDTH,
        b = this.constantProvider.TAB_HEIGHT,
        c = LearnBlock.utils.svgPaths.moveBy(-2, -b + 3.4) + LearnBlock.utils.svgPaths.lineTo(-.45 * a, -2.1),
        d = LearnBlock.utils.svgPaths.lineOnAxis("v", 2.5) + LearnBlock.utils.svgPaths.moveBy(.97 * -a, 2.5) + LearnBlock.utils.svgPaths.curve("q", [LearnBlock.utils.svgPaths.point(.05 * -a, 10), LearnBlock.utils.svgPaths.point(.3 * a, 9.5)]) + LearnBlock.utils.svgPaths.moveBy(.67 * a, -1.9) + LearnBlock.utils.svgPaths.lineOnAxis("v",
            2.5),
        e = LearnBlock.utils.svgPaths.lineOnAxis("v", -1.5) + LearnBlock.utils.svgPaths.moveBy(-.92 * a, -.5) + LearnBlock.utils.svgPaths.curve("q", [LearnBlock.utils.svgPaths.point(-.19 * a, -5.5), LearnBlock.utils.svgPaths.point(0, -11)]) + LearnBlock.utils.svgPaths.moveBy(.92 * a, 1),
        f = LearnBlock.utils.svgPaths.moveBy(-5, b - .7) + LearnBlock.utils.svgPaths.lineTo(.46 * a, -2.1);
    return {
        width: a,
        height: b,
        pathUp: function (a) {
            return a ? c : e
        },
        pathDown: function (a) {
            return a ? d : f
        }
    }
};
//An object containing sizing and path information about notch highlights
LearnBlock.geras.HighlightConstantProvider.prototype.makeNotch = function () {
    return {
        pathLeft: LearnBlock.utils.svgPaths.lineOnAxis("h", this.OFFSET) + this.constantProvider.NOTCH.pathLeft
    }
};
//An object containing sizing and path information about start highlights
LearnBlock.geras.HighlightConstantProvider.prototype.makeStartHat = function () {
    var a = this.constantProvider.START_HAT.height,
        b = LearnBlock.utils.svgPaths.moveBy(25, -8.7) + LearnBlock.utils.svgPaths.curve("c", [LearnBlock.utils.svgPaths.point(29.7, -6.2), LearnBlock.utils.svgPaths.point(57.2, -.5), LearnBlock.utils.svgPaths.point(75, 8.7)]),
        c = LearnBlock.utils.svgPaths.curve("c", [LearnBlock.utils.svgPaths.point(17.8, -9.2), LearnBlock.utils.svgPaths.point(45.3, -14.9), LearnBlock.utils.svgPaths.point(75, -8.7)]) + LearnBlock.utils.svgPaths.moveTo(100.5,
            a + .5);
    return {
        path: function (a) {
            return a ? b : c
        }
    }
};
//The geras renderer
LearnBlock.geras.Renderer = function () {
    LearnBlock.geras.Renderer.superClass_.constructor.call(this);
    this.highlightConstants_ = null
};
LearnBlock.utils.object.inherits(LearnBlock.geras.Renderer, LearnBlock.blockRendering.Renderer);
//Initializes the renderer
LearnBlock.geras.Renderer.prototype.init = function () {
    LearnBlock.geras.Renderer.superClass_.init.call(this);
    this.highlightConstants_ = this.makeHighlightConstants_()
};
//Override method
LearnBlock.geras.Renderer.prototype.makeConstants_ = function () {
    return new LearnBlock.geras.ConstantProvider
};
//Creates a new instance of the renderer's render info object
LearnBlock.geras.Renderer.prototype.makeRenderInfo_ = function (a) {
    return new LearnBlock.geras.RenderInfo(this, a)
};
//Creates a new instance of the renderer's drawer
LearnBlock.geras.Renderer.prototype.makeDrawer_ = function (a, b) {
    return new LearnBlock.geras.Drawer(a, b)
};
//Creates a new instance of a renderer path object
LearnBlock.geras.Renderer.prototype.makePathObject = function (a) {
    return new LearnBlock.geras.PathObject(a)
};
//Creates a new instance of the renderer's highlight constant provider
LearnBlock.blockRendering.Renderer.prototype.makeHighlightConstants_ = function () {
    return new LearnBlock.geras.HighlightConstantProvider(this.getConstants())
};
//Gets the renderer's highlight constant provider
LearnBlock.geras.Renderer.prototype.getHighlightConstants = function () {
    return this.highlightConstants_
};
LearnBlock.blockRendering.register("geras", LearnBlock.geras.Renderer);

//Class for the toolbox
LearnBlock.Toolbox = function (a) {
    this.workspace_ = a;
    this.RTL = a.options.RTL;
    this.horizontalLayout_ = a.options.horizontalLayout;
    this.toolboxPosition = a.options.toolboxPosition;
    this.config_ = {
        indentWidth: 19,
        cssRoot: "blocklyTreeRoot",
        cssHideRoot: "blocklyHidden",
        cssTreeRow: "blocklyTreeRow",
        cssItemLabel: "blocklyTreeLabel",
        cssTreeIcon: "blocklyTreeIcon",
        cssExpandedFolderIcon: "blocklyTreeIconOpen",
        cssFileIcon: "blocklyTreeIconNone",
        cssSelectedRow: "blocklyTreeSelected"
    };
    this.treeSeparatorConfig_ = {
        cssTreeRow: "blocklyTreeSeparator"
    };
    this.horizontalLayout_ && (this.config_.cssTreeRow += a.RTL ? " blocklyHorizontalTreeRtl" : " blocklyHorizontalTree", this.treeSeparatorConfig_.cssTreeRow = "blocklyTreeSeparatorHorizontal " + (a.RTL ? "blocklyHorizontalTreeRtl" : "blocklyHorizontalTree"), this.config_.cssTreeIcon = "")
};
LearnBlock.Toolbox.prototype.width = 0;
LearnBlock.Toolbox.prototype.height = 0;
LearnBlock.Toolbox.prototype.selectedOption_ = null;
LearnBlock.Toolbox.prototype.lastCategory_ = null;
//Initializes the toolbox
LearnBlock.Toolbox.prototype.init = function () {
    var a = this.workspace_,
        b = this.workspace_.getParentSvg();
    this.HtmlDiv = document.createElement("div");
    this.HtmlDiv.className = "blocklyToolboxDiv blocklyNonSelectable";
    this.HtmlDiv.setAttribute("dir", a.RTL ? "RTL" : "LTR");
    b.parentNode.insertBefore(this.HtmlDiv, b);
    b = a.getThemeManager();
    b.subscribe(this.HtmlDiv, "toolbox", "background-color");
    b.subscribe(this.HtmlDiv, "toolboxText", "color");
    LearnBlock.bindEventWithChecks_(this.HtmlDiv, "mousedown", this, function (a) {
        LearnBlock.utils.isRightButton(a) ||
            a.target == this.HtmlDiv ? LearnBlock.hideChaff(!1) : LearnBlock.hideChaff(!0);
        LearnBlock.Touch.clearTouchIdentifier()
    }, !1, !0);
    b = {
        disabledPatternId: a.options.disabledPatternId,
        parentWorkspace: a,
        RTL: a.RTL,
        oneBasedIndex: a.options.oneBasedIndex,
        horizontalLayout: a.horizontalLayout,
        toolboxPosition: a.options.toolboxPosition,
        renderer: a.options.renderer
    };
    this.flyout_ = null;
    if (a.horizontalLayout) {
        if (!LearnBlock.HorizontalFlyout) throw Error("Missing require for LearnBlock.HorizontalFlyout");
        this.flyout_ = new LearnBlock.HorizontalFlyout(b)
    } else {
        if (!LearnBlock.VerticalFlyout) throw Error("Missing require for LearnBlock.VerticalFlyout");
        this.flyout_ = new LearnBlock.VerticalFlyout(b)
    }
    LearnBlock.utils.dom.insertAfter(this.flyout_.createDom("svg"), this.workspace_.getParentSvg());
    this.flyout_.init(a);
    this.config_.cleardotPath = a.options.pathToMedia + "1x1.gif";
    this.config_.cssCollapsedFolderIcon = "blocklyTreeIconClosed" + (a.RTL ? "Rtl" : "Ltr");
    this.renderTree(a.options.languageTree)
};
//Fills the toolbox with categories and blocks
LearnBlock.Toolbox.prototype.renderTree = function (a) {
    this.tree_ && (this.tree_.dispose(), this.lastCategory_ = null);
    var b = new LearnBlock.tree.TreeControl(this, this.config_);
    this.tree_ = b;
    b.setSelectedItem(null);
    b.onBeforeSelected(this.handleBeforeTreeSelected_);
    b.onAfterSelected(this.handleAfterTreeSelected_);
    var c = null;
    if (a) {
        this.tree_.blocks = [];
        this.hasColours_ = !1;
        c = this.syncTrees_(a, this.tree_, this.workspace_.options.pathToMedia);
        if (this.tree_.blocks.length) throw Error("Toolbox cannot have both blocks and categories in the root level.");
        this.workspace_.resizeContents()
    }
    b.render(this.HtmlDiv);
    c && b.setSelectedItem(c);
    this.position();
    this.horizontalLayout_ && LearnBlock.utils.aria.setState(this.tree_.getElement(), LearnBlock.utils.aria.State.ORIENTATION, "horizontal")
};
//Handles the before tree item selected action
LearnBlock.Toolbox.prototype.handleBeforeTreeSelected_ = function (a) {
    if (a == this.tree_) return !1;
    this.lastCategory_ && (this.lastCategory_.getRowElement().style.backgroundColor = "");
    if (a) {
        var b = a.hexColour || "#57e";
        a.getRowElement().style.backgroundColor = b;
    }
    return !0
};
//Handles the after tree item selected action
LearnBlock.Toolbox.prototype.handleAfterTreeSelected_ = function (a, b) {
    b && b.blocks && b.blocks.length ? (this.flyout_.show(b.blocks), this.lastCategory_ != b && this.flyout_.scrollToStart(), LearnBlock.keyboardAccessibilityMode && LearnBlock.navigation.setState(LearnBlock.navigation.STATE_TOOLBOX)) : (this.flyout_.hide(), !LearnBlock.keyboardAccessibilityMode || b instanceof LearnBlock.Toolbox.TreeSeparator || LearnBlock.navigation.setState(LearnBlock.navigation.STATE_WS));
    if (a != b && a != this) {
        var c = new LearnBlock.Events.Ui(null, "category", a && a.getText(),
            b && b.getText());
        c.workspaceId = this.workspace_.id;
        LearnBlock.Events.fire(c)
    }
    b && (this.lastCategory_ = b)
};
//Handles the given Blockly action on a toolbox
LearnBlock.Toolbox.prototype.onBlocklyAction = function (a) {
    var b = this.tree_.getSelectedItem();
    if (!b) return !1;
    switch (a.name) {
        case LearnBlock.navigation.actionNames.PREVIOUS:
            return b.selectPrevious();
        case LearnBlock.navigation.actionNames.OUT:
            return b.selectParent();
        case LearnBlock.navigation.actionNames.NEXT:
            return b.selectNext();
        case LearnBlock.navigation.actionNames.IN:
            return b.selectChild();
        default:
            return !1
    }
};
//Dispose of the toolbox
LearnBlock.Toolbox.prototype.dispose = function () {
    this.flyout_.dispose();
    this.tree_.dispose();
    this.workspace_.getThemeManager().unsubscribe(this.HtmlDiv);
    LearnBlock.utils.dom.removeNode(this.HtmlDiv);
    this.lastCategory_ = this.workspace_ = null
};
//Gets the width of the toolbox
LearnBlock.Toolbox.prototype.getWidth = function () {
    return this.width
};
//Gets the height of the toolbox
LearnBlock.Toolbox.prototype.getHeight = function () {
    return this.height
};
//Moves the toolbox to the edge
LearnBlock.Toolbox.prototype.position = function () {
    var a = this.HtmlDiv;
    if (a) {
        var b = this.workspace_.getParentSvg();
        b = LearnBlock.svgSize(b);
        this.horizontalLayout_ ? (a.style.left = "0", a.style.height = 30 + "px", a.style.width = 800 + "px", this.height = a.offsetHeight, this.toolboxPosition == LearnBlock.TOOLBOX_AT_TOP ? a.style.top = "0" : a.style.bottom = "0") : (this.toolboxPosition == LearnBlock.TOOLBOX_AT_RIGHT ? a.style.right = "0" : a.style.left = "0", a.style.height = b.height + "px", this.width = a.offsetWidth);
        this.flyout_.position()
    }
};
//Syncs trees of the toolbox
LearnBlock.Toolbox.prototype.syncTrees_ = function (a, b, c) {
    for (var d = null, e = null, f = 0, g; g = a.childNodes[f]; f++)
        if (g.tagName) switch (g.tagName.toUpperCase()) {
            case "CATEGORY":
                e = LearnBlock.utils.replaceMessageReferences(g.getAttribute("name"));
                var h = this.tree_.createNode(e);
                h.blocks = [];
                b.add(h);
                var k = g.getAttribute("custom");
                k ? h.blocks = k : (k = this.syncTrees_(g, h, c)) && (d = k);
                k = g.getAttribute("categorystyle");
                "true" == g.getAttribute("expanded") ? (h.blocks.length && (d = h), h.setExpanded(!0)) : h.setExpanded(!1);
                e = g;
                break;
            case "SEP":
                if (e && "CATEGORY" == e.tagName.toUpperCase()) {
                    b.add(new LearnBlock.Toolbox.TreeSeparator(this.treeSeparatorConfig_));
                    break
                }
                case "BLOCK":
                case "BUTTON":
                    b.blocks.push(g), e = g
        }
    return d
};
//Unhighlights any previously specified option
LearnBlock.Toolbox.prototype.clearSelection = function () {
    console.log(this.tree_.getSelectedItem())
    this.tree_.setSelectedItem(null)
    //!!!!!
    //this.lastCategory_ = null;
};
//Adds a style on the toolbox
LearnBlock.Toolbox.prototype.addStyle = function (a) {
    LearnBlock.utils.dom.addClass(this.HtmlDiv, a)
};
//Removes a style from the toolbox
LearnBlock.Toolbox.prototype.removeStyle = function (a) {
    LearnBlock.utils.dom.removeClass(this.HtmlDiv, a)
};
//Returns the deletion rectangle for this toolbox
LearnBlock.Toolbox.prototype.getClientRect = function () {
    if (!this.HtmlDiv) return null;
    var a = this.HtmlDiv.getBoundingClientRect(),
        b = a.top,
        c = b + a.height,
        d = a.left;
    a = d + a.width;
    return this.toolboxPosition == LearnBlock.TOOLBOX_AT_TOP ? new LearnBlock.utils.Rect(-1E7, c, -1E7, 1E7) : this.toolboxPosition == LearnBlock.TOOLBOX_AT_BOTTOM ? new LearnBlock.utils.Rect(b, 1E7, -1E7, 1E7) : this.toolboxPosition == LearnBlock.TOOLBOX_AT_LEFT ? new LearnBlock.utils.Rect(-1E7, 1E7, -1E7, a) : new LearnBlock.utils.Rect(-1E7, 1E7, d, 1E7)
};
//Updates the flyout's contents without closing it
LearnBlock.Toolbox.prototype.refreshSelection = function () {
    var a = this.tree_.getSelectedItem();
    a && a.blocks && this.flyout_.show(a.blocks)
};
//Selects the first toolbox category if no category is selected
LearnBlock.Toolbox.prototype.selectFirstCategory = function () {
    this.tree_.getSelectedItem() || this.tree_.selectFirst()
};
//A blank separator node in the tree
LearnBlock.Toolbox.TreeSeparator = function (a) {
    LearnBlock.tree.TreeNode.call(this, null, "", a)
};
LearnBlock.utils.object.inherits(LearnBlock.Toolbox.TreeSeparator, LearnBlock.tree.TreeNode);

//Dynamic Variables
LearnBlock.VariablesDynamic = {};
//Button for String variable
LearnBlock.VariablesDynamic.onCreateVariableButtonClick_String = function (a) {
    LearnBlock.Variables.createVariableButtonHandler(a.getTargetWorkspace(), null, "String")
};
//Button for Number variable
LearnBlock.VariablesDynamic.onCreateVariableButtonClick_Number = function (a) {
    LearnBlock.Variables.createVariableButtonHandler(a.getTargetWorkspace(), null, "Number")
};
//Constructs the elements (blocks and button) required by the flyout for the variable category
LearnBlock.VariablesDynamic.flyoutCategory = function (a) {
    var b = [],
        c = document.createElement("button");
    c.setAttribute("text", LearnBlock.Msg.NEW_STRING_VARIABLE);
    c.setAttribute("callbackKey", "CREATE_VARIABLE_STRING");
    b.push(c);
    c = document.createElement("button");
    c.setAttribute("text", LearnBlock.Msg.NEW_NUMBER_VARIABLE);
    c.setAttribute("callbackKey", "CREATE_VARIABLE_NUMBER");
    b.push(c);
    a.registerButtonCallback("CREATE_VARIABLE_STRING", LearnBlock.VariablesDynamic.onCreateVariableButtonClick_String);
    a.registerButtonCallback("CREATE_VARIABLE_NUMBER", LearnBlock.VariablesDynamic.onCreateVariableButtonClick_Number);
    a = LearnBlock.VariablesDynamic.flyoutCategoryBlocks(a);
    return b = b.concat(a)
};
//Constructs the blocks required by the flyout for the variable category
LearnBlock.VariablesDynamic.flyoutCategoryBlocks = function (a) {
    a = a.getAllVariables();
    var b = [];
    if (0 < a.length) {
        if (LearnBlock.Blocks.variables_set_dynamic) {
            //Setter block
            var c = a[a.length - 1],
                d = LearnBlock.utils.xml.createElement("block");
            d.setAttribute("type", "variables_set_dynamic");
            d.setAttribute("gap", 24);
            d.appendChild(LearnBlock.Variables.generateVariableFieldDom(c));
            b.push(d)
        }
        if (LearnBlock.Blocks.variables_get_dynamic) {
            //Getter block: input and output
            a.sort(LearnBlock.VariableModel.compareByName);
            c = 0;
            for (var e; e = a[c]; c++) {
                d = LearnBlock.utils.xml.createElement("block"),
                    d.setAttribute("type", "variables_get_dynamic"), d.setAttribute("gap", 8), d.appendChild(LearnBlock.Variables.generateVariableFieldDom(e)), b.push(d)
            }
        }
        if (LearnBlock.Blocks['variables_get_dynamic2']) {
            //Getter block: output
            a.sort(LearnBlock.VariableModel.compareByName);
            c = 0;
            for (var e; e = a[c]; c++) {
                d = LearnBlock.utils.xml.createElement("block"),
                    d.setAttribute("type", "variables_get_dynamic2"), d.setAttribute("gap", 8), d.appendChild(LearnBlock.Variables.generateVariableFieldDom(e)), b.push(d)
            }
        }
        if (LearnBlock.Blocks['variables_get_dynamic3']) {
            //Getter block: prev and next statements
            a.sort(LearnBlock.VariableModel.compareByName);
            c = 0;
            for (var e; e = a[c]; c++) {
                d = LearnBlock.utils.xml.createElement("block"),
                    d.setAttribute("type", "variables_get_dynamic3"), d.setAttribute("gap", 8), d.appendChild(LearnBlock.Variables.generateVariableFieldDom(e)), b.push(d)
            }
        }
    }
    return b
};

LearnBlock.requires = {};
